<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Kotlin使用技巧一-接口与命名参数的优雅运用]]></title>
      <url>/Kotlin%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E4%B8%80-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%91%BD%E5%90%8D%E5%8F%82%E6%95%B0%E7%9A%84%E4%BC%98%E9%9B%85%E8%BF%90%E7%94%A8.html</url>
      <content type="html"><![CDATA[<p><strong>版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起.</strong></p>
<hr>
<blockquote>
<p>文章首发于我的<a href="https://www.jianshu.com/u/2334b8b9f764" target="_blank" rel="noopener">简书</a>,本处只做整理归档用<br><a id="more"></a></p>
</blockquote>
<h3 id="抛出问题"><a href="#抛出问题" class="headerlink" title="抛出问题"></a>抛出问题</h3><p>看过我的<a href="https://www.jianshu.com/p/35c91abaae44" target="_blank" rel="noopener">Kotlin-高阶函数的使用(二)</a>都知道，我们的<code>setOnClickListener</code>可以这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">view.setOnClickListener &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是当接口有多个实现方法的时候我们可能就需要这样实现了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">edittext.addTextChangedListener(object :TextWatcher&#123;</span><br><span class="line">            override fun afterTextChanged(s: Editable?) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure></p>
<p>通常我们只需要在<code>onTextChanged</code>里执行一些逻辑，其余的方法用不到，这样就显得很不优雅了，那有没有办法显得更加的优雅呢,答案肯定是有哒~~~</p>
<h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><h4 id="1-使用扩展函数封装对应的方法"><a href="#1-使用扩展函数封装对应的方法" class="headerlink" title="1.使用扩展函数封装对应的方法"></a>1.使用扩展函数封装对应的方法</h4><p>我们可以使用扩展方法内部实现3个方法，然后让其中一个方法<code>invoke</code>出去，实现之后像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">edittext.onTextChanged &#123; s, start, before, count -&gt;</span><br><span class="line">            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fun EditText.onTextChanged(changed:(s: CharSequence?, start: Int, before: Int, count: Int)-&gt;Unit)&#123;</span><br><span class="line">     addTextChangedListener(object : TextWatcher&#123;</span><br><span class="line">         override fun afterTextChanged(s: Editable?) &#123;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) &#123;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) &#123;</span><br><span class="line">             changed(s,start,before, count)</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>这里我假设你已经理解了扩展函数的使用，如果看不太懂，可以先看看我的这篇文章<a href="https://www.jianshu.com/p/7a771317ab74" target="_blank" rel="noopener">Kotlin-高阶函数的使用(一)</a></p>
</blockquote>
<p>代码一下子清爽起来了，并且我可以专注于一个方法逻辑的实现，但是有一个缺点，万一我需要在<code>beforeTextChanged</code>里实现一些逻辑呢，万一我想实现其他的方法呢，有人会说我再申明一个<code>beforeTextChanged</code>的扩展方法啊，然后像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> edittext.onTextChanged &#123; s, start, before, count -&gt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">edittext.beforeTextChanged&#123;s, start, count, after-&gt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样写实际上是申明了两个监听，<code>onTextChanged</code>是会失效的，所以这种方案pass。我们可以想到在一个方法里申明多个<code>lambda</code>，貌似解决了问题，于是就像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">edittext.addTextChangedListener(&#123; s -&gt;</span><br><span class="line"></span><br><span class="line">       &#125;, &#123; s, start, count, after -&gt;</span><br><span class="line"></span><br><span class="line">       &#125;, &#123; s, start, before, count-&gt;</span><br><span class="line"></span><br><span class="line">       &#125;)</span><br></pre></td></tr></table></figure></p>
<p>实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fun EditText.addTextChangedListener(after:(s: Editable?)-&gt;Unit,before:(s: CharSequence?, start: Int, count: Int, after: Int)-&gt;Unit,</span><br><span class="line">                                    changed: (s: CharSequence?, start: Int, before: Int, count: Int) -&gt; Unit)&#123;</span><br><span class="line">    addTextChangedListener(object : TextWatcher&#123;</span><br><span class="line">        override fun afterTextChanged(s: Editable?) &#123;</span><br><span class="line">            after(s)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) &#123;</span><br><span class="line">            before(s, start, count, after)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) &#123;</span><br><span class="line">            changed(s,start,before, count)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我滴妈，这啥跟啥，谁要是这么写估计出门会被打。其实这种思路是对的，但是可能敲出来的代码他有自己的想法…..</p>
<h4 id="2-使用命名参数和默认值解决lambda方法区分问题"><a href="#2-使用命名参数和默认值解决lambda方法区分问题" class="headerlink" title="2.使用命名参数和默认值解决lambda方法区分问题"></a>2.使用命名参数和默认值解决lambda方法区分问题</h4><p>我们知道上面那种实现的缺点就是方法不易区分，so，我们只需要加入一个命名参数就解决问题啦：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">edittext.addTextChangedListener(</span><br><span class="line">        after = &#123; s -&gt;</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line">        before = &#123; s, start, count, after -&gt;</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line">        changed = &#123; s, start, before, count -&gt;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">inline fun EditText.addTextChangedListener(crossinline after:(s: Editable?)-&gt;Unit,</span><br><span class="line">                                           crossinline before:(s: CharSequence?, start: Int, count: Int, after: Int)-&gt;Unit,</span><br><span class="line">                                           crossinline changed: (s: CharSequence?, start: Int, before: Int, count: Int) -&gt; Unit)&#123;</span><br><span class="line">    addTextChangedListener(object : TextWatcher&#123;</span><br><span class="line">        override fun afterTextChanged(s: Editable?) &#123;</span><br><span class="line">            after(s)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) &#123;</span><br><span class="line">            before(s, start, count, after)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) &#123;</span><br><span class="line">            changed(s,start,before, count)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>使用<code>crossinline</code>关键字来规定命名参数，但必须申明方法为<code>inline</code>,关于内联，详见<a href="https://www.kotlincn.net/docs/reference/inline-functions.html" target="_blank" rel="noopener">官方文档</a></p>
</blockquote>
<p>这样看起来就清晰多了，每个<code>lambda</code>对应什么方法一目了然，但是，回到我们最初说的，我们有时只需要其中的一个方法的，这样还是要申明3个方法呀，别急，加个默认值搞定：<br>实现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">inline fun EditText.addTextChangedListener(crossinline after:(s: Editable?)-&gt;Unit=&#123;&#125;,</span><br><span class="line">                                           crossinline before:(s: CharSequence?, start: Int, count: Int, after: Int)-&gt;Unit=&#123;</span><br><span class="line">                                               _, _, _, _ -&gt; </span><br><span class="line">                                           &#125;,</span><br><span class="line">                                           crossinline changed: (s: CharSequence?, start: Int, before: Int, count: Int) -&gt; Unit=&#123;</span><br><span class="line">                                               _, _, _, _ -&gt;</span><br><span class="line">                                           &#125;)&#123;</span><br><span class="line">    addTextChangedListener(object : TextWatcher&#123;</span><br><span class="line">        override fun afterTextChanged(s: Editable?) &#123;</span><br><span class="line">            after(s)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) &#123;</span><br><span class="line">            before(s, start, count, after)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) &#123;</span><br><span class="line">            changed(s,start,before, count)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">edittext.addTextChangedListener(</span><br><span class="line">        changed = &#123; s, start, before, count -&gt;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>这样看起来就舒服多了，既达到了申明单个多个实现的灵活选择，又达到了方法名的命名区分，感觉人生已经到达了巅峰有木有！！</p>
<blockquote>
<p>我们知道如果方法申明了默认值，那么这个参数可以不申明，我们正是利用了这个特性来达到的效果,关于这个特性也可以用到接口上，当我们有些接口不想让它每次都实现，可以在接口后面加入一个返回值，如果没有返回值可以返回一个<code>Unit</code>，像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface Test &#123;</span><br><span class="line">    fun test1() = Unit</span><br><span class="line">    fun test2()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>这样的话<code>test2</code>为必须实现，<code>test1</code>就变成了选择实现</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>经过<code>addTextChangedListener</code>的一个例子，我们学习了扩展函数，接口与命名参数的运用，在实际项目中，建议读者们可以将常用的一些接口实现做一些封装，具体选择那种方式视实际情况而定，如果你不经常的使用它，那么就不用去特意去封装它，不然会造成方法臃肿。</p>
<p>关于方法与接口的封装，还有更加高级的用法，就是<code>DSL</code>,这种方案在<code>Anko</code>框架中使用的非常频繁，有兴趣的可以去研究一下</p>
]]></content>
      
        <categories>
            
            <category> Kotlin </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[flutter踩坑记录(持续更新中)]]></title>
      <url>/fluttercaikengjilv.html</url>
      <content type="html"><![CDATA[<p><strong>版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起.</strong></p>
<hr>
<blockquote>
<p>文章首发于我的<a href="https://www.jianshu.com/u/2334b8b9f764" target="_blank" rel="noopener">简书</a>,本处只做整理归档用<br><a id="more"></a></p>
</blockquote>
<h2 id="Flutter编译问题"><a href="#Flutter编译问题" class="headerlink" title="Flutter编译问题"></a>Flutter编译问题</h2><h4 id="1-Flutter编译时一直卡在”Resolving-dependencies”"><a href="#1-Flutter编译时一直卡在”Resolving-dependencies”" class="headerlink" title="1.Flutter编译时一直卡在”Resolving dependencies”"></a>1.Flutter编译时一直卡在”Resolving dependencies”</h4><p>原因：国内被墙的原因</p>
<p><strong>解决方案1：</strong><br>配置系统环境变量：</p>
<ul>
<li><code>PUB_HOSTED_URL</code>-&gt;<code>https://pub.flutter-io.cn</code></li>
<li><code>FLUTTER_STORAGE_BASE_URL</code>-&gt;<code>https://storage.flutter-io.cn</code><br>最新的变量地址请访问：<a href="https://flutter.io/community/china" target="_blank" rel="noopener">https://flutter.io/community/china</a></li>
</ul>
<p><strong>解决方案2：</strong><br>在<code>android</code>目录的<code>build.gradle</code>下添加阿里镜像代理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123; url &apos;https://maven.aliyun.com/repository/google&apos; &#125;</span><br><span class="line">        maven &#123; url &apos;https://maven.aliyun.com/repository/jcenter&apos; &#125;</span><br><span class="line">        maven &#123; url &apos;https://maven.aliyun.com/repository/public&apos; &#125;</span><br><span class="line">        maven &#123; url &apos;https://maven.aliyun.com/repository/gradle-plugin&apos; &#125;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath &apos;com.android.tools.build:gradle:3.2.1&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123; url &apos;https://maven.aliyun.com/repository/google&apos; &#125;</span><br><span class="line">        maven &#123; url &apos;https://maven.aliyun.com/repository/jcenter&apos; &#125;</span><br><span class="line">        maven &#123; url &apos;https://maven.aliyun.com/repository/public&apos; &#125;</span><br><span class="line">        maven &#123; url &apos;https://maven.aliyun.com/repository/gradle-plugin&apos; &#125;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>解决方案3：</strong><br>使用翻墙工具构建</p>
<h4 id="2-运行一些开源的项目编辑报错提示Finished-with-error-FormatException-Bad-UTF-8-encoding-0xc3-at-offset-169"><a href="#2-运行一些开源的项目编辑报错提示Finished-with-error-FormatException-Bad-UTF-8-encoding-0xc3-at-offset-169" class="headerlink" title="2.运行一些开源的项目编辑报错提示Finished with error: FormatException: Bad UTF-8 encoding 0xc3 (at offset 169)"></a>2.运行一些开源的项目编辑报错提示<code>Finished with error: FormatException: Bad UTF-8 encoding 0xc3 (at offset 169)</code></h4><p>原因：app的release版本找不到keystore文件<br>解决方案：<br>找到<code>android</code>-&gt;<code>app</code>目录下的<code>build.gradle</code>，找到<code>buildTypes</code>,修改<code>release</code>的<code>signingConfigs.release</code>为<code>debug</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">buildTypes &#123;</span><br><span class="line">    debug &#123;</span><br><span class="line">        signingConfig signingConfigs.debug</span><br><span class="line">    &#125;</span><br><span class="line">    release &#123;</span><br><span class="line">        signingConfig signingConfigs.debug</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>或者自己重新配置<code>release</code>的签名</p>
<h4 id="3-第一次构建Flutter项目一直卡在Initializing-gradle…"><a href="#3-第一次构建Flutter项目一直卡在Initializing-gradle…" class="headerlink" title="3.第一次构建Flutter项目一直卡在Initializing gradle…"></a>3.第一次构建Flutter项目一直卡在Initializing gradle…</h4><h5 id="结合网上博客总结，有两种解决方案"><a href="#结合网上博客总结，有两种解决方案" class="headerlink" title="结合网上博客总结，有两种解决方案"></a>结合网上博客总结，有两种解决方案</h5><p>1.修改镜像<br>博客地址:<a href="https://blog.csdn.net/qq_16071655/article/details/84106853" target="_blank" rel="noopener"><br>Flutter 运行 一直Initializing gradle…，和模拟器运行白屏问题</a></p>
<p>本人测试发现没有效果，于是找到了第二种解决方案,亲测有效</p>
<p>2.修改gradle下载地址<br>找到项目中的<code>android</code>-&gt;<code>gradle</code>-&gt;<code>wrapper</code>-&gt;<code>gradle-wrapper.properties</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#Fri Jun 23 08:50:38 CEST 2017</span><br><span class="line">distributionBase=GRADLE_USER_HOME</span><br><span class="line">distributionPath=wrapper/dists</span><br><span class="line">zipStoreBase=GRADLE_USER_HOME</span><br><span class="line">zipStorePath=wrapper/dists</span><br><span class="line">distributionUrl=https\://services.gradle.org/distributions/gradle-4.10.2-all.zip</span><br></pre></td></tr></table></figure></p>
<p>修改<code>distributionUrl</code>，可以先看一下你本地能运行的项目的gradle的配置，如果没有，可以修改为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">distributionUrl=https\://services.gradle.org/distributions/gradle-4.6-all.zip</span><br></pre></td></tr></table></figure></p>
<p>低版本是不行的，flutter需要的gradle版本需要4.6或更高才行,所以你本地如果比这个低也需要改成更高的。</p>
<p>我猜测是因为这个地址在本地是没有的，所以需要到<a href="http://services.gradle.org/distributions/" target="_blank" rel="noopener">gradle官网</a>上去下载，而在中国下载是巨慢的，所以会一直卡在那里，如果换成本地的就不需要去下载了，直接使用本地的gradle,所以就变快了。</p>
<h3 id="Flutter开发问题"><a href="#Flutter开发问题" class="headerlink" title="Flutter开发问题"></a>Flutter开发问题</h3><h4 id="1-使用Navigator-push-跳转界面报错："><a href="#1-使用Navigator-push-跳转界面报错：" class="headerlink" title="1.使用Navigator.push()跳转界面报错："></a>1.使用<code>Navigator.push()</code>跳转界面报错：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&apos;Navigator operation requested with a context that does not include a Navigator.\n&apos;</span><br><span class="line">&apos;The context used to push or pop routes from the Navigator must be that of a &apos;</span><br><span class="line">&apos;widget that is a descendant of a Navigator widget.&apos;</span><br></pre></td></tr></table></figure>
<p>原因：传入的<code>context</code>不支持堆栈管理，比如一个类直接继承自<code>StatelessWidget</code>或<code>StatefulWidget</code>，而它本身或父类没有堆栈管理功能。那么这个类是不支持页面跳转的，所以就会报错。要查看是否支持页面跳转，直接进入源码，比如<code>MaterialApp</code>类，它是支持的，那么它的源码里会有对应的功能介绍：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/// See also:</span><br><span class="line">///</span><br><span class="line">///  * [Scaffold], which provides standard app elements like an [AppBar] and a [Drawer].</span><br><span class="line">///  * [Navigator], which is used to manage the app&apos;s stack of pages.  //这里做了对应的介绍</span><br><span class="line">///  * [MaterialPageRoute], which defines an app page that transitions in a material-specific way.</span><br><span class="line">///  * [WidgetsApp], which defines the basic app elements but does not depend on the material library.</span><br><span class="line">///  * The Flutter Internationalization Tutorial,</span><br><span class="line">///    &lt;https://flutter.io/tutorials/internationalization/&gt;.</span><br><span class="line">class MaterialApp extends StatefulWidget &#123;</span><br><span class="line">  .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>放一个报错的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void main() =&gt; runApp(new MyApp());</span><br><span class="line"></span><br><span class="line">class MyApp extends StatelessWidget &#123;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return new MaterialApp(</span><br><span class="line">        title: &apos;Welcome to Flutter&apos;,</span><br><span class="line">        home: new Scaffold(</span><br><span class="line">            body:Container(</span><br><span class="line">              child: FlatButton(onPressed:()&#123;</span><br><span class="line">                var push = Navigator.push(context,MaterialPageRoute(builder: (BuildContext context) &#123;</span><br><span class="line">                  return new OtherPager(&quot;我是从main传过去的值&quot;);</span><br><span class="line">                &#125;));</span><br><span class="line">                push.then((value)&#123;</span><br><span class="line">                print(&quot;我是从上个页面传递回来的值$value&quot;);</span><br><span class="line">                &#125;);</span><br><span class="line">              &#125;, child:new Icon(Icons.build)),</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的<code>MyApp</code>是直接继承自<code>StatelessWidget</code>的，而在<code>runApp()</code>中直接使用了它，它没有父类而它本身也不支持界面的跳转，所以用它的<code>context</code>传入到<code>Navigator</code>中肯定是会报错的<br><strong>解决方案</strong><br>使用一个有堆栈管理功能的父类将<code>MyApp</code>类包裹，使其具有堆栈跳转功能<br>见如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void main() =&gt; runApp(MaterialApp(home: MyApp()));</span><br><span class="line"></span><br><span class="line">class MyApp extends StatelessWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    // TODO: implement build</span><br><span class="line">    return new Scaffold(</span><br><span class="line">        body: Container(</span><br><span class="line">      child: FlatButton(</span><br><span class="line">          onPressed: () &#123;</span><br><span class="line">            var push = Navigator.push(context,</span><br><span class="line">                MaterialPageRoute(builder: (BuildContext context) &#123;</span><br><span class="line">              return new OtherPager(&quot;我是从main传过去的值&quot;);</span><br><span class="line">            &#125;));</span><br><span class="line">            push.then((value) &#123;</span><br><span class="line">              print(&quot;我是从上个页面传递回来的值$value&quot;);</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;,</span><br><span class="line">          child: new Icon(Icons.build)),</span><br><span class="line">    ));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码中将<code>MaterialApp</code>移出来了，直接将<code>MyApp</code>包裹了，那么<code>MyApp</code>的<code>context</code>就生效了，代码也不会报错啦。</p>
<h4 id="2-在pubspec-yaml申明本地图片路径报错"><a href="#2-在pubspec-yaml申明本地图片路径报错" class="headerlink" title="2.在pubspec.yaml申明本地图片路径报错"></a>2.在pubspec.yaml申明本地图片路径报错</h4><p>错误信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Error on line 29, column 4 of pubspec.yaml: Expected a key while parsing a block mapping.</span><br><span class="line">   assets:</span><br><span class="line">   ^</span><br><span class="line"></span><br><span class="line">pub get failed (65)</span><br></pre></td></tr></table></figure></p>
<p>原因：格式不对，注意空格，与上面对齐,直接将原来的官方注释掉的解开就会出现这个错误，别问我怎么知道的!!</p>
]]></content>
      
        <categories>
            
            <category> flutter </category>
            
        </categories>
        
        
        <tags>
            
            <tag> flutter </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[flutter_redux框架的使用]]></title>
      <url>/flutter-redux%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8.html</url>
      <content type="html"><![CDATA[<p><strong>版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起.</strong></p>
<hr>
<blockquote>
<p>文章首发于我的<a href="https://www.jianshu.com/u/2334b8b9f764" target="_blank" rel="noopener">简书</a>,本处只做整理归档用<br><a id="more"></a></p>
</blockquote>
<h3 id="框架简介以及作用"><a href="#框架简介以及作用" class="headerlink" title="框架简介以及作用"></a>框架简介以及作用</h3><p><code>flutter_redux</code>是基于<a href="https://book.flutterchina.club/chapter7/inherited_widget.html" target="_blank" rel="noopener">InheritedWidget</a>封装的用于Widget树的数据传递与共享的的一套框架，它能高效的完成数据共享，进而达到ui及时更新等目的，使用起来略显复杂，一般不是很多的数据更新不建议使用，直接用InheritedWidget就能解决，当Widget绑定的很多的时候，使用起来就会很爽了。🌼</p>
<h3 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h3><p>打开<code>pubspec.yaml</code>添加如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">  flutter:</span><br><span class="line">    sdk: flutter</span><br><span class="line">  flutter_redux: ^0.5.3</span><br></pre></td></tr></table></figure></p>
<p>关于版本可前往dart库查看，传送门：<a href="https://pub.dartlang.org/packages/flutter_redux#-readme-tab-" target="_blank" rel="noopener">flutter_redux</a></p>
<p>使用步骤：<br>1.新建一个数据共享类，也可以是基本数据类型，里面申明需要共享的数据<br>2.新建一个枚举用于消息发送与区分<br>3.申明一个方法用于处理数据更新逻辑与新的数据返回<br>4.申明<code>Store</code>类，将步骤4的方法放进去<br>5.在需要共享数据的地方申明<code>StoreProvider</code>跟布局，绑定<code>Store</code>类<br>6.使用<code>StoreConnector</code>类或<code>StoreBuilder</code>处理数据逻辑与<code>Widget</code>交互逻辑</p>
<p>注意事项：<br>使用<code>StoreConnector</code>要注意前面的泛型申明，具体使用看以下示例代码(来自官方示例)，此示例实现了一个点击按钮文本加一的效果。</p>
<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">import &apos;package:flutter/material.dart&apos;;</span><br><span class="line">import &apos;package:flutter_redux/flutter_redux.dart&apos;;</span><br><span class="line">import &apos;package:redux/redux.dart&apos;;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  runApp(FlutterReduxApp());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//步骤2，用于在步骤三中做消息区分与消息发送</span><br><span class="line">enum Action &#123; Increment &#125;</span><br><span class="line"></span><br><span class="line">//步骤1的数据共享类是count,一个基本数据类型</span><br><span class="line">//步骤3，处理数据的更新逻辑，此处是做加一操作，注意需要把新的类型返回</span><br><span class="line">int reducer(int count, action) &#123;</span><br><span class="line">  if (action == Action.Increment) &#123;</span><br><span class="line">    return count + 1;</span><br><span class="line">  &#125;</span><br><span class="line">  return count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class FlutterReduxApp extends StatelessWidget &#123;</span><br><span class="line">  //步骤4 申明一个store,必须传入一个方法进去，其余的参数选填，这里选择初始化一下基础参数</span><br><span class="line">  final store = Store(reducer, initialState: 0);</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return StoreProvider(</span><br><span class="line">        store: store, //绑定store</span><br><span class="line">        child: MaterialApp(</span><br><span class="line">          home: Scaffold(</span><br><span class="line">            appBar: AppBar(</span><br><span class="line">              title: Text(&quot;Title&quot;),</span><br><span class="line">            ),</span><br><span class="line">            body: Center(</span><br><span class="line">              child: Column(</span><br><span class="line">                mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">                children: &lt;Widget&gt;[</span><br><span class="line">                  Text(&quot;You have pushed the button this many times:&quot;),</span><br><span class="line">                   //当需要使用到共享数据的时候使用StoreConnector来获取数据</span><br><span class="line">                  StoreConnector&lt;int, String&gt;(builder: (context, value) &#123;</span><br><span class="line">                    return Text(value, style: Theme.of(context).textTheme.display1);</span><br><span class="line">                  &#125;, converter: (Store store) &#123;</span><br><span class="line">                    return store.state.toString();</span><br><span class="line">                  &#125;)</span><br><span class="line">                ],</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">            floatingActionButton: StoreConnector&lt;int, VoidCallback&gt;(</span><br><span class="line">              converter: (Store store) &#123;</span><br><span class="line">                return () =&gt; store.dispatch(Action.Increment); //发送数据</span><br><span class="line">              &#125;,</span><br><span class="line">              builder: (BuildContext context, VoidCallback callback) &#123;</span><br><span class="line">                return FloatingActionButton(</span><br><span class="line">                    onPressed: callback, child: Icon(Icons.add));</span><br><span class="line">              &#125;,</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        ));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源码中主要注意如下地方：<br><strong>1.StoreConnector的使用</strong><br><code>StoreConnector</code>主要是起一个数据转化的作用，可以在组件赋值之前做一些数据转化操作，而<code>StoreBuilder</code>是直接将共享的数据赋值在组件上，具体的选择看需求而定。<br>StoreConnector有两个泛型参数，第一个是我们的原本的共享类型，第二个是我们需要转换的参数类型，它可以是类，方法，基本数据类型等都可以<br>它需要申明两个方法：</p>
<ul>
<li>converter 起数据转化作用，例如源码中申明了一个String类型的转化参数，那么converter的返回值就是一个String类型，返回值会直接传递到builder方法的第二个参数中去。</li>
<li>builder 接收数据，构建Widget交互，第一个context不需要解释，第二个参数就是我们申明的转化参数的返回值，返回值类型视传入的泛型类型而定。</li>
</ul>
<p>经过以上分析，需要注意的就是泛型的申明以及它的数据流向：StoreConnector申明一个转化类型=&gt;converter 转化=&gt;<br>builder方法中接收并使用</p>
<p><strong>store.dispatch(Action.Increment);</strong><br>此方法用来通知数据的改变与更新</p>
<p><strong>StoreBuilder</strong><br>与<code>StoreConnector</code>不同，它只需要申明一个共享数据类型的泛型，在使用中也只有一个<code>builder</code>参数，使用方式与<code>StoreConnector</code>一样，示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">return new StoreProvider(</span><br><span class="line">      store: store,</span><br><span class="line">      child: new StoreBuilder&lt;String&gt;(builder: (context, count) &#123;</span><br><span class="line">        return new Text(count);</span><br><span class="line">    );</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> flutter </category>
            
        </categories>
        
        
        <tags>
            
            <tag> flutter </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Glide设置默认图片后setImageBitmap,setImageResource失效问题]]></title>
      <url>/Glide%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4%E5%9B%BE%E7%89%87%E5%90%8EsetImageBitmapsetImageResource%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98.html</url>
      <content type="html"><![CDATA[<p><strong>版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起.</strong></p>
<hr>
<blockquote>
<p>文章首发于我的<a href="https://www.jianshu.com/u/2334b8b9f764" target="_blank" rel="noopener">简书</a>,本处只做整理归档用<br><a id="more"></a></p>
</blockquote>
<h4 id="复现场景"><a href="#复现场景" class="headerlink" title="复现场景"></a>复现场景</h4><p>在适配器中添加了一个条件，path为空就去加载本地图片，不为空就使用<code>Glide</code>去加载图片，伪代码实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public void onBindViewHolder(ViewHolder holder, int position) &#123;</span><br><span class="line">        if(path==null)&#123;</span><br><span class="line">              imageView.setImageResource(R.drawable.my_image)</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">              Glide.with(this).load(path).apply( RequestOptions().placeholder(R.drawable.place).error(R.drawable.error)).into(imageView)</span><br><span class="line">          &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>咋一看没啥问题,当path为一个无效地址的时候，imageView会显示error的图片，但是当path为null的时候，发现imageView没有显示my_image，还是显示的error图片，打断点发现<code>imageView.setImageResource(R.drawable.my_image)</code>这句代码是执行了的，但为什么会失效呢？</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>先来说一下解决方案，如果对出现原因(从源码层面分析)感兴趣可以继续往下看</p>
<p>1.使用<code>Glide.with(this).clear(imageView)</code>关闭失败重试<br>2.使用<code>Glide</code>加载本地图片,不使用原生Api:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(imageView).load(R.drawable.my_image).into(imageView)</span><br></pre></td></tr></table></figure></p>
<h4 id="出现原因"><a href="#出现原因" class="headerlink" title="出现原因"></a>出现原因</h4><p>Glide内部有加载失败重试机制，当第一次加载失败，重试机制就会启动，这时<code>imageView.setImageResource(R.drawable.my_image)</code>也同步执行了，但是当重试机制执行完毕后，Glide发现图片最终还是加载失败，所以会将error中设置的图片又添加到<code>imageView</code>上去，所以并不是<code>imageView.setImageResource(R.drawable.my_image)</code>这句代码失效了，而是Glide又重新设置了一遍。</p>
<p>我们可以来瞅一眼源码，我们知道图片加载失败是有一个回调的，所以从回调入手：<br>先找到<code>RequestListener</code>回调：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public interface RequestListener&lt;R&gt; &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  boolean onLoadFailed(</span><br><span class="line">      @Nullable GlideException e, Object model, Target&lt;R&gt; target, boolean isFirstResource);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  boolean onResourceReady(</span><br><span class="line">      R resource, Object model, Target&lt;R&gt; target, DataSource dataSource, boolean isFirstResource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>随后找到<code>onLoadFailed</code>实现类<code>SingleRequest</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * A callback method that should never be invoked directly.</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public void onLoadFailed(GlideException e) &#123;</span><br><span class="line">  onLoadFailed(e, Log.WARN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void onLoadFailed(GlideException e, int maxLogLevel) &#123;</span><br><span class="line">  stateVerifier.throwIfRecycled();</span><br><span class="line">  int logLevel = glideContext.getLogLevel();</span><br><span class="line">  if (logLevel &lt;= maxLogLevel) &#123;</span><br><span class="line">    Log.w(GLIDE_TAG, &quot;Load failed for &quot; + model + &quot; with size [&quot; + width + &quot;x&quot; + height + &quot;]&quot;, e);</span><br><span class="line">    if (logLevel &lt;= Log.INFO) &#123;</span><br><span class="line">      e.logRootCauses(GLIDE_TAG);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  loadStatus = null;</span><br><span class="line">  status = Status.FAILED;</span><br><span class="line"></span><br><span class="line">  isCallingCallbacks = true;</span><br><span class="line">  try &#123;</span><br><span class="line">    //TODO: what if this is a thumbnail request?</span><br><span class="line">    if ((requestListener == null</span><br><span class="line">        || !requestListener.onLoadFailed(e, model, target, isFirstReadyResource()))   //可以看到listence的接口调用是在这里，返回值决定了是否往下调用逻辑</span><br><span class="line">        &amp;&amp; (targetListener == null</span><br><span class="line">        || !targetListener.onLoadFailed(e, model, target, isFirstReadyResource()))) &#123;</span><br><span class="line">      setErrorPlaceholder();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    isCallingCallbacks = false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  notifyLoadFailed();  //这里会重试一次</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到这里会先有一个<code>requestListener</code>的接口调用，这里<code>requestListener</code>其实就是我们的listence监听功能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(imageView).load(url).listener(new RequestListener&lt;Drawable&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public boolean onLoadFailed(@Nullable GlideException e, Object model, Target&lt;Drawable&gt; target, boolean isFirstResource) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public boolean onResourceReady(Drawable resource, Object model, Target&lt;Drawable&gt; target, DataSource dataSource, boolean isFirstResource) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure></p>
<p>只有返回false才会去调用<code>setErrorPlaceholder()</code>方法，看一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private void setErrorPlaceholder() &#123;</span><br><span class="line">  if (!canNotifyStatusChanged()) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Drawable error = null;</span><br><span class="line">  if (model == null) &#123;</span><br><span class="line">    error = getFallbackDrawable();</span><br><span class="line">  &#125;</span><br><span class="line">  // Either the model isn&apos;t null, or there was no fallback drawable set.</span><br><span class="line">  if (error == null) &#123;</span><br><span class="line">    error = getErrorDrawable();</span><br><span class="line">  &#125;</span><br><span class="line">  // The model isn&apos;t null, no fallback drawable was set or no error drawable was set.</span><br><span class="line">  if (error == null) &#123;</span><br><span class="line">    error = getPlaceholderDrawable();</span><br><span class="line">  &#125;</span><br><span class="line">  target.onLoadFailed(error);  //target就是我们设置进去的ImageView</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在看一下我们的<code>onLoadFailed</code>实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onLoadFailed(@Nullable Drawable errorDrawable) &#123;</span><br><span class="line">  super.onLoadFailed(errorDrawable);</span><br><span class="line">  setResourceInternal(null);</span><br><span class="line">  setDrawable(errorDrawable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以<code>setErrorPlaceholder</code>方法的作用就是把我们设置的error图片设置给我们放进去的ImageView上<br>我们回到<code>onLoadFailed</code>方法中，发现最后调用了<code>notifyLoadFailed()</code>方法，这个方法是干嘛的呢，看一下源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private void notifyLoadFailed() &#123;</span><br><span class="line">  if (requestCoordinator != null) &#123;</span><br><span class="line">    requestCoordinator.onRequestFailed(this);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>是一个接口，我们看一下它的实现,是在<code>ErrorRequestCoordinator</code>中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if (!request.equals(error)) &#123;</span><br><span class="line">  if (!error.isRunning()) &#123;</span><br><span class="line">    error.begin();</span><br><span class="line">  &#125;</span><br><span class="line">  return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (parent != null) &#123;</span><br><span class="line">  parent.onRequestFailed(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们发现调用了一个熟悉的方法，<code>begin()</code>，研究过源码的都知道，Glide都会在这个接口实现开始异步加载的方法，所以在这里又会去开始异步加载图片</p>
<p>所以，走一圈下来，大致的流程就是这样子：<br>在<code>SingleRequest</code>类中先调用<code>begin</code>开始异步加载图片-&gt;加载失败-&gt;<code>onLoadFailed()</code>-&gt;调用<code>notifyLoadFailed()</code>方法重试(内部会判断是否需要重试)-&gt;需要加载重试-&gt;<code>begin</code></p>
]]></content>
      
        <categories>
            
            <category> Android基础进阶 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[玩转Class之Class的各种骚操作(反射封装必看)]]></title>
      <url>/androidclassstudy.html</url>
      <content type="html"><![CDATA[<p><strong>版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起.</strong></p>
<hr>
<blockquote>
<p>文章首发于我的<a href="https://www.jianshu.com/u/2334b8b9f764" target="_blank" rel="noopener">简书</a>,本处只做整理归档用<br><a id="more"></a></p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Class类表示正在运行的Java应用程序中的类和接口，枚举和基本数据类型，我们可以从中获取到类的一切相关信息，包括字段，方法，名称，父类，接口等</p>
<h2 id="常用方法介绍"><a href="#常用方法介绍" class="headerlink" title="常用方法介绍"></a>常用方法介绍</h2><h4 id="名称获取"><a href="#名称获取" class="headerlink" title="名称获取"></a>名称获取</h4><p>此类方法用于获取类的名称信息<br><strong>getName()方法</strong></p>
<ul>
<li><p>如果是一个实体类，则会返回完整包名路径名称,<br>例如位于<code>com.hj.testclass</code>包下的<code>student</code>类，则会返回<code>com.hj.testclass.student</code></p>
</li>
<li><p>如果是一个数组类型，则返回内部嵌套深度的一个或多个”[“字符，后面拼接上基本数据类型的二进制名称,二进制名称表如下：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Element Type</th>
<th>Encoding</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean</td>
<td>Z</td>
</tr>
<tr>
<td>byte</td>
<td>B</td>
</tr>
<tr>
<td>char</td>
<td>C</td>
</tr>
<tr>
<td>class or interface</td>
<td>Lclassname</td>
</tr>
<tr>
<td>double</td>
<td>D</td>
</tr>
<tr>
<td>float</td>
<td>F</td>
</tr>
<tr>
<td>int</td>
<td>I</td>
</tr>
<tr>
<td>long</td>
<td>J</td>
</tr>
<tr>
<td>short</td>
<td>S</td>
</tr>
</tbody>
</table>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(new long[1][2][3]).getClass().getName()</span><br><span class="line">输出:</span><br><span class="line">[[[J</span><br></pre></td></tr></table></figure>
<ul>
<li>如果是基本数据类型，则会返回数据类型的关键字<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">byte.class.getName()</span><br><span class="line">输出：</span><br><span class="line">byte</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>getSimpleName()方法</strong><br>返回源代码中给出的基础类的简单名称。 如果基础类是匿名的，则返回一个空字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Student student = new Student();</span><br><span class="line">Class mClass = student.getClass();</span><br><span class="line">log(&quot;getSimpleName:&quot;+mClass.getSimpleName());</span><br><span class="line">输出：</span><br><span class="line">Student</span><br></pre></td></tr></table></figure></p>
<p><strong>getPackage()方法</strong><br>返回包名信息</p>
<h4 id="注解相关"><a href="#注解相关" class="headerlink" title="注解相关"></a>注解相关</h4><p>可获取此类是否是注解，是否包含某注解并获取到其对象，获取全部注解</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>getAnnotation(Class<a> annotationClass)</a></strong></td>
<td>获取传入的注解对象，如果不存在，则返回null</td>
</tr>
<tr>
<td><strong>getAnnotations()</strong></td>
<td>返回此类上的所有注解</td>
</tr>
<tr>
<td><strong>getAnnotationsByType(Class<a> annotationClass)</a></strong></td>
<td>返回传入的注解对象数组，与getAnnotation()的区别是检测传入的注解是否是重复元素</td>
</tr>
<tr>
<td><strong>isAnnotation()</strong></td>
<td>判断这个类是否是一个注解类</td>
</tr>
<tr>
<td><strong>isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)</strong></td>
<td>是否包含传入的注解类,效果与getAnnotation()!=null相同</td>
</tr>
</tbody>
</table>
<p>举个栗子：<br>新建一个注解对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by hj on 2019/1/10.</span><br><span class="line"> * 说明：</span><br><span class="line"> */</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface MyAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新建一个Student并加入<code>@MyAnnotation</code>注解：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by hj on 2019/1/10.</span><br><span class="line"> * 说明：</span><br><span class="line"> */</span><br><span class="line">@MyAnnotation</span><br><span class="line">public class Student&#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Student student = new Student();</span><br><span class="line">        Class studentClass = student.getClass();</span><br><span class="line">        boolean isAnnotation = studentClass.isAnnotation();</span><br><span class="line">        log(studentClass.getSimpleName()+&quot;是否是注解类:&quot;+isAnnotation);</span><br><span class="line">        boolean isContainAnnotation = studentClass.isAnnotationPresent(MyAnnotation.class);</span><br><span class="line">        log(studentClass.getSimpleName()+&quot;是否包含MyAnnotation注解类:&quot;+isContainAnnotation);</span><br><span class="line">        Annotation annotation = studentClass.getAnnotation(MyAnnotation.class);</span><br><span class="line">        Annotation[] annotations = studentClass.getAnnotations();</span><br><span class="line">        if (annotation != null) &#123;</span><br><span class="line">            log(&quot;获取指定的MyAnnotation类:&quot;+annotation.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        if (annotations.length &gt; 0)&#123;</span><br><span class="line">            log(&quot;获取注解集合中的第一个元素:&quot;+annotations[0].toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void log(String value) &#123;</span><br><span class="line">        System.out.print(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>打印：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Student是否是注解类:false</span><br><span class="line">Student是否包含MyAnnotation注解类:true</span><br><span class="line">获取指定的MyAnnotation类:@jie.com.imageoptimize.mclass.MyAnnotation()</span><br><span class="line">获取注解集合中的第一个元素:@jie.com.imageoptimize.mclass.MyAnnotation()</span><br></pre></td></tr></table></figure></p>
<h4 id="构造方法相关"><a href="#构造方法相关" class="headerlink" title="构造方法相关"></a>构造方法相关</h4><p>在介绍构造方法之前，先介绍一个类<code>Constructor</code>,它的作用是提供一个类的单个构造方法的信息访问，如果一个类有两个构造方法，那么这个类就会对应有两个<code>Constructor</code>类，它可以使用<code>newInstance</code>方法来进行类的构造方法实现并进行扩展，但如果发生缩小转换则会抛出<code>IllegalArgumentException</code>异常，比如这个类有两个构造参数却只传入一个，就会抛异常。<br>获取<code>Constructor</code>信息的方法有：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>getConstructors()</strong></td>
<td>返回这个类的公共构造函数的 Constructor对象的数组</td>
</tr>
<tr>
<td><strong>getConstructor(Class&lt;?&gt;..parameterTypes)</strong></td>
<td>传入一个指定的参数类型来获取特定的公共构造方法类</td>
</tr>
<tr>
<td><strong>getDeclaredConstructors()</strong></td>
<td>与getConstructors的区别是返回所有的构造方法数组，不限于public protected private</td>
</tr>
<tr>
<td><strong>getDeclaredConstructor(Class&lt;?&gt;..parameterTypes)</strong></td>
<td>与getConstructor的区别是会返回所有类型的构造方法</td>
</tr>
</tbody>
</table>
<p>接下来介绍一下<code>Constructor</code>类的<code>newInstance</code>方法，这个方法说白了就是执行构造函数的，你传入一个当前构造函数的类型的值进去，那么就会执行这个类的构造方法。<br>下面举一个反射调用构造方法的栗子：<br>新建一个Student类，分别添加两个私有构造方法，一个公有构造方法，并添加两个参数，在构造方法处执行打印逻辑，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by hj on 2019/1/10.</span><br><span class="line"> * 说明：</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class Student &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    private Student() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Student(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        log(&quot;公有构造方法执行了，打印传入的名称为:&quot;+name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Student(int age)&#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">        log(&quot;私有构造方法执行了，打印传入的年龄为:&quot;+age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Student student = new Student();</span><br><span class="line">        Class mClass = student.getClass();</span><br><span class="line">        Constructor[] constructors = mClass.getConstructors();</span><br><span class="line">        log(&quot;获取&quot; + mClass.getSimpleName() + &quot;的公共构造方法数量为:&quot; + constructors.length);</span><br><span class="line">        try &#123;</span><br><span class="line">            Constructor constructor = mClass.getConstructor(String.class);</span><br><span class="line"></span><br><span class="line">            constructor.newInstance(&quot;张三&quot;);</span><br><span class="line"></span><br><span class="line">        &#125; catch (NoSuchMethodException | IllegalAccessException | InstantiationException | InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Constructor[] declaredConstructors = mClass.getDeclaredConstructors();</span><br><span class="line">        log(&quot;获取&quot; + mClass.getSimpleName() + &quot;的所有构造方法数量为:&quot; + declaredConstructors.length);</span><br><span class="line">        try &#123;</span><br><span class="line">            Constructor constructor = mClass.getDeclaredConstructor(int.class);</span><br><span class="line"></span><br><span class="line">            constructor.newInstance(18);</span><br><span class="line"></span><br><span class="line">        &#125; catch (NoSuchMethodException | IllegalAccessException | InstantiationException | InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void log(String value) &#123;</span><br><span class="line">        System.out.print(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">获取Student的公共构造方法数量为:1</span><br><span class="line">公有构造方法执行了，打印传入的名称为:张三</span><br><span class="line">获取Student的所有构造方法数量为:3</span><br><span class="line">私有构造方法执行了，打印传入的年龄为:18</span><br></pre></td></tr></table></figure></p>
<p>怎么样，反射调用类的构造方法技能get到了吗</p>
<h5 id="字段相关"><a href="#字段相关" class="headerlink" title="字段相关"></a>字段相关</h5><p>此类型方法是用的最多的一种，希望小伙伴们可以熟练掌握<br>在介绍字段方法之前，先介绍一个类<code>Field</code>,它用于保存，修改字段的信息，甚至可以修改字段的访问权限,常用的方法如下:</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>getName()</strong></td>
<td>获取字段名称</td>
</tr>
<tr>
<td><strong>get()</strong></td>
<td>传入需要获取的值的类的对象，获取该字段的值,返回object类型，使用的时候需要做类型判断</td>
</tr>
<tr>
<td><strong>getBoolean(),getInt()…</strong></td>
<td>获取指定类型的字段值</td>
</tr>
<tr>
<td><strong>set()，setBoolean()…</strong></td>
<td>将指定的类的指定值设置为新值</td>
</tr>
<tr>
<td><strong>isAccessible()</strong></td>
<td>判断此字段是否有访问权限</td>
</tr>
<tr>
<td><strong>setAccessible()</strong></td>
<td>设置字段的权限，为true代表可以访问</td>
</tr>
</tbody>
</table>
<p>接下来再来看看如何使用Class来获取字段信息:</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>getFields()</strong></td>
<td>获取所有的公共字段</td>
</tr>
<tr>
<td><strong>getField()</strong></td>
<td>传入字段的名称，返回公共字段对象</td>
</tr>
<tr>
<td><strong>getDeclaredFields()</strong></td>
<td>获取所有字段，返回一个Field数组</td>
</tr>
<tr>
<td><strong>getDeclaredField</strong></td>
<td>传入字段的名称，返回字段对象,无访问限制</td>
</tr>
</tbody>
</table>
<p>下面举个获取字段名称和内容的例子，并分享一个常用的套路写法，一般的都可以按照这个套路来写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by hj on 2019/1/10.</span><br><span class="line"> * 说明：</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class Student &#123;</span><br><span class="line"></span><br><span class="line">    public String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public Student(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Student student = new Student(&quot;张三&quot;, 18);</span><br><span class="line">        setAllComponentsName(student);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    private static void setAllComponentsName(Object f) &#123;</span><br><span class="line">        Field[] fields = f.getClass().getDeclaredFields();</span><br><span class="line">        for (Field field : fields) &#123;</span><br><span class="line">            // 对于每个属性，获取属性名</span><br><span class="line">            String varName = field.getName();</span><br><span class="line">            try &#123;</span><br><span class="line">                // 获取原来的访问控制权限</span><br><span class="line">                boolean accessFlag = field.isAccessible();</span><br><span class="line">                // 修改访问控制权限</span><br><span class="line">                field.setAccessible(true);</span><br><span class="line">                // 获取在对象f中属性fields[i]对应的对象中的变量</span><br><span class="line">                Object o = field.get(f);</span><br><span class="line">                if (!&quot;&quot;.equals(varName)) &#123;</span><br><span class="line">                    //这里可以处理相关逻辑</span><br><span class="line">                    if (o != null) &#123;</span><br><span class="line">                        if (o instanceof String) &#123;</span><br><span class="line">                            String value = (String) o;</span><br><span class="line">                            log(&quot;String类型字段:&quot; + value);</span><br><span class="line">                        &#125; else if (o instanceof Integer) &#123;</span><br><span class="line">                            int value = (int) o;</span><br><span class="line">                            log(&quot;int类型字段:&quot; + value);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                // 恢复访问控制权限</span><br><span class="line">                field.setAccessible(accessFlag);</span><br><span class="line">            &#125; catch (IllegalArgumentException | IllegalAccessException ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void log(String value) &#123;</span><br><span class="line">        System.out.print(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String类型字段:张三</span><br><span class="line">int类型字段:18</span><br></pre></td></tr></table></figure></p>
<p>一般都是先将权限修改为true,再去读取字段内容，随后进行逻辑处理，最后记得将权限改回来.</p>
<h5 id="方法相关"><a href="#方法相关" class="headerlink" title="方法相关"></a>方法相关</h5><p>此类型方法也是用的比较多的一种，是反射调用方法的关键<br>class中关于方法的封装都是给<code>Method</code>类来操作的，它可以获取，修改，执行类的方法，核心方法就是<code>invoke()</code>，作用是执行方法，第一个参数是需要执行的方法的类对象，随后是需要执行的方法参数值。<br>获取<code>Method</code>对象有四个方法:</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>getMethods()</strong></td>
<td>获取类的所有公共方法</td>
</tr>
<tr>
<td><strong>getMethod()</strong></td>
<td>获取指定公共方法，传入一个方法的名称与参数的类型</td>
</tr>
<tr>
<td><strong>getDeclaredMethods()</strong></td>
<td>获取类的所有方法</td>
</tr>
<tr>
<td><strong>getDeclaredMethod()</strong></td>
<td>获取类的指定方法，传入参数同getMethod()</td>
</tr>
</tbody>
</table>
<p>举个例子，将本来为张三的名称修改为李四：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by hj on 2019/1/10.</span><br><span class="line"> * 说明：</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class Student &#123;</span><br><span class="line"></span><br><span class="line">    public String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public Student(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void setName(String name)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        log(&quot;设置的名称为：&quot;+name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Student student = new Student(&quot;张三&quot;, 18);</span><br><span class="line">        Class mClass = student.getClass();</span><br><span class="line">        try &#123;</span><br><span class="line">            Method method = mClass.getDeclaredMethod(&quot;setName&quot;,String.class);</span><br><span class="line">            method.invoke(student,&quot;李四&quot;);</span><br><span class="line">        &#125; catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private static void log(String value) &#123;</span><br><span class="line">        System.out.print(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">设置的名称为：李四</span><br></pre></td></tr></table></figure></p>
<p>在项目中使用，可以参考上面的<code>Field</code>类，其实都是差不多的，一通百通。</p>
<h5 id="抽象-继承-接口-泛型相关"><a href="#抽象-继承-接口-泛型相关" class="headerlink" title="抽象,继承,接口,泛型相关"></a>抽象,继承,接口,泛型相关</h5><p>此类方法虽然不常用到，但在某些情况下能发挥意想不到的作用，在许多框架的源码中也能看见它们的身影，如<code>Gson</code>的<code>$Gson$Types</code>类,<code>Retrofit</code>的<code>Util</code>类等，来跟我学习一下把。</p>
<p><strong>泛型</strong><br>首先说说获取类的泛型获取，先介绍一个接口<code>Type</code>,它是java中所有类型的通用接口，类型包括原始类型(class)，参数化类型(ParameterizedType)，数组类型(GenericArrayType)，类型变量(TypeVariable)和基本数据类型。内部实现了一个方法<code>getTypeName()</code>,用于返回类型参数信息，基于它向外扩展的接口有：</p>
<ul>
<li>ParameterizedType<br>表示一个参数化类型，说简单点就是带有参数类型的类型，如Collection ,如果带有了类型，如Collection<string>，那么就是说String将Collection参数化</string></li>
<li>GenericArrayType<br>表示一个参数化类型或类型变量的数组类型，简单说就是泛型A<t>[]或泛型数组T[]</t></li>
<li>TypeVariable<br>所有类型变量的父接口,也就是我们定义抽象类中的那种K,E等泛型变量，可以泛指任何类</li>
<li>WildcardType<br>表示一个通配符表达，例如?,? extends Integer<br><code>Type</code>可以通过<code>class</code>的<code>getGenericInterfaces</code>或<code>getGenericSuperclass()</code>方法来获取<br>这么说或许还有点抽象，<code>ParameterizedType</code>与<code>TypeVariable</code>的概念或许还拎不太清。下面通过示例来加深理解<br>先来说说ParameterizedType<br>举个例子，先声明一个带泛型的超类<code>Person</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by hj on 2019/1/10.</span><br><span class="line"> * 说明：</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class Person&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public T feature;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>随后定义一个实体类<code>Feature</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by hj on 2019/1/10.</span><br><span class="line"> * 说明：</span><br><span class="line"> */</span><br><span class="line">public class Feature &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后申明一个<code>Student</code>并继承<code>Person</code>,将<code>Feature</code>作为<code>T</code>传入:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by hj on 2019/1/10.</span><br><span class="line"> * 说明：</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class Student extends Person&lt;Feature&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Student student = new Student();</span><br><span class="line">        Class mClass = student.getClass();</span><br><span class="line">        Type type = mClass.getGenericSuperclass();</span><br><span class="line">        //这里获取的type为Person&lt;Feature&gt;，所以属于ParameterizedType</span><br><span class="line">        if (type instanceof ParameterizedType) &#123;</span><br><span class="line">            //父类的泛型可能有多个，这里只写了一个，所以取第一个就行了，这里是取Person&lt;Feature&gt;中的Feature</span><br><span class="line">            Class tClass = (Class) ((ParameterizedType) type).getActualTypeArguments()[0];</span><br><span class="line">            log(tClass.getSimpleName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private static void log(String value) &#123;</span><br><span class="line">        System.out.print(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为<code>Class</code>类也实现了<code>Type</code>接口，所以是可以强制转化的<br>打印结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Feature</span><br></pre></td></tr></table></figure></p>
<p>可以看到在此示例中，只要是<code>Person&lt;&gt;</code>中传入的参数是一个参数类型，不管是<code>实体类</code>，<code>String</code>都行，只要是参数而没有泛指意义，那么它就属于<code>ParameterizedType</code>类型<br>接下来将代码修改一下，将<code>Feature</code>改为<code>T</code>,修改获取逻辑：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by hj on 2019/1/10.</span><br><span class="line"> * 说明：</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class Student&lt;T&gt; extends Person&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Student student = new Student();</span><br><span class="line">        Class mClass = student.getClass();</span><br><span class="line">        Type type = mClass.getGenericSuperclass();</span><br><span class="line">       //此时这里的type为Person&lt;T&gt;，而不是T，所以依旧属于ParameterizedType</span><br><span class="line">        if (type instanceof ParameterizedType) &#123;</span><br><span class="line">           //这里是从Person&lt;T&gt;中获取T</span><br><span class="line">            Type childType = ((ParameterizedType)type).getActualTypeArguments()[0];</span><br><span class="line">            if (childType instanceof TypeVariable)&#123;</span><br><span class="line">                log(((TypeVariable) childType).getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private static void log(String value) &#123;</span><br><span class="line">        System.out.print(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出名称为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T</span><br></pre></td></tr></table></figure></p>
<p>不知道小伙伴们有没有理解了，当获取的类型是泛指的，如T等，那么就是<code>TypeVariable</code>类型，当类型是参数类型的，例如由子类传入的，具体化的，那么就是<code>ParameterizedType</code>类型。<br>接下来的<code>GenericArrayType</code>和<code>WildcardType</code>就比较好理解了，将以上示例中的<code>Person&lt;T&gt;</code>改为<code>Person&lt;T[]&gt;</code>，将结果输出，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by hj on 2019/1/10.</span><br><span class="line"> * 说明：</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class Student&lt;T&gt; extends Person&lt;T[]&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Student student = new Student();</span><br><span class="line">        Class mClass = student.getClass();</span><br><span class="line">        Type type = mClass.getGenericSuperclass();</span><br><span class="line">        if (type instanceof ParameterizedType) &#123;</span><br><span class="line">            //这里获取到的类型为：T[],是一个数组类型，所以是GenericArrayType</span><br><span class="line">            Type childType = ((ParameterizedType)type).getActualTypeArguments()[0];</span><br><span class="line">            if (childType instanceof GenericArrayType)&#123;</span><br><span class="line">                log(childType.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private static void log(String value) &#123;</span><br><span class="line">        System.out.print(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出名称为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T[]</span><br></pre></td></tr></table></figure></p>
<p><code>WildcardType</code>就不演示了，将<code>T</code>改为带<code>？</code>的类型就可以了，如果封装类型实在太复杂，教大家一个技巧，打个断点，啥类型都帮你显示出来了。<br><img src="https://upload-images.jianshu.io/upload_images/3468978-115865cd6cbf0d07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="断点识别参数类型.png"><br>一看就知道是ParameterizedType类型了，哈哈哈，溜不溜。</p>
<p>这里给小伙伴一个作业：<br><code>List&lt;? extends T&gt;[]</code>中的<code>List&lt;? extends T&gt;</code>,<code>? extends T</code>，<code>T</code> ,<code>List&lt;? extends T&gt;[]</code>分别代表什么类型呢？</p>
<p><strong>继承</strong><br>获取父级类使用<code>Class.getSuperclass()</code>方法即可获取父类的<code>class</code></p>
<p><strong>接口</strong><br>获取接口也比较简单，一个接口实际上也是一个Class类，通过<code>getInterfaces()</code>获取到一个<code>Class</code>数组，而接口里声明的方法可以通过获取<code>Method</code>的方式来获取,<br>举个栗子，先创建一个<code>MyInterface</code>接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by hj on 2019/1/11.</span><br><span class="line"> * 说明：</span><br><span class="line"> */</span><br><span class="line">public interface MyInterface &#123;</span><br><span class="line">    void getName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在<code>Student</code>类里实现并获取：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by hj on 2019/1/10.</span><br><span class="line"> * 说明：</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class Student implements MyInterface&#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Student student = new Student();</span><br><span class="line">        Class mClass = student.getClass();</span><br><span class="line">        Class interfaces = mClass.getInterfaces()[0];</span><br><span class="line">        try &#123;</span><br><span class="line">            Method methods = interfaces.getMethod(&quot;getName&quot;,null);</span><br><span class="line">            log(methods.getName());</span><br><span class="line">        &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void log(String value) &#123;</span><br><span class="line">        System.out.print(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void getName() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>打印出方法名为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getName</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>只要拿到Class类，我们就可以获取到它的父类，接口，方法，字段，以及泛型，从而做一些解耦封装，提高类的解耦性。或者在不修改源码的情况下执行或修改源码中的方法，字段，从而达到理想中的效果。小伙伴们快去练习一下把。</p>
]]></content>
      
        <categories>
            
            <category> Android基础进阶 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android性能优化-图片篇]]></title>
      <url>/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E5%9B%BE%E7%89%87%E7%AF%87.html</url>
      <content type="html"><![CDATA[<p><strong>版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起.</strong></p>
<hr>
<blockquote>
<p>文章首发于我的<a href="https://www.jianshu.com/u/2334b8b9f764" target="_blank" rel="noopener">简书</a>,本处只做整理归档用<br><a id="more"></a></p>
</blockquote>
<h3 id="1-drawable目录详解-mdpi-hdpi-xhdpi-xxhdpi-xxxhdpi"><a href="#1-drawable目录详解-mdpi-hdpi-xhdpi-xxhdpi-xxxhdpi" class="headerlink" title="(1)drawable目录详解(mdpi,hdpi,xhdpi,xxhdpi,xxxhdpi)"></a>(1)drawable目录详解(mdpi,hdpi,xhdpi,xxhdpi,xxxhdpi)</h3><h4 id="1-1、图片在各个目录中要如何存放？（必须理解）"><a href="#1-1、图片在各个目录中要如何存放？（必须理解）" class="headerlink" title="1.1、图片在各个目录中要如何存放？（必须理解）"></a>1.1、图片在各个目录中要如何存放？（必须理解）</h4><p>android的drawable目录有：</p>
<ul>
<li>drawable-ldpi(低密度) </li>
<li>drawable-mdpi(中等密度)</li>
<li>drawable-hdpi(高密度)</li>
<li>drawable-xhdpi(超高密度)</li>
<li>drawable-xxhdpi(超超高密度)</li>
<li>drawable-xxxhdpi(超超超高密度)</li>
<li>drawable-nohdpi(无缩放)</li>
<li>默认的drawable</li>
</ul>
<p>而安卓加载图片的原理是根据手机的密度(dpi)来选择不同的文件夹下的图片,如果没有，就会从别的密度文件夹来获取图片并按照一定比例来缩放展示图片。获取设备密度的方法为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float xdpi = getResources().getDisplayMetrics().xdpi;</span><br><span class="line">float ydpi = getResources().getDisplayMetrics().ydpi;</span><br></pre></td></tr></table></figure></p>
<p>知道了dpi,就知道会去哪个文件夹获取图片了:<br>|  对应文件夹 | 密度范围（dpi）| 缩放比例 |<br>| ——| ——| ——|<br>|  ldpi |  0~120     | 0.75 |<br>| mdpi |120~160 | 1(基准)|<br>| hdpi |160~240 | 1.5 |<br>| xhdpi |240~320 | 2.0 |<br>| xxhdpi |320~480 | 3.0 |<br>| xxxhdpi |480~640 | 4.0|<br>而当前的主流机型密度基本都是在320~480之间，一般放两套图就够了，一套放到xhdpi,一套放到xxhdpi,那么如果是一个hdpi的手机来运行会发生什么呢？安卓是有一套图片匹配规则的:</p>
<p>一个hdpi密度的手机，肯定是先去匹配<code>hdpi</code>目录下的图片，如果没有，那么就会向上级去查找，分别是<code>xhdpi</code>-&gt;<code>xxhdpi</code>-&gt;<code>xxxhdpi</code>-&gt;<code>nodpi</code>，如果都没有，就会往下级目录去查，分别是<code>mdpi</code>-&gt;<code>ldpi</code>,如果还没有，就会去<code>drawable</code>目录去查找，如果还没有！就会开启自毁模式，嘣！！(resouse not found)</p>
<h4 id="1-2、相同图片在不同目录所占用资源分析-了解即可"><a href="#1-2、相同图片在不同目录所占用资源分析-了解即可" class="headerlink" title="1.2、相同图片在不同目录所占用资源分析(了解即可)"></a>1.2、相同图片在不同目录所占用资源分析(了解即可)</h4><p>不知道有没有朋友做过这样一个实验，把一个xhdpi密度的图片放到xxhdpi密度的文件夹中去加载会发生什么,它所占的内存会有区别吗？<br>例如一个在xhdpi下为200 <em> 200的图片，xxhdpi密度下为300 </em> 300,但此时图片只有200 <em> 200，所以它会放大到300 </em> 300，这时候图片就会出现模糊的情况了，所以如果你在项目中发现图片模糊的情况可以检查下图片的尺寸是否正确。</p>
<p>接下来我们来做一个实验,使用一个名叫<code>icon_database_xls</code>  <code>64 * 64 PNG</code>的图片，将它放到<code>xhdpi</code>目录中，执行下面的代码获取内存占用情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Bitmap bitmap = BitmapFactory.decodeResource(getResources(),R.mipmap.icon_database_xls);</span><br><span class="line">Log.i(&quot;HJ&quot;,bitmap.getByteCount()+&quot;&quot;);</span><br></pre></td></tr></table></figure></p>
<p>结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2019-01-08 10:56:01.872 18507-18507/jie.com.imageoptimize I/HJ: 30976</span><br></pre></td></tr></table></figure></p>
<p>接下来将图片放到<code>xxhdpi</code>目录下，再次执行代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2019-01-08 10:56:32.123 18677-18677/jie.com.imageoptimize I/HJ: 13924</span><br></pre></td></tr></table></figure></p>
<p>可以看到结果差距巨大,我们知道，一个图片的内存占用公式为：图片内存宽度 <em> 图片内存高度</em> 每像素占用的内存位数，那我们的内存宽高是如何计算的呢？我们可以追踪framework的源码，路径为<code>/frameworks/base/core/jni/android/graphics/BitmapFactory.cpp</code>,找到<code>doDecode</code>方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">static jobject doDecode(JNIEnv* env, std::unique_ptr&lt;SkStreamRewindable&gt; stream,</span><br><span class="line">                        jobject padding, jobject options) &#123;</span><br><span class="line">    int sampleSize = 1;</span><br><span class="line">    bool onlyDecodeSize = false;</span><br><span class="line">    ... ...</span><br><span class="line">    float scale = 1.0f;</span><br><span class="line">    ... ...</span><br><span class="line">    if (options != NULL) &#123;</span><br><span class="line">        sampleSize = env-&gt;GetIntField(options, gOptions_sampleSizeFieldID);</span><br><span class="line">        if (sampleSize &lt;= 0) &#123;</span><br><span class="line">            sampleSize = 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (env-&gt;GetBooleanField(options, gOptions_justBoundsFieldID)) &#123;</span><br><span class="line">            onlyDecodeSize = true;</span><br><span class="line">        &#125;</span><br><span class="line">        ... ...</span><br><span class="line">        if (env-&gt;GetBooleanField(options, gOptions_scaledFieldID)) &#123;</span><br><span class="line">            const int density = env-&gt;GetIntField(options, gOptions_densityFieldID);</span><br><span class="line">            const int targetDensity = env-&gt;GetIntField(options, gOptions_targetDensityFieldID);</span><br><span class="line">            const int screenDensity = env-&gt;GetIntField(options, gOptions_screenDensityFieldID);</span><br><span class="line">            if (density != 0 &amp;&amp; targetDensity != 0 &amp;&amp; density != screenDensity) &#123;</span><br><span class="line">                scale = (float) targetDensity / density;  //缩放比在这里计算的</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    if (scale != 1.0f) &#123;</span><br><span class="line">        willScale = true;</span><br><span class="line">        scaledWidth = static_cast&lt;int&gt;(scaledWidth * scale + 0.5f); //内存宽度计算</span><br><span class="line">        scaledHeight = static_cast&lt;int&gt;(scaledHeight * scale + 0.5f); //内存高度计算</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></p>
<p>以上源码总结为：<br>内存宽高 = 图片本身的宽高 * （设备密度/使用的密度）+ 0.5<br>所以，内存的占用与图片所在的密度目录是有密切关系的</p>
<h4 id="1-3、-drawable-xxhdpi与mipmap-xxhdpi的区别-了解即可"><a href="#1-3、-drawable-xxhdpi与mipmap-xxhdpi的区别-了解即可" class="headerlink" title="1.3、 drawable-xxhdpi与mipmap-xxhdpi的区别(了解即可)"></a>1.3、 drawable-xxhdpi与mipmap-xxhdpi的区别(了解即可)</h4><p>从新版Android studio开始，系统会默认给我们创建<code>mipmap</code>文件夹而不是<code>drawable</code>,先前我一直以为这个目录只是放icon的(流下了菜逼的心酸泪水),后来发现这个目录与drawable都可以放图片，而且貌似也没有任何差别????，为了弄清楚，上网查了一下，大意是会对图片缩放做性能优化，不过我在平常的使用中并没有发现有太大的区别，可能是高版本drawable也做了优化把，所以这个简单了解一下即可。</p>
<h3 id="2-Bitmap优化详解"><a href="#2-Bitmap优化详解" class="headerlink" title="(2)Bitmap优化详解"></a>(2)Bitmap优化详解</h3><h4 id="2-1、基础知识"><a href="#2-1、基础知识" class="headerlink" title="2.1、基础知识"></a>2.1、基础知识</h4><p>安卓的图片加载都会对应到bitmap对象,当bitmap占用的内存过高，超过了android为app分配的最大内存，那么它就会不开心，它就会OOM，所以我们的图片优化，本质就是内存优化。<br>我们常用的图片格式一般有三种:</p>
<ul>
<li>JPEG 一种有损压缩格式，不支持透明通道,所以有透明背景需求的图片不要用jpeg格式，它会变成黑色，会变黑！！！，会变黑！！！，会变黑！！！</li>
<li>PNG   无损压缩格式,支持透明通道</li>
<li>WEBP  同时支持无损和有损压缩格式，然而兼容性较差，需要适配库<br> 可参考:<a href="https://github.com/EverythingMe/webp-android" target="_blank" rel="noopener">webp-android</a></li>
</ul>
<p>在代码中可以通过<code>Bitmap.CompressFormat</code>来指定生成的图片格式<br>bitmap还可以配置像素占用字节数（一个字节对应8位），这与内存占用息息相关，对应<code>Bitmap.Config</code>类：</p>
<ul>
<li>ALPHA_8   8位ALPHA通道，即A=8，一个像素占用一个字节，它是没有颜色的，只有透明度</li>
<li>ARGB_4444  16位 A=4,R=4,G=4,B=4,一个像素占用字节 = 4+4+4+4 = 16位 = 2个字节</li>
<li>ARGB_8888 32位 A=8,R=8,G=8,B=8,一个像素占用字节 = 8+8+8+8 = 32位 = 4个字节</li>
<li>RGB_565 16位 R=5,G=6,B=5,因为没有A，所以它没有透明度，计算同上也是占用2个字节<br>像平常如果没有透明度要求使用<code>RGB_565</code>即可<h4 id="2-2、优化的本质"><a href="#2-2、优化的本质" class="headerlink" title="2.2、优化的本质"></a>2.2、优化的本质</h4>前面已经提到我们的图片优化实际是内存的优化，而我们的内存计算公式是：<br>内存占用宽高相乘 * 每像素占用的内存位数，所以要么就减少图片内存占用宽高，要么就减少像素占用内存数。减少像素内存占用数可以通过配置Bitmap.Config解决，而减少图片内存占用宽高，可以有以下几个方式：<br>1.缩小图片实际宽高，缩小到正好正常展示<br>2.匹配合适的像素密度<br>此外还能主动回收占用的内存从而缓解内存紧张的问题。<h4 id="2-3、优化方式"><a href="#2-3、优化方式" class="headerlink" title="2.3、优化方式"></a>2.3、优化方式</h4>分析了一下优化的本质问题，我们可以针对性的使用以下几种方式来进行优化：<br><strong>1.配置BitmapConfig（前面已经讲到）</strong><br><strong>2.拿到一个图片，通过<code>inJustDecodeBounds</code>不消耗内存拿到图片的宽高，然后使用<code>inSampleSize</code>来设置图片的缩放比。</strong><br>简单示例代码:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">BitmapFactory.Options options = new BitmapFactory.Options();</span><br><span class="line">options.inJustDecodeBounds = true;</span><br><span class="line">BitmapFactory.decodeResource(getResources(),R.mipmap.icon_database_xls,options);</span><br><span class="line">Log.i(&quot;HJ&quot;,&quot;初始图片宽:&quot;+options.outWidth);</span><br><span class="line">Log.i(&quot;HJ&quot;,&quot;初始图片高:&quot;+options.outHeight);</span><br><span class="line">options.inSampleSize = 2;</span><br><span class="line">options.inJustDecodeBounds = false;</span><br><span class="line">BitmapFactory.decodeResource(getResources(),R.mipmap.icon_database_xls,options);</span><br><span class="line">Log.i(&quot;HJ&quot;,&quot;缩放后图片宽:&quot;+options.outWidth);</span><br><span class="line">Log.i(&quot;HJ&quot;,&quot;缩放后图片高:&quot;+options.outHeight);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>运行后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2019-01-08 17:07:50.935 25900-25900/jie.com.imageoptimize I/HJ: 初始图片宽:64</span><br><span class="line">2019-01-08 17:07:50.935 25900-25900/jie.com.imageoptimize I/HJ: 初始图片高:64</span><br><span class="line">2019-01-08 17:07:50.936 25900-25900/jie.com.imageoptimize I/HJ: 缩放后图片宽:32</span><br><span class="line">2019-01-08 17:07:50.937 25900-25900/jie.com.imageoptimize I/HJ: 缩放后图片高:32</span><br></pre></td></tr></table></figure></p>
<p>可以看到inSampleSize设为2，图片的宽和高都变成了原来的一半，所以可得缩放公式为：<br>原始图片宽度/inSampleSize  = 缩放后的图片宽度。高度同理，所以图片的整体大小变为了原来的1/4。</p>
<p><strong>3.压缩图片，除了外部压缩，内部也可以使用<code>compress()</code>来压缩图片。或者自定义压缩算法，使用比较广泛的有<a href="https://github.com/Curzibn/Luban" target="_blank" rel="noopener">Luban</a>算法</strong></p>
<p>compress()示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.mipmap.icon_database_xls);</span><br><span class="line">ByteArrayOutputStream stream = new ByteArrayOutputStream();</span><br><span class="line">boolean compress = bitmap.compress(Bitmap.CompressFormat.PNG, 90, stream);</span><br></pre></td></tr></table></figure></p>
<p>第一个参数是需要生成的图片格式，第二个是压缩百分比，第三个是生成的输出流容器。请注意，此方法<strong>只会压缩图片大小，但是并不会减少内存占用</strong>。</p>
<p><strong>4.主动释放内存，绑定控件生命周期，在销毁的时候调用<code>recycler()</code>方法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(bitmap != null &amp;&amp; !bitmap.isRecycled())&#123;  </span><br><span class="line">    bitmap.recycle(); </span><br><span class="line">    bitmap = null; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Android基础进阶 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[2018年终总结]]></title>
      <url>/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93.html</url>
      <content type="html"><![CDATA[<p><strong>版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起.</strong></p>
<hr>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>人啊，最怕一生碌碌无为，与其平淡中度过，何不为自己定一个小目标，体验先赚他一个亿的刺激梦想!!!!</p>
<p>今年我总结起来就是:蓄势待发与蓄谋已久,嗯，分别对应2018与2019，谋，是我藏在心中的一个目标<del>~</del></p>
<a id="more"></a>
<h4 id="面试的故事"><a href="#面试的故事" class="headerlink" title="面试的故事"></a>面试的故事</h4><p>2018年初，考了驾照，回到了家乡长沙开始了长沙开发之旅，记得年初的时候投的第一家公司就是现在的这家公司，当时是技术总监面试的我，对我印象挺好的，当场就决定录用了我，问我什么时候可以过来上班，我因为是第一次在长沙面试，对长沙的大概薪资状况以及互联网发展情况并不是特别的了解，所以我打算再去其他公司看看，对整体都了解一下，我说3天后来上班，这三天里，我去了蓝思科技，世界500强企业，面试官看到我只有2年经验，连一个技术问题都没问就让我回去等通知，说实话我是比较伤心的，因为我觉得工作年限不等于技术，工作年限长不一定技术就会好，起码可以试一试啊，可能这是大公司的一个<code>硬性标准</code>吧，哎，都没领略过大海的波涛汹涌,就被拍死在了沙滩上。随后我去了一家总部在北京的长沙分公司，是做智能化管理的，面试官问了一些非常基础的问题，答完后直接和总监谈薪资，总监觉得我要价高，我说我最低要求就这个价，不能少，随后就GG了，我觉得这或许就是他在长沙开分公司的原因吧，招人相对于北京能节约更多的成本，但你这价格也压得太低了哎…面来面去最后还是第一家公司最满意，于是，我来到了现在的这家公司—–长沙居美网络科技有限公司，主要是做家居建材招商加盟的，现金流非常的充足，公司也挺大的，有200多号人，4个办公场地。</p>
<h4 id="新公司的奋斗故事"><a href="#新公司的奋斗故事" class="headerlink" title="新公司的奋斗故事"></a>新公司的奋斗故事</h4><p>入职的第一天，技术总监就把我叫到一个会议室谈话，总监说，你是这家公司来的第一个Android开发，公司计划在7月份推出一款app,要在广州的建博会上亮相，天啊，那可是十几万人都会来参加的展会，必须要万无一失，马虎不得，可是，总监透漏，目前公司产品，测试，ui人员还没有招到位……emmmmmmm,我找不到语言来描述我当时的心情，但是这家公司给我的感觉还是挺靠谱的，不像是那种坑人的公司，所以我承诺了要替公司开发好这一款app.</p>
<p>到了3月份，人员果然陆陆续续都找齐了，于是开始干活。作为一款从0开发的app,并且公司在这方面没有任何的知识储备，可以想象难度还是有的，开发一款app,首先第一件事就是把架子搭起来，原来公司的app架构是不能用的，项目太旧，框架太老了，所以只能靠自己搭建。</p>
<p>首先确定的是MVP模式，这没的跑，然后把Activity等的一些基类写好，随后开始封装网络请求，本来考虑使用<code>Retrofit</code>，但是这款框架需要再次封装的东西还是蛮多的，基于快速开发的原因我就使用了<code>OkGo</code>框架，它把所有的一切都帮你封装好了，我在上层写了一些简单的封装就能直接使用了。随后就是各种Utils封装,UI封装，把Rxjava,Glide等常用的框架弄进来，随后的日子就开始了疯狂的码代码,那段时间基本没有在9点钟之前下过班，一直持续到项目成功上线。虽然辛苦，但看到自己的app代码逐渐的成熟完善，成就感也特别的强烈，而且收获也是满满的，懂得了如何搭建好的架构，封装功底也得到了提高，或许，这就是传说的魔鬼历练吧</p>
<h4 id="Kotlin的故事"><a href="#Kotlin的故事" class="headerlink" title="Kotlin的故事"></a>Kotlin的故事</h4><p>随着项目的成功上线，时间渐渐变得充裕，公司前后也陆续招了一些Android开发进来，总监提拔我当了Android组的组长，每天向她汇报一些开发工作，由于项目处于推广阶段，后期需求增长乏力，留下的空余时间较多，总监说需要增加组员的工作饱和度，于是我就开始了Kotlin的代码重构，对于Kotlin,先前只是了解一点，但是当深入研究了这门语言之后，我意识到它的确能为开发带来很大的便捷（能偷懒）。使用了它之后，我们每一个类平均少了百来行代码，并且其中的扩展函数功能实在是不能太赞。由于不改逻辑，只是单纯的翻译，修改速度特别快，当我们把所有代码都换成Kotlin之后，我们就针对Kotlin的特性从底层到应用层来了个大的封装调整，让代码看起来就是Kotlin编程，而不是Java翻译语言,这样，我的第一个纯Kotlin语言开发的app就这样诞生了.</p>
<h4 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h4><p>之后在公司的日子就比较平淡了，开发完需求，如果有剩余的时间都是学习新技术来提升自己，最大的收获是学习了小程序开发。而回首今年，在自定义View,多线程开发，以及设计模式的使用，类的封装方面技能上都有很大的提升。并且学会了Kotlin，也学会了看源码，从Kotlin的源码里可以看到许多Kotlin的使用技巧，这对于提升Kotlin的熟练度非常有帮助，并且习惯了研究系统源码，陆陆续续看了一些类的源码，发现源码的世界真的很奇妙，使用这些类时都有了不一样的感觉，通透了许多，果然，有些东西看透才是最重要的。</p>
<h4 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h4><p>2019年，我已经确定了接下来需要研究的领域：图形图像和音视频领域，为此，我决定花一个多的时间学习c++语言，以应对之后的NDK开发，深入理解相机，美颜效果的实现，AR/VR，视频转码等等领域。并且同时提升一下H5/css/javaScript的开发水平，还有Flutter我也是比较看好的，希望能有个成绩，嗯，就这样~~~~2019加油!!!!</p>
]]></content>
      
        <categories>
            
            <category> 感悟 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Android/java 多线程(六)-AsyncTask使用详解及源码分析]]></title>
      <url>/Threadsource6.html</url>
      <content type="html"><![CDATA[<p><strong>版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起.</strong></p>
<hr>
<p>多线程系列历史文章:<br><a href="http://www.huangjie.name/Threadsourse.html">Android/java 多线程(一)-Thread的使用以及源码分析</a><br><a href="http://www.huangjie.name/multithreading2.html">Android/java 多线程(二)-Thread的好兄弟Handler</a><br><a href="http://www.huangjie.name/Threadsourse3.html">Android/java 多线程(三)-HandlerThread的使用场景及源码解析</a><br><a href="http://www.huangjie.name/Threadsourse4.html">Android/java 多线程(四)-IntentService</a><br><a href="http://www.huangjie.name/Threadsource5.html">Android/java 多线程(五)-ThreadPoolExecutor线程池的使用</a><br><a id="more"></a></p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>一个Android封装好的轻量级异步抽象类，使用的话需要继承并重写部分方法</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>方便的实现多线程，并能方便的实现主线程与工作线程的通信，并且逻辑都在一个类中，不同于Handler的实现机制在不同的回调中，内部采用线程池管理策略，方便管理</p>
<h3 id="使用介绍"><a href="#使用介绍" class="headerlink" title="使用介绍"></a>使用介绍</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AsyncTask&lt;Params, Progress, Result&gt; &#123;</span><br><span class="line">   ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到有三个泛型参数，它们的作用分别是：</p>
<ul>
<li>Params 传递给异步任务的参数类型，对应execute()方法和doInBackground()中的参数类型</li>
<li>Progress 进度跟新参数类型,对应onProgressUpdate()方法返回的参数类型</li>
<li>Result 异步任务执行完毕的返回结果类型，对应doInBackground()方法的返回结果类型和onPostExecute()方法的参数类型</li>
</ul>
<p>如果不需要使用到，则可以使用<code>Void</code>类代替</p>
<p>简单示例：</p>
<p>申明一个实现类TestAsyncTask，主要打印方法的执行顺序以及参数及运行的线程名称<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by hj on 2018/12/29.</span><br><span class="line"> * 说明：</span><br><span class="line"> */</span><br><span class="line">public class TestAsyncTask extends AsyncTask&lt;String,Integer,Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onPostExecute(Integer integer) &#123;</span><br><span class="line">        super.onPostExecute(integer);</span><br><span class="line">        Log.i(&quot;HJ&quot;,&quot;onPostExecute方法接收的参数值:&quot;+integer+&quot;--&quot;+runThreadName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onPreExecute() &#123;</span><br><span class="line">        super.onPreExecute();</span><br><span class="line">        Log.i(&quot;HJ&quot;,&quot;onPreExecute&quot;+&quot;--&quot;+runThreadName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onProgressUpdate(Integer... values) &#123;</span><br><span class="line">        super.onProgressUpdate(values);</span><br><span class="line">        Log.i(&quot;HJ&quot;,&quot;onProgressUpdate:&quot;+ Arrays.toString(values)+&quot;--&quot;+runThreadName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Integer doInBackground(String... strings) &#123;</span><br><span class="line">        Log.i(&quot;HJ&quot;,&quot;doInBackground()&quot;+&quot;--&quot;+runThreadName());</span><br><span class="line">        publishProgress(50);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String runThreadName()&#123;</span><br><span class="line">        return &quot;运行在:&quot;+Thread.currentThread().getName()+&quot;线程&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//必须是在主线程中</span><br><span class="line"> TestAsyncTask task = new TestAsyncTask();</span><br><span class="line">        task.execute();</span><br></pre></td></tr></table></figure></p>
<p>打印结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I/HJ: onPreExecute--运行在:main线程</span><br><span class="line">I/HJ: doInBackground()--运行在:AsyncTask #1线程</span><br><span class="line">I/HJ: onProgressUpdate:[50]--运行在:main线程</span><br><span class="line">I/HJ: onPostExecute方法接收的参数值:1--运行在:main线程</span><br></pre></td></tr></table></figure></p>
<p>可以看到，只有doInBackground()方法执行在异步线程中，其他的方法都是运行在主线程中，方法执行顺序为：<br>onPreExecute()—-&gt;doInBackground()—-&gt;调用publishProgress()方法—-&gt;onProgressUpdate()——&gt;onPostExecute()</p>
<p>下面介绍一下方法的具体作用:</p>
<ul>
<li>onPreExecute  在进行异步任务处理前的一些数据准备工作</li>
<li>doInBackground 处理异步任务逻辑，内部可以调用publishProgress更新进度</li>
<li>onProgressUpdate 进度更新回调</li>
<li>onPostExecute  异步处理完毕后的结果回调 ，处理ui逻辑</li>
</ul>
<h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><p><code>AsyncTask</code>内部的实现原理为：线程池+Handler</p>
<p>其内部有两个线程池：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static final Executor SERIAL_EXECUTOR = new SerialExecutor();</span><br><span class="line">private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;</span><br><span class="line">public static final Executor THREAD_POOL_EXECUTOR;</span><br></pre></td></tr></table></figure></p>
<p><code>SERIAL_EXECUTOR</code>对应内部的<code>SerialExecutor</code>内部实现类，主要实现了异步任务的顺序分发:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">private static class SerialExecutor implements Executor &#123;</span><br><span class="line">        final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;();</span><br><span class="line">        Runnable mActive;  //当前要处理的异步任务</span><br><span class="line"></span><br><span class="line">        //给execute方法加锁保证了顺序执行</span><br><span class="line">        public synchronized void execute(final Runnable r) &#123;</span><br><span class="line">           //将一个runnable添加进双端队列中</span><br><span class="line">            mTasks.offer(new Runnable() &#123;</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        r.run();  //执行</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        scheduleNext();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            if (mActive == null) &#123;</span><br><span class="line">                scheduleNext();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //此方法的作用是将SerialExecutor 池中的任务的第一个任务赋值给mActive ，并压入到</span><br><span class="line">       //THREAD_POOL_EXECUTOR线程池中</span><br><span class="line">        protected synchronized void scheduleNext() &#123;</span><br><span class="line">            //poll()方法的作用是删除队列中的第一个并返回结果,如果为null则返回null</span><br><span class="line">            if ((mActive = mTasks.poll()) != null) &#123;</span><br><span class="line">                //将第一个任务添加到THREAD_POOL_EXECUTOR线程池中</span><br><span class="line">                THREAD_POOL_EXECUTOR.execute(mActive);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>而THREAD_POOL_EXECUTOR的实现是在这里：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(</span><br><span class="line">            CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS,</span><br><span class="line">            sPoolWorkQueue, sThreadFactory);</span><br><span class="line">    threadPoolExecutor.allowCoreThreadTimeOut(true);</span><br><span class="line">    THREAD_POOL_EXECUTOR = threadPoolExecutor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出它是一个常见的工作线程池，所以，这两个线程池，一个负责消息的任务调度，保证按照顺序执行，另外一个则是真正的异步任务处理池</p>
<p>接下来看一下它的构造方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public AsyncTask(@Nullable Looper callbackLooper) &#123;</span><br><span class="line">        //初始化一个Handler处理主线程的通信</span><br><span class="line">        mHandler = callbackLooper == null || callbackLooper == Looper.getMainLooper()</span><br><span class="line">            ? getMainHandler()</span><br><span class="line">            : new Handler(callbackLooper);</span><br><span class="line">        //初始化一个可以存储Params参数的callable实现，其实也是 </span><br><span class="line">       //THREAD_POOL_EXECUTOR.execute()的执行回调</span><br><span class="line">        mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123;</span><br><span class="line">            public Result call() throws Exception &#123;</span><br><span class="line">               //里面的回调是不是很熟悉，和HandlerThread类似</span><br><span class="line">                mTaskInvoked.set(true); //添加线程标识,用于postResultIfNotInvoked方法的检查</span><br><span class="line">                Result result = null;  //这就是onPostExecute()方法的result</span><br><span class="line">                try &#123;</span><br><span class="line">                    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">                    //noinspection unchecked</span><br><span class="line">                    result = doInBackground(mParams); //doInBackground方法在这里执行了</span><br><span class="line">                    Binder.flushPendingCommands();</span><br><span class="line">                &#125; catch (Throwable tr) &#123;</span><br><span class="line">                    mCancelled.set(true); //抛异常了取消任务</span><br><span class="line">                    throw tr;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    postResult(result); //此方法的作用是将结果发送到主线程</span><br><span class="line">                &#125;</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">         //初始化一个Future回调，主要用于检查处理结果是否发送</span><br><span class="line">        mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123;</span><br><span class="line">            //done()方法是在callable()方法之后的回调</span><br><span class="line">            @Override</span><br><span class="line">            protected void done() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    //执行检查</span><br><span class="line">                    postResultIfNotInvoked(get());</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    android.util.Log.w(LOG_TAG, e);</span><br><span class="line">                &#125; catch (ExecutionException e) &#123;</span><br><span class="line">                    throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;,</span><br><span class="line">                            e.getCause());</span><br><span class="line">                &#125; catch (CancellationException e) &#123;</span><br><span class="line">                    postResultIfNotInvoked(null);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//mWorker 的实现</span><br><span class="line">    private static abstract class WorkerRunnable&lt;Params, Result&gt; implements Callable&lt;Result&gt; &#123;</span><br><span class="line">        Params[] mParams;  //保存传入的参数</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来看看以上检查的方法的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private void postResultIfNotInvoked(Result result) &#123;</span><br><span class="line">        //执行了mWorker 里的call()回调的都会变为true,如果为false,说明任务没有被执行</span><br><span class="line">        final boolean wasTaskInvoked = mTaskInvoked.get();</span><br><span class="line">        if (!wasTaskInvoked) &#123;</span><br><span class="line">            postResult(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //将此AsyncTask对象作为message参数发送,接收到之后就会调用finish()方法结束</span><br><span class="line">    private Result postResult(Result result) &#123;</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,</span><br><span class="line">                new AsyncTaskResult&lt;Result&gt;(this, result));</span><br><span class="line">        message.sendToTarget();</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>其中的getHandler()中的Handler的实现类是<code>InternalHandler</code>，来看看它的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">  private static class InternalHandler extends Handler &#123;</span><br><span class="line">      public InternalHandler(Looper looper) &#123;</span><br><span class="line">          super(looper);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      @SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;&#125;)</span><br><span class="line">      @Override</span><br><span class="line">      public void handleMessage(Message msg) &#123;</span><br><span class="line">          </span><br><span class="line">          AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;</span><br><span class="line">          switch (msg.what) &#123;</span><br><span class="line">              case MESSAGE_POST_RESULT:</span><br><span class="line">                  //result.mData[0]就是从postResult发送过来的AsyncTask对象</span><br><span class="line">                  result.mTask.finish(result.mData[0]);  //处理结果分发，回调对应的方法</span><br><span class="line">                  break;</span><br><span class="line">              case MESSAGE_POST_PROGRESS:</span><br><span class="line">                  result.mTask.onProgressUpdate(result.mData);  //这里处理进度更新</span><br><span class="line">                  break;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private void finish(Result result) &#123;</span><br><span class="line">      // 先判断是否调用了Cancelled()</span><br><span class="line">          // 1. 若调用了则执行我们复写的onCancelled（）</span><br><span class="line">          // 即 取消任务时的操作</span><br><span class="line">          if (isCancelled()) &#123;</span><br><span class="line">              onCancelled(result);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line"></span><br><span class="line">          // 2. 若无调用Cancelled()，则执行我们复写的onPostExecute(result)</span><br><span class="line">          // 即更新UI操作</span><br><span class="line">              onPostExecute(result);</span><br><span class="line">          &#125;</span><br><span class="line">          // 注：不管AsyncTask是否被取消，都会将AsyncTask的状态变更为：FINISHED</span><br><span class="line">          mStatus = Status.FINISHED;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
<p>最后来看一下执行方法<code>execute()</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> @MainThread</span><br><span class="line"> public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123;</span><br><span class="line">     return executeOnExecutor(sDefaultExecutor, params);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">@MainThread</span><br><span class="line"> public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec,</span><br><span class="line">         Params... params) &#123;</span><br><span class="line">     if (mStatus != Status.PENDING) &#123;</span><br><span class="line">         switch (mStatus) &#123;</span><br><span class="line">             case RUNNING:</span><br><span class="line">                 throw new IllegalStateException(&quot;Cannot execute task:&quot;</span><br><span class="line">                         + &quot; the task is already running.&quot;);</span><br><span class="line">             case FINISHED:</span><br><span class="line">                 throw new IllegalStateException(&quot;Cannot execute task:&quot;</span><br><span class="line">                         + &quot; the task has already been executed &quot;</span><br><span class="line">                         + &quot;(a task can be executed only once)&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     mStatus = Status.RUNNING;</span><br><span class="line"></span><br><span class="line">     onPreExecute();</span><br><span class="line"></span><br><span class="line">     mWorker.mParams = params; //mWorker中的参数是在这里保存的</span><br><span class="line">     exec.execute(mFuture);  //将mFuture对象添加到THREAD_POOL_EXECUTOR 线程池中，mFuture在构造方法中做了初始化。</span><br><span class="line"></span><br><span class="line">     return this;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>总结：<br>1.初始化两个线程池，一个负责任务调度<code>(SerialExecutor)</code>,一个负责任务处理<code>THREAD_POOL_EXECUTOR</code><br>2.构造方法中实例化了子线程中的callable接口方法，从<code>WorkerRunnable</code>中取出<code>Params</code>对象并赋值给<code>dodoInBackground(mParams)</code>方法执行耗时任务。<br>3.执行<code>execute()</code>方法将任务提交到THREAD_POOL_EXECUTOR线程池中，并将Params参数赋值到了<code>WorkerRunnable</code>中。<br>4.调用了<code>postResult(result)</code>,通过InternalHandler 将消息回调到了主线程（执行了finish()方法，里面有onPostExecute方法),实现了UI的更新</p>
]]></content>
      
        <categories>
            
            <category> 多线程编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android/java 多线程(五)-ThreadPoolExecutor线程池的使用]]></title>
      <url>/Threadsource5.html</url>
      <content type="html"><![CDATA[<p><strong>版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起.</strong></p>
<hr>
<p>多线程系列历史文章:<br><a href="http://www.huangjie.name/Threadsourse.html">Android/java 多线程(一)-Thread的使用以及源码分析</a><br><a href="http://www.huangjie.name/multithreading2.html">Android/java 多线程(二)-Thread的好兄弟Handler</a><br><a href="http://www.huangjie.name/Threadsourse3.html">Android/java 多线程(三)-HandlerThread的使用场景及源码解析</a><br><a href="http://www.huangjie.name/Threadsourse4.html">Android/java多线程(四)-IntentService</a><br><a id="more"></a></p>
<blockquote>
<p>前面几篇文章主要都是介绍的单个线程的运用以及原理，这篇文章开始讲解多个线程的运用</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>线程池是一个能对多个线程进行统一管理的一套机制，它具有诸多的优点：</p>
<ul>
<li>能对线程进行复用，当有空闲的线程，线程池会复用这些线程而不会去重新创建，节省了资源</li>
<li>能灵活创建各种线程使用场景，内部封装了常用线程池创建逻辑，并支持自定义线程池逻辑创建</li>
<li>能准确的对每一个线程进行管理，并能读取每个线程的一写基础信息，方便进行一些逻辑处理</li>
</ul>
</blockquote>
<p>缺点：<br>线程中的数据传递没有Handler机制方便</p>
<p>使用场景：<br>具有诸多耗时任务的情况，当系统为每一个任务创建一个线程，会占用系统的大量资源，容易引起界面的卡顿，线程池的复用机制就很好的解决了这个问题</p>
<h3 id="常用的线程池的使用"><a href="#常用的线程池的使用" class="headerlink" title="常用的线程池的使用"></a>常用的线程池的使用</h3><h5 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                          int maximumPoolSize,</span><br><span class="line">                          long keepAliveTime,</span><br><span class="line">                          TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                          ThreadFactory threadFactory,</span><br><span class="line">                          RejectedExecutionHandler handler) &#123;</span><br><span class="line">    if (corePoolSize &lt; 0 ||</span><br><span class="line">        maximumPoolSize &lt;= 0 ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    if (workQueue == null || threadFactory == null || handler == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    this.corePoolSize = corePoolSize;</span><br><span class="line">    this.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    this.workQueue = workQueue;</span><br><span class="line">    this.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    this.threadFactory = threadFactory;</span><br><span class="line">    this.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>传入不同的参数，实现的效果也不同,下面说一下每个参数的作用:</p>
<ul>
<li>corePoolSize 核心线程数,，即使空闲时仍保留在池中的线程数,除非设置了<code>allowCoreThreadTimeOut</code></li>
<li>maximumPoolSize 线程池中允许的最大线程数</li>
<li>keepAliveTime 顾名思义，线程终止前的存活时间，即当线程数大于核心线程数(corePoolSize )时,多余的空闲线程在终止之前等待新任务的最大时间</li>
<li>TimeUnit  <code>keepAliveTime</code>的单位</li>
<li>workQueue 在执行任务之前用于保存任务的队列。 该队列将仅保存execute方法提交的Runnable任务。</li>
<li>ThreadFactory  执行程序创建新线程时使用的工厂</li>
<li>RejectedExecutionHandler  执行被阻止时使用的处理程序</li>
</ul>
<p>这里说一下各个参数的配置套路,当使用<code>execute(Runnable)</code>方法添加一个任务到队列中，如果<code>corePoolSize</code>比<code>maximumPoolSize</code>小，队列满了后就会去创建新的线程,当<code>corePoolSize</code>与<code>maximumPoolSize</code>相等时，就会创建一个固定大小的核心线程池。如果将<code>maximumPoolSize</code>设置为无限大(例如nteger.MAX_VALUE)，则是创建一个能容纳任意数量任务的线程池。<br><code>ThreadFactory</code>的作用是用来创建新的线程的，它是一个接口,实现它即可创建一个新的线程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public interface ThreadFactory &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Constructs a new &#123;@code Thread&#125;.  Implementations may also initialize</span><br><span class="line">     * priority, name, daemon status, &#123;@code ThreadGroup&#125;, etc.</span><br><span class="line">     *</span><br><span class="line">     * @param r a runnable to be executed by new thread instance</span><br><span class="line">     * @return constructed thread, or &#123;@code null&#125; if the request to</span><br><span class="line">     *         create a thread is rejected</span><br><span class="line">     */</span><br><span class="line">    Thread newThread(Runnable r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过它，你可以指定线程的名称，优先级，守护进程等，如果不设置，则会默认使用<code>Executors.defaultThreadFactory()</code>，它会创建一个与所有线程与所有相同的<code>ThreadGroup</code>并且具有相同的优先级和非守护进程状态<code>NORM_PRIORITY</code>。<br><code>workQueue</code>是一个排队策略,一般有三种:</p>
<ul>
<li>直接切换：对应<code>SynchronousQueue</code>实现类，将任务直接交给线程处理，不需要另外的控制，通常需要配置一个无限制的<code>maximumPoolSizes</code>，以避免拒绝掉新提交的任务</li>
<li>无界队列:对应<code>LinkedBlockingDeque</code>实现类，它没有预定的容量，当有新的任务，会在队列中等待，直到加入到corePoolSize的线程中，如果corePoolSize线程一直很忙，也不会去创建新的线程，此时，最大值最小值对它没有任何的影响，每个任务与其他的任务都是独立的，不会互相影响</li>
<li>有边界的队列：例如<code>ArrayBlockingQueue</code>实现类,它有助于在使用有限的maxPoolSize时防止资源的耗尽，但它更难调整与控制。</li>
</ul>
<p>一般情况下我们都可以通过java提供的工厂模式来构造我们的线程池策略，主要提供了以下几种方式:</p>
<h5 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h5><p>特点:</p>
<ul>
<li>线程重用，如果没有重用的线程，将会创建一个新的线程添加到池中</li>
<li>适合执行短期异步任务程序，默认为60秒的线程等待时间，超过就会终止与移除</li>
<li>闲置的线程不会消耗资源</li>
</ul>
<p>源码配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                  60L, TimeUnit.SECONDS,</span><br><span class="line">                                  new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用场景:<br>它创建了一个无限扩大的线程池，但没有核心线程池，因此资源占用少，适合处理一些短期的异步任务</p>
<h5 id="newFixedThreadPool-1"><a href="#newFixedThreadPool-1" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h5><p>特点:</p>
<ul>
<li>创建一个固定数量的线程池，不能随时的新建线程，如果队列已满，提交了新任务，必须等待一个可用的线程</li>
<li>线程会一直存在，直到调用shutdown方法</li>
</ul>
<p>源码配置:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">    return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用场景:<br>它创建了一个核心线程数与最大线程数相同的线程池，适用于已知任务数量，对线程数量进行限制的场景</p>
<h5 id="newWorkStealingPool"><a href="#newWorkStealingPool" class="headerlink" title="newWorkStealingPool"></a>newWorkStealingPool</h5><p>特点:</p>
<ul>
<li>创建使用所有给定并行级别的线程池，并且可以使用多个队列来减少占用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newWorkStealingPool() &#123;</span><br><span class="line">    return new ForkJoinPool</span><br><span class="line">        (Runtime.getRuntime().availableProcessors(),</span><br><span class="line">         ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">         null, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>使用场景:<br>它能创建一个拥有多个任务队列的线程池，可以减少链接数。并且它是默认创建当前可用cpu数量的线程来并行执行，因此适用于非常耗时的操作，并且可以并行执行</p>
<h5 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h5><p>特点：</p>
<ul>
<li>有且只有一个任务处于活动状态</li>
<li>先提交的先执行，有任务顺序</li>
<li>当任务出现异常，会另创建一个新的线程替换<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class="line">    return new FinalizableDelegatedExecutorService</span><br><span class="line">        (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>使用场景:<br>它是一个单例线程，并且有执行顺序，所以适用于有执行顺序的任务，并且有且只有一个任务是执行中的</p>
<h5 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h5><p>特点：</p>
<ul>
<li>能设置延迟时间，能定期执行</li>
<li>空闲的线程会保留</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public ScheduledThreadPoolExecutor(int corePoolSize) &#123;</span><br><span class="line">    super(corePoolSize, Integer.MAX_VALUE,</span><br><span class="line">          DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line">          new DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用场景：<br>它具有定时特性，因此可以用来执行周期行的任务</p>
<p>五大线程池介绍完毕，此外还有其他的常用方法:</p>
<ul>
<li><code>execute(Runnable command)</code> 提交任务，在将来的某个时间点执行任务</li>
<li><code>afterExecute(Runnale r,Throwable t)</code> 在指定的Runnale执行后调用此方法</li>
<li><code>beforeExecute(Thread t,Runnable r)</code>在给定的线程中执行给定的Runnable之前调用方法</li>
<li><code>funalize</code> 当执行器不再被引用并且没有线程时，调用<code>shundown</code></li>
<li>shundown 启动有序关闭，先前提交的任务会执行，执行完毕后关闭</li>
<li><code>shundownNow</code> 主动停止执行中的任务，并返回正在执行等待的任务列表</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 多线程编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android/java多线程(四)-IntentService]]></title>
      <url>/Threadsource4.html</url>
      <content type="html"><![CDATA[<p><strong>版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起.</strong></p>
<hr>
<p>往期文章:<br><a href="http://www.huangjie.name/Threadsourse.html">Android/java 多线程(一)-Thread的使用以及源码分析</a><br><a href="http://www.huangjie.name/multithreading2.html">Android/java 多线程(二)-Thread的好兄弟Handler</a><br><a href="http://www.huangjie.name/Threadsourse3.html">Android/java 多线程(三)-HandlerThread的使用场景及源码解析</a><br><a id="more"></a></p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>一个方便的能在子线程中运行的服务，一个IntentService对应一个线程，由于是四大组件，优先级比线程高，不易被系统回收，处理完任务还能主动回收，因此用来处理后台下载任务极为适合</p>
<h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>先继承此类，重写必要的方法，我们的逻辑处理是在<code>onHandleIntent()</code>方法中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by hj on 2018/12/21.</span><br><span class="line"> * 说明：</span><br><span class="line"> */</span><br><span class="line">public class MyIntentService extends IntentService &#123;</span><br><span class="line"></span><br><span class="line">    public MyIntentService() &#123;</span><br><span class="line">        super(&quot;MyIntentService&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onHandleIntent(@Nullable Intent intent) &#123;</span><br><span class="line">        //核心方法，处理异步逻辑</span><br><span class="line">        Log.i(&quot;HJ&quot;,&quot;onHandleIntent&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int onStartCommand(@Nullable Intent intent, int flags, int startId) &#123;</span><br><span class="line">        Log.i(&quot;HJ&quot;,&quot;onStartCommand&quot;);</span><br><span class="line">        return super.onStartCommand(intent, flags, startId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        Log.i(&quot;HJ&quot;, &quot;onCreate&quot;);</span><br><span class="line">        super.onCreate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onDestroy() &#123;</span><br><span class="line">        Log.i(&quot;HJ&quot;,&quot;onDestroy&quot;);</span><br><span class="line">        super.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在清单文件中注册:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;service android:name=&quot;.MyIntentService&quot;&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=&quot;com.jay.thread&quot;/&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/service&gt;</span><br></pre></td></tr></table></figure></p>
<p>在Activity中运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = new Intent(&quot;com.jay.thread&quot;);</span><br><span class="line">intent.setPackage(getPackageName());</span><br><span class="line">startService(intent);</span><br></pre></td></tr></table></figure></p>
<p>打印的结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2018-12-21 15:03:14.848 4241-4241/com.zj.example.customview.funnel I/HJ: onCreate</span><br><span class="line">2018-12-21 15:03:14.850 4241-4241/com.zj.example.customview.funnel I/HJ: onStartCommand</span><br><span class="line">2018-12-21 15:03:14.850 4241-4258/com.zj.example.customview.funnel I/HJ: onHandleIntent</span><br><span class="line">2018-12-21 15:03:16.225 4241-4241/com.zj.example.customview.funnel I/HJ: onDestroy</span><br></pre></td></tr></table></figure></p>
<p>可以看到，它的生命周期是<code>onCreate()</code>-&gt;<code>onStartCommand()</code>-&gt;<code>onHandleIntent()</code>-&gt;<code>onDestroy()</code>,而且当它把<code>onHandleIntent()</code>方法里的逻辑处理完毕后会自动调用<code>onDestroy</code>来结束，所以我们不需要主动来关闭它。</p>
<p>而且说到隐式启动Service，这里要叨逼两句，如果我把上面的<code>intent.setPackage(getPackageName())</code>去掉那么在5.0以上机型会遇到这种异常：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.lang.IllegalArgumentException: Service Intent must be explicit: Intent &#123; act=com.jay.thread &#125;</span><br><span class="line">       at android.app.ContextImpl.validateServiceIntent(ContextImpl.java:1448)</span><br><span class="line">       at android.app.ContextImpl.startServiceCommon(ContextImpl.java:1489)</span><br><span class="line">       at android.app.ContextImpl.startService(ContextImpl.java:1461)</span><br><span class="line">       at android.content.ContextWrapper.startService(ContextWrapper.java:644)</span><br><span class="line">       at com.zj.example.customview.funnel.MainActivity.onCreate(MainActivity.java:34)</span><br><span class="line">       at android.app.Activity.performCreate(Activity.java:6975)</span><br><span class="line">       at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1213)</span><br><span class="line">       at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2770)</span><br><span class="line">       at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2892) </span><br><span class="line">       at android.app.ActivityThread.-wrap11(Unknown Source:0) </span><br><span class="line">       at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1593) </span><br><span class="line">       at android.os.Handler.dispatchMessage(Handler.java:105) </span><br><span class="line">       at android.os.Looper.loop(Looper.java:164) </span><br><span class="line">       at android.app.ActivityThread.main(ActivityThread.java:6541) </span><br><span class="line">       at java.lang.reflect.Method.invoke(Native Method) </span><br><span class="line">       at com.android.internal.os.Zygote$MethodAndArgsCaller.run(Zygote.java:240) </span><br><span class="line">       at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:767)</span><br></pre></td></tr></table></figure></p>
<p>原因是在5.0源码中谷歌做了限制，如果component和package都为空，那么就会抛出这个异常，详见源码(源码位置：sdk/sources/android21/android/app/ContextImpl.java）:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private void validateServiceIntent(Intent service) &#123;</span><br><span class="line">       if (service.getComponent() == null &amp;&amp; service.getPackage() == null) &#123;</span><br><span class="line">           if (getApplicationInfo().targetSdkVersion &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">               IllegalArgumentException ex = new IllegalArgumentException(</span><br><span class="line">                       &quot;Service Intent must be explicit: &quot; + service);</span><br><span class="line">               throw ex;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               Log.w(TAG, &quot;Implicit intents with startService are not safe: &quot; + service</span><br><span class="line">                       + &quot; &quot; + Debug.getCallers(2, 3));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>So,我们只要保证其中一个不为空就可以啦.</p>
<h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><p>源码还是比较简单，可以先从<code>onCreate()</code>方法看起，具体逻辑见注释：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">public abstract class IntentService extends Service &#123;</span><br><span class="line">    private volatile Looper mServiceLooper; //HandlerThread中的Looper</span><br><span class="line">    private volatile ServiceHandler mServiceHandler; //逻辑处理Handler</span><br><span class="line">    private String mName; //线程名称</span><br><span class="line">    private boolean mRedelivery; //是否保证intent在服务被杀死后能被接收到</span><br><span class="line"></span><br><span class="line">    //子线程Handler的逻辑处理类</span><br><span class="line">    private final class ServiceHandler extends Handler &#123;</span><br><span class="line">        public ServiceHandler(Looper looper) &#123;</span><br><span class="line">            super(looper);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            onHandleIntent((Intent)msg.obj); //onHandleIntent方法回调</span><br><span class="line">            stopSelf(msg.arg1); //自动回收</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public IntentService(String name) &#123;</span><br><span class="line">        super();</span><br><span class="line">        mName = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">   /**</span><br><span class="line">   *此方法的作用：如果为true,则将Service StartResult状态置为START_REDELIVER_INTENT,这样当onHandleIntent方法还未回调的时候服务被回收，重启的时候onHandleIntent方法会被回调,发送上一次回收前的intent,如果有多个intent,将会发送最后一个意图</span><br><span class="line">   *</span><br><span class="line">   **/</span><br><span class="line">    public void setIntentRedelivery(boolean enabled) &#123;</span><br><span class="line">        mRedelivery = enabled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate()&#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">        //创建HandlerThread 并将线程命名为IntentService+自定义名称的形式</span><br><span class="line">        HandlerThread thread = new HandlerThread(&quot;IntentService[&quot; + mName + &quot;]&quot;);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        mServiceLooper = thread.getLooper();</span><br><span class="line">        mServiceHandler = new ServiceHandler(mServiceLooper); //将HandlerThread里初始化的looper设置给子线程Handler</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onStart(@Nullable Intent intent, int startId) &#123;</span><br><span class="line">        Message msg = mServiceHandler.obtainMessage();</span><br><span class="line">        msg.arg1 = startId;</span><br><span class="line">        msg.obj = intent;  //我们在onHandleIntent方法里接收的intent是在这里赋值的</span><br><span class="line">        mServiceHandler.sendMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * You should not override this method for your IntentService. Instead,</span><br><span class="line">     * override &#123;@link #onHandleIntent&#125;, which the system calls when the IntentService</span><br><span class="line">     * receives a start request.</span><br><span class="line">     * @see android.app.Service#onStartCommand</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public int onStartCommand(@Nullable Intent intent, int flags, int startId) &#123;</span><br><span class="line">        onStart(intent, startId);</span><br><span class="line">        //StartResult状态设置是在这里</span><br><span class="line">        return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onDestroy() &#123;</span><br><span class="line">        mServiceLooper.quit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //这里将返回值置为了null，所以不建议使用bindService的形式来启动它，如果需要，建议直接使用Service</span><br><span class="line">    @Override</span><br><span class="line">    @Nullable</span><br><span class="line">    public IBinder onBind(Intent intent) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * This method is invoked on the worker thread with a request to process.</span><br><span class="line">     * Only one Intent is processed at a time, but the processing happens on a</span><br><span class="line">     * worker thread that runs independently from other application logic.</span><br><span class="line">     * So, if this code takes a long time, it will hold up other requests to</span><br><span class="line">     * the same IntentService, but it will not hold up anything else.</span><br><span class="line">     * When all requests have been handled, the IntentService stops itself,</span><br><span class="line">     * so you should not call &#123;@link #stopSelf&#125;.</span><br><span class="line">     *</span><br><span class="line">     * @param intent The value passed to &#123;@link</span><br><span class="line">     *               android.content.Context#startService(Intent)&#125;.</span><br><span class="line">     *               This may be null if the service is being restarted after</span><br><span class="line">     *               its process has gone away; see</span><br><span class="line">     *               &#123;@link android.app.Service#onStartCommand&#125;</span><br><span class="line">     *               for details.</span><br><span class="line">     */</span><br><span class="line">    @WorkerThread</span><br><span class="line">    protected abstract void onHandleIntent(@Nullable Intent intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们在源码中看到，内部实现其实还是<code>HandlerThread</code>+<code>Handler</code>的方式，<code>onCreate()</code>中做了一些初始化的操作，在<code>onStart</code>中将<code>intent</code>用obj的方式传递给了<code>ServiceHandler</code>,然后在<code>handleMessage</code>中拿到intent并调用了<code>onHandleIntent</code>回调出来，这样一个完整的线程有序循环就建立了，而且因为是四大组件，存活率有很大的提升，这是直接用线程实现所没有的优势</p>
<p>看完了源码，有没有对HandlerThread+Handler的应用进一步加深呢？</p>
]]></content>
      
        <categories>
            
            <category> 多线程编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android/java多线程(三)-HandlerThread的使用场景及源码解析]]></title>
      <url>/Threadsource3.html</url>
      <content type="html"><![CDATA[<p><strong>版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起.</strong></p>
<hr>
<h3 id="HandlerThread是什么？"><a href="#HandlerThread是什么？" class="headerlink" title="HandlerThread是什么？"></a>HandlerThread是什么？</h3><p>点开类楸一眼，这货是这样介绍自己的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* Handy class for starting a new thread that has a looper. The looper can then be </span><br><span class="line">* used to create handler classes. Note that start() must still be called.</span><br></pre></td></tr></table></figure></p>
<p>大意是说它是用来启动具有一个内部循环的新线程的一个便利类。<br>内部循环？同时名称又有Handler又有Thread，看过我这篇文章的同学估计猜到了，这货估计是Handler与Thread的亲儿子无疑了,但是两个好基友哪来的儿子呢，囧~~~~<br>往期目录：<br><a href="https://www.jianshu.com/p/853be38bcd0a" target="_blank" rel="noopener">Android/java 多线程(一)-Thread的使用以及源码分析</a><br><a href="https://www.jianshu.com/p/35ace3aa0022" target="_blank" rel="noopener">Android/java 多线程(二)-Thread的好兄弟Handler</a></p>
<p>我在上篇文章介绍Handler的时候举了一个例子，在子线程中使用Handler：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class MyThread extends Thread &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        Looper.prepare();</span><br><span class="line">        @SuppressLint(&quot;HandlerLeak&quot;)</span><br><span class="line">        Handler mHandler = new Handler()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void handleMessage(Message msg) &#123;</span><br><span class="line">                 //处理逻辑</span><br><span class="line">                l(Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Message message = mHandler.obtainMessage(1);</span><br><span class="line">        mHandler.sendMessage(message);</span><br><span class="line">        Looper.loop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>是不是显得巨麻烦，而且巨丑，<code>HandlerThread</code>就是为了防止我们写出如此丑陋的代码而生的，它的本质原理其实也就是以上那几行代码。不信？，我们来瞅瞅</p>
<h3 id="HandlerThread源码"><a href="#HandlerThread源码" class="headerlink" title="HandlerThread源码"></a>HandlerThread源码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">public class HandlerThread extends Thread &#123;</span><br><span class="line">    int mPriority; //线程优先级</span><br><span class="line">    int mTid = -1; </span><br><span class="line">    Looper mLooper;</span><br><span class="line">    private @Nullable Handler mHandler;</span><br><span class="line"></span><br><span class="line">//指定线程的名称，默认线程优先级为DEFAULT,也是最低级的</span><br><span class="line">    public HandlerThread(String name) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">        mPriority = Process.THREAD_PRIORITY_DEFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">//指定线程的名称，同时指定线程的优先级</span><br><span class="line">    public HandlerThread(String name, int priority) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">        mPriority = priority;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //这里主要处理一些数据的初始化啊一些子线程的逻辑操作啥的，在run()方法中回调</span><br><span class="line">    protected void onLooperPrepared() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   //熟悉的run()方法</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        mTid = Process.myTid();</span><br><span class="line">        Looper.prepare();  //创建Looper()</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            mLooper = Looper.myLooper();</span><br><span class="line">            notifyAll();  //到这里Looper已经创建完毕，唤醒阻塞的线程</span><br><span class="line">        &#125;</span><br><span class="line">        //设置线程优先级</span><br><span class="line">        Process.setThreadPriority(mPriority);</span><br><span class="line">        onLooperPrepared(); //执行onLooperPrepared()方法</span><br><span class="line">        Looper.loop(); //开启循环</span><br><span class="line">        mTid = -1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * This method returns the Looper associated with this thread. If this thread not been started</span><br><span class="line">     * or for any reason isAlive() returns false, this method will return null. If this thread</span><br><span class="line">     * has been started, this method will block until the looper has been initialized.  </span><br><span class="line">     * @return The looper.</span><br><span class="line">     */</span><br><span class="line">    public Looper getLooper() &#123;</span><br><span class="line">        if (!isAlive()) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // If the thread has been started, wait until the looper has been created.</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            while (isAlive() &amp;&amp; mLooper == null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    wait();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return mLooper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @return a shared &#123;@link Handler&#125; associated with this thread</span><br><span class="line">     * @hide</span><br><span class="line">     */</span><br><span class="line">    @NonNull</span><br><span class="line">    public Handler getThreadHandler() &#123;</span><br><span class="line">        if (mHandler == null) &#123;</span><br><span class="line">            mHandler = new Handler(getLooper());</span><br><span class="line">        &#125;</span><br><span class="line">        return mHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">   //非安全的结束循环</span><br><span class="line">    public boolean quit() &#123;</span><br><span class="line">        Looper looper = getLooper();</span><br><span class="line">        if (looper != null) &#123;</span><br><span class="line">            looper.quit();</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   ////安全的结束循环</span><br><span class="line">    public boolean quitSafely() &#123;</span><br><span class="line">        Looper looper = getLooper();</span><br><span class="line">        if (looper != null) &#123;</span><br><span class="line">            looper.quitSafely();</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns the identifier of this thread. See Process.myTid().</span><br><span class="line">     */</span><br><span class="line">    public int getThreadId() &#123;</span><br><span class="line">        return mTid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结合源码，这货其实也就是在run()中开启了Looper循环，并提供了一个<code>onLooperPrepared ()</code>方法供我们使用，做一些初始化的操作。<br>需要注意的是<code>quit()</code>方法和<code>quitSafely()</code>的区别，<code>quit()</code>是立即停止Looper循环，此时可能有消息未处理就GG了，所以说它的不安全的，而<code>quitSafely()</code>是等待消息处理完毕后才停止Looper循环，所以说它是安全的，另外可以看到它指定线程优先级是使用的<code>Process.setThreadPriority(mPriority)</code>方法，所有它的可选值是从<code>Process()</code>里面获取</p>
<h3 id="HandlerThread的使用场景"><a href="#HandlerThread的使用场景" class="headerlink" title="HandlerThread的使用场景"></a>HandlerThread的使用场景</h3><h4 id="HandlerThread小朋友的优点"><a href="#HandlerThread小朋友的优点" class="headerlink" title="HandlerThread小朋友的优点"></a>HandlerThread小朋友的优点</h4><p>HandlerThread里面的本质实际上是子线程消息轮询机制，我们能够从中获取到一个在子线程中轮询的Looper，如果设置给Handler,那么这个Handler就能在子线程中处理消息。所以它特别适合处理大量需要排队等待或需要重复操作的又耗时的逻辑，它既能够方便的通知主线程更新UI，内部又能方便的做线程的队列处理，所以它的使用还是比较广泛滴。</p>
<h4 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h4><p>假设有这么个需求：需要批量下载文件，一次只能下载一个，下载完毕后自动下载下一个，或者这个下载失败或暂停自动下载下一个(是不是有点像某雷的下载场景)，伪实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by hj on 2018/12/21.</span><br><span class="line"> * 说明：模拟线程下载</span><br><span class="line"> */</span><br><span class="line">public class DownloadHandlerThread extends HandlerThread implements Handler.Callback &#123;</span><br><span class="line"></span><br><span class="line">    private Handler workHandler; //处理下载逻辑的Handler</span><br><span class="line">    private Handler uiHandler; //处理UI刷新的Handler</span><br><span class="line"></span><br><span class="line">    public final static int READY = 0X110;</span><br><span class="line">    public final static int STAR = 0X111;</span><br><span class="line">    public final static int STOP = 0X112;</span><br><span class="line">    public final static int ERROR = 0X113;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private int max;</span><br><span class="line">    private int index;</span><br><span class="line"></span><br><span class="line">    public DownloadHandlerThread() &#123;</span><br><span class="line">        super(&quot;download-thread&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onLooperPrepared() &#123;</span><br><span class="line">        //初始化</span><br><span class="line">        workHandler = new Handler(getLooper(), this);</span><br><span class="line">        if (uiHandler == null) &#123;</span><br><span class="line">            throw new NullPointerException(&quot;uiHandler is not null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        uiHandler.sendEmptyMessage(READY); //通知主线程Looper已经准备完毕，可以开始下载了</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean handleMessage(Message msg) &#123;</span><br><span class="line">        switch (msg.what) &#123;</span><br><span class="line">            case STAR: //开始下载</span><br><span class="line">                index++; //记录当前下载到了第几个</span><br><span class="line">                String url = msg.getData().getString(&quot;url&quot;);</span><br><span class="line">                Log.i(&quot;HJ&quot;, &quot;准备下载：&quot; + url);</span><br><span class="line">                try &#123;</span><br><span class="line">                    sleep(2000); //模拟下载</span><br><span class="line">                    if (index == 2) &#123;  //下载到第二个的时候模拟下载失败</span><br><span class="line">                        Log.i(&quot;HJ&quot;, &quot;下载出错：&quot; + url);</span><br><span class="line">                        setErrorMessage(url);</span><br><span class="line">                        Log.i(&quot;HJ&quot;, &quot;开始下载下一个地址&quot;);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        Log.i(&quot;HJ&quot;, &quot;当前地址下载完成：&quot; + url);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    setErrorMessage(url);</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                if (index == max) &#123; //全部下载完毕</span><br><span class="line">                    workHandler.sendEmptyMessage(STOP);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case STOP: //全部下载完成</span><br><span class="line">                </span><br><span class="line">                //退出Looper循环</span><br><span class="line">                if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR2) &#123;</span><br><span class="line">                    quitSafely();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    quit();</span><br><span class="line">                &#125;</span><br><span class="line">                Log.i(&quot;HJ&quot;, &quot;全部下载完成&quot;);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //发送下载错误消息到主线程用于刷新UI</span><br><span class="line">    private void setErrorMessage(String url) &#123;</span><br><span class="line">        Message errorMsg = new Message();</span><br><span class="line">        errorMsg.what = ERROR;</span><br><span class="line">        Bundle bundle = new Bundle();</span><br><span class="line">        bundle.putString(&quot;errorUrl&quot;, url);</span><br><span class="line">        errorMsg.setData(bundle);</span><br><span class="line">        uiHandler.sendMessage(errorMsg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUiHandler(Handler uiHandler) &#123;</span><br><span class="line">        this.uiHandler = uiHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Handler getWorkHandler() &#123;</span><br><span class="line">        return workHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMax(int max) &#123;</span><br><span class="line">        this.max = max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在Activity中使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    private Handler uiHandler; </span><br><span class="line">    //模拟数据源</span><br><span class="line">    private String[] urls = new String[]&#123;</span><br><span class="line">            &quot;url-1&quot;, &quot;url-2&quot;, &quot;url-3&quot;, &quot;url-4&quot;, &quot;url-5&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">    private DownloadHandlerThread mThread;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        initUiHandler();</span><br><span class="line">        initDownLoad();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressLint(&quot;HandlerLeak&quot;)</span><br><span class="line">    private void initUiHandler() &#123;</span><br><span class="line">        uiHandler = new Handler() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void handleMessage(Message msg) &#123;</span><br><span class="line">                switch (msg.what) &#123;</span><br><span class="line">                    case DownloadHandlerThread.READY: //获取到workHandler已经初始化完毕，可以进行下载任务了</span><br><span class="line">                        Handler workHandler = mThread.getWorkHandler();</span><br><span class="line">                        mThread.setMax(urls.length);</span><br><span class="line">                        for (String url : urls) &#123;  //循环将Message加入MessageQueue消息池中</span><br><span class="line">                            Message message = new Message();</span><br><span class="line">                            message.what = DownloadHandlerThread.STAR;</span><br><span class="line">                            Bundle bundle = new Bundle();</span><br><span class="line">                            bundle.putString(&quot;url&quot;, url);</span><br><span class="line">                            message.setData(bundle);</span><br><span class="line">                            workHandler.sendMessage(message);</span><br><span class="line">                        &#125;</span><br><span class="line">                        break;</span><br><span class="line">                    case DownloadHandlerThread.ERROR:  //处理下载失败UI逻辑</span><br><span class="line">                        String url = msg.getData().getString(&quot;errorUrl&quot;);</span><br><span class="line">                        showShortToast(&quot;下载失败链接:&quot; + url);</span><br><span class="line">                        Log.i(&quot;HJ&quot;,&quot;展示下载失败UI&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;);</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void showShortToast(String string) &#123;</span><br><span class="line">        Toast.makeText(this, string, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void initDownLoad() &#123;</span><br><span class="line">        mThread = new DownloadHandlerThread();</span><br><span class="line">        mThread.setUiHandler(uiHandler);</span><br><span class="line">        mThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">2018-12-21 11:51:02.775 2390-2432/com.zj.example.customview.funnel I/HJ: 准备下载：url-1</span><br><span class="line">2018-12-21 11:51:04.775 2390-2432/com.zj.example.customview.funnel I/HJ: 当前地址下载完成：url-1</span><br><span class="line">2018-12-21 11:51:04.775 2390-2432/com.zj.example.customview.funnel I/HJ: 准备下载：url-2</span><br><span class="line">2018-12-21 11:51:06.777 2390-2432/com.zj.example.customview.funnel I/HJ: 下载出错：url-2</span><br><span class="line">2018-12-21 11:51:06.777 2390-2432/com.zj.example.customview.funnel I/HJ: 开始下载下一个地址</span><br><span class="line">2018-12-21 11:51:06.778 2390-2432/com.zj.example.customview.funnel I/HJ: 准备下载：url-3</span><br><span class="line">2018-12-21 11:51:06.779 2390-2390/com.zj.example.customview.funnel I/HJ: 展示下载失败UI&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">2018-12-21 11:51:08.778 2390-2432/com.zj.example.customview.funnel I/HJ: 当前地址下载完成：url-3</span><br><span class="line">2018-12-21 11:51:08.778 2390-2432/com.zj.example.customview.funnel I/HJ: 准备下载：url-4</span><br><span class="line">2018-12-21 11:51:10.779 2390-2432/com.zj.example.customview.funnel I/HJ: 当前地址下载完成：url-4</span><br><span class="line">2018-12-21 11:51:10.779 2390-2432/com.zj.example.customview.funnel I/HJ: 准备下载：url-5</span><br><span class="line">2018-12-21 11:51:12.783 2390-2432/com.zj.example.customview.funnel I/HJ: 当前地址下载完成：url-5</span><br><span class="line">2018-12-21 11:51:12.783 2390-2432/com.zj.example.customview.funnel I/HJ: 全部下载完成</span><br></pre></td></tr></table></figure></p>
<p>可以看到<code>DownloadHandlerThread</code>主要承载的功能如下:</p>
<ul>
<li>初始化一个子线程Handler用于处理子线程的消息通信</li>
<li>执行下载任务以及与主线程的ui通信</li>
</ul>
<p>这样的处理方式极大的方便了ui线程与子线程的通讯，只需要用不同的handler发送消息即可，来再多的handler都不怕。而且这只需要开启一个线程，极大的节省了内存空间，而且能让线程任务有序进行，方便管理。</p>
<p>建议将以上代码复制过去跑一跑，调试一下，这样能更快的理解HandlerThread的通信以及它的便捷通信机制。</p>
]]></content>
      
        <categories>
            
            <category> 多线程编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android/java 多线程(二)-Thread的好兄弟Handler]]></title>
      <url>/multithreading2.html</url>
      <content type="html"><![CDATA[<p><strong>版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起.</strong></p>
<hr>
<blockquote>
<p>上一篇带大家了解了Thread的使用以及基本的运行原理，这一篇就带大家了解下Thread的好兄弟Handler</p>
</blockquote>
<a id="more"></a>
<p><a href="http://www.huangjie.name/Threadsourse.html">Android/java 多线程(一)-Thread的使用以及源码分析</a></p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Handler机制在安卓中应用非常广泛，像我们常见的用于在子线程中更新UI：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    @SuppressLint(&quot;HandlerLeak&quot;)</span><br><span class="line">    private Handler mHandler = new Handler()&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            //更新UI</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        MyThread thread = new MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class MyThread extends Thread &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">             //处理子线程逻辑</span><br><span class="line">            //....</span><br><span class="line">            //发送消息更新UI</span><br><span class="line">            Message message = mHandler.obtainMessage(1);</span><br><span class="line">            mHandler.sendMessage(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由此引出一些问题，为什么<code>sendMessage</code>之后<code>handleMessage</code>方法会被执行?.为什么<code>handleMessage</code>是在主线程中?.它们的消息是如何传递的?.这些会在下面讲解</p>
<p>且看还有一种使用情况，在子线程中使用Handler:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        MyThread thread = new MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class MyThread extends Thread &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            Looper.prepare();</span><br><span class="line">            @SuppressLint(&quot;HandlerLeak&quot;)</span><br><span class="line">            Handler mHandler = new Handler()&#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void handleMessage(Message msg) &#123;</span><br><span class="line">                     //处理逻辑</span><br><span class="line">                    l(Thread.currentThread().getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            Message message = mHandler.obtainMessage(1);</span><br><span class="line">            mHandler.sendMessage(message);</span><br><span class="line">            Looper.loop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void l(String s) &#123;</span><br><span class="line">        Log.i(&quot;HJ&quot;, s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>打印结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2018-12-20 10:48:21.682 1808-1824/? I/HJ: Thread-2</span><br></pre></td></tr></table></figure></p>
<p>如果我们不使用<code>Looper.prepare()</code>和<code>Looper.loop()</code>方法，直接运行，那么会抛出以下异常：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2018-12-20 11:00:49.654 2029-2045/com.zj.example.customview.funnel E/AndroidRuntime: FATAL EXCEPTION: Thread-2</span><br><span class="line">    Process: com.zj.example.customview.funnel, PID: 2029</span><br><span class="line">    java.lang.RuntimeException: Only one Looper may be created per thread</span><br><span class="line">        at android.os.Looper.prepare(Looper.java:95)</span><br><span class="line">        at android.os.Looper.prepare(Looper.java:90)</span><br><span class="line">        at com.zj.example.customview.funnel.MainActivity$MyThread.run(MainActivity.java:48)</span><br></pre></td></tr></table></figure></p>
<p>这是为什么呢？，为什么子线程不能直接创建Handler呢？使用了<code>Looper.prepare()</code>和<code>Looper.loop()</code>为什么又可以了呢？，这两个方法又是干什么用的呢？请看以下源码分析。</p>
<h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><p>Handler机制的核心类主要有三个，<code>Handler</code> ,<code>Message</code>,<code>Looper</code>,而与<code>Looper</code>相关联的类还有<code>ThreadLocal</code>和<code>MessageQueue</code>,下面来一一介绍下它们的作用:</p>
<h5 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h5><p>消息的载体，内部主要存放一些消息类型，参数主要有：<br>（1）public int what：变量，用于定义此Message属于何种操作<br>（2）public Object obj：变量，用于定义此Message传递的信息数据，通过它传递信息<br>（3）public int arg1：变量，传递一些整型数据时使用<br>（4）public int arg2：变量，传递一些整型数据时使用<br>（5）public Handler getTarget()：普通方法，取得操作此消息的Handler对象。<br>在该类的使用上，尽量使用<code>obtain()</code>方法来获取，而非构造方法，这样可以节省内存。而在数据传递方面，如果是<code>int</code>类型的，建议使用<code>arg1</code>和<code>arg2</code>,其次再考虑使用<code>Bundle</code></p>
<h5 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h5><p>消息通道，消息机制的主要逻辑实现类，内部有使用<code>ThreadLocal</code>用来保存当前线程的<code>Looper</code>,使用<code>MessageQueue</code>用来维护<code>Message</code>池，而我们使用<code>Looper.prepare()</code>方法其实也就是将此线程的<code>Looper</code>对象加入到<code>ThreadLocal</code>中去：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void prepare() &#123;</span><br><span class="line">    prepare(true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void prepare(boolean quitAllowed) &#123;</span><br><span class="line">    if (sThreadLocal.get() != null) &#123;</span><br><span class="line">     //一个线程只能创建一个Looper</span><br><span class="line">        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(new Looper(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看源码就知道，当前线程中有且只有一个Looper，当我们再次创建，就会抛出异常，所以上面抛异常的原因就是在这里。</p>
<p>而我们的<code>loop()</code>方法就是消息机制的核心，原理是实现了一个无限循环，用于从<code>MessageQueue</code>中取出消息分发到各个<code>Handler</code>中去，以下是精简源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public static void loop() &#123;</span><br><span class="line">        //从ThreadLocal中取出Looper</span><br><span class="line">        final Looper me = myLooper();</span><br><span class="line">        if (me == null) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">       //从Looper中获取到MessageQueue </span><br><span class="line">        final MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">        ........</span><br><span class="line">        //创建循环</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            //从MessageQueue中一个一个的取出Message</span><br><span class="line">            Message msg = queue.next(); // might block</span><br><span class="line">            if (msg == null) &#123;</span><br><span class="line">               //没消息取了就退出</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">           ...........</span><br><span class="line">            final long start = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();</span><br><span class="line">            final long end;</span><br><span class="line">            try &#123;</span><br><span class="line">               //dispatchMessage方法的调用在这</span><br><span class="line">                msg.target.dispatchMessage(msg);</span><br><span class="line">                end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                if (traceTag != 0) &#123;</span><br><span class="line">                    Trace.traceEnd(traceTag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            .........</span><br><span class="line">           //回收消息，同时将Message置为空消息对象，存储在消息池中，用于obtain()方法再次获取</span><br><span class="line">            msg.recycleUnchecked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>综合要点就是使用<code>loop()</code>来开启消息分发，并且使用<code>prepare</code>来创建Looper。<strong>并且一个线程只能有一个Looper</strong>。</p>
<p>可以看到，<code>dispatchMessage</code>就是在这里回调的，那这个target是什么东西呢，其实就是我们的Handler对象。那这个Handler对象是在哪里赋值的呢，请看Handler源码</p>
<h5 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h5><p>首先看我们的构造方法最终会调用到这里：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public Handler(Callback callback, boolean async) &#123;</span><br><span class="line">        if (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">            final Class&lt;? extends Handler&gt; klass = getClass();</span><br><span class="line">            if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                    (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123;</span><br><span class="line">                Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; +</span><br><span class="line">                    klass.getCanonicalName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         //这里就将Looper创建好了，主要这里是在主线程中</span><br><span class="line">        mLooper = Looper.myLooper();</span><br><span class="line">        if (mLooper == null) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        mQueue = mLooper.mQueue;</span><br><span class="line">        mCallback = callback;</span><br><span class="line">        mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里主要起到从ThreadLocal中获取Looper对象的作用。看<code>Looper.myLooper()</code>方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Return the Looper object associated with the current thread.  Returns</span><br><span class="line"> * null if the calling thread is not associated with a Looper.</span><br><span class="line"> */</span><br><span class="line">public static @Nullable Looper myLooper() &#123;</span><br><span class="line">    return sThreadLocal.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>随后我们会调用<code>sendMessage()</code>类型的方法来发送消息，最终都会调用这个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123;</span><br><span class="line">    msg.target = this; //这里将Handler赋值了</span><br><span class="line">    if (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(true);</span><br><span class="line">    &#125;</span><br><span class="line">    return queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意看这里<code>msg.target = this</code>，这里实现了将当前Handler赋值到了Message中。随后调用了<code>enqueueMessage</code>方法就将此Message投入到了消息池<code>MessageQueue</code>中.到这里，一系列的初始化与调用都完成了。</p>
<p>所以，经过以上分析，我们之前的问题就迎刃而解了，但是还是有一个问题，我们在第一个实例中并没有使用<code>Looper</code>的<code>prepare</code>和<code>loop</code>方法，那我们的消息机制为什么会生效呢，其实在我们的app创建的时候系统已经默认为我们开启了，并且是在主程序的最后调用的，并没有在<code>onCreate()</code>方法中,而其他的生命周期方法，是通过AMS进行回调。这就保证了我们的循环不会造成主线程卡顿，具体的源码调用是在<code>ActivityThread</code>类中的<code>main</code>函数中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    SamplingProfilerIntegration.start();</span><br><span class="line"></span><br><span class="line">    // CloseGuard defaults to true and can be quite spammy.  We</span><br><span class="line">    // disable it here, but selectively enable it later (via</span><br><span class="line">    // StrictMode) on debug builds, but using DropBox, not logs.</span><br><span class="line">    CloseGuard.setEnabled(false);</span><br><span class="line"></span><br><span class="line">    Environment.initForCurrentUser();</span><br><span class="line"></span><br><span class="line">    // Set the reporter for event logging in libcore</span><br><span class="line">    EventLogger.setReporter(new EventLoggingReporter());</span><br><span class="line"></span><br><span class="line">    Security.addProvider(new AndroidKeyStoreProvider());</span><br><span class="line"></span><br><span class="line">    // Make sure TrustedCertificateStore looks in the right place for CA certificates</span><br><span class="line">    final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());</span><br><span class="line">    TrustedCertificateStore.setDefaultUserDirectory(configDir);</span><br><span class="line"></span><br><span class="line">    Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;);</span><br><span class="line"></span><br><span class="line">    Looper.prepareMainLooper();  // //为当前线程（主线程）创建一个Looper对象</span><br><span class="line"></span><br><span class="line">    ActivityThread thread = new ActivityThread();</span><br><span class="line">    thread.attach(false);</span><br><span class="line"></span><br><span class="line">    if (sMainThreadHandler == null) &#123;</span><br><span class="line">        sMainThreadHandler = thread.getHandler();  //为当前线程设置Handler</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AsyncTask.init();</span><br><span class="line"></span><br><span class="line">    if (false) &#123;</span><br><span class="line">        Looper.myLooper().setMessageLogging(new</span><br><span class="line">                LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Looper.loop();  // 执行从消息队列中获取Message，并调用Handler进行处理的无限循环；所有和主线程相关的消息处理都在该方法中执行</span><br><span class="line"></span><br><span class="line">    throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>分析到这，Handler流程其实也差不多了，最后做下总结:</p>
<p>1.在主线程中初始化了一个Handler,此时Looper.loop()已经开启，通过Handler构造方法创建了一个在主线程中的Looper，并保存到了ThreadLocal中，<strong>此时主线程不允许再创建第二个Looper</strong>.</p>
<p>2.在子线程中使用<code>sendMessage</code>方法，此时会调用enqueueMessage()方法并创建一个Message(或从池中取出空Message对象),然后我们将需要发送的消息保存在Message中，<strong>并将此Handler保存到Message的target对象中</strong>，然后压入到MessageQueue消息池中</p>
<p>3.Looper中会循环从MessageQueue中取出Message对象，并回调到target对象上的Handler的dispatchMessage()方法中去，由于Looper.loop()方法是在主线程中调用，所以dispatchMessage()方法也是运行在主线程中。<strong>Looper.loop()方法运行所在的线程决定dispatchMessage()方法回调的线程，并且需要与Looper.prepare()方法配套使用</strong></p>
]]></content>
      
        <categories>
            
            <category> 多线程编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android/java 多线程(一)-Thread的使用以及源码分析]]></title>
      <url>/Threadsourse.html</url>
      <content type="html"><![CDATA[<p><strong>版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起.</strong></p>
<hr>
<blockquote>
<p>七牛云过期了，图片也存不了了，以后决定在简书上发布文章，此地只做保存记录<br><a href="https://www.jianshu.com/u/2334b8b9f764" target="_blank" rel="noopener">我的简书地址</a>,欢迎来逛逛哟~</p>
</blockquote>
<a id="more"></a>
<h4 id="线程的概念以及状态"><a href="#线程的概念以及状态" class="headerlink" title="线程的概念以及状态"></a>线程的概念以及状态</h4><p>在学习线程之前，我们需要普及一个概念，每一个程序运行都会有一个父进程，我们的线程就是在此父进程中运行，拿Android来说，默认情况下，启动一个程序，所有的组件程序都运行在同一个进程中，并且会创建一个执行线程在该进程中，俗称”主线程”,当我们在该线程中做了耗时的操作造成了程序卡顿，我们就叫“线程阻塞”了,此时就应该另起一个线程来执行耗时操作。</p>
<p>要了解线程中方法的使用，就得先了解线程的运行状态，线程从创建到执行完毕，一共有6个状态：</p>
<ul>
<li>NEW(线程创建未启动)</li>
<li>RUNNABLE(正在执行中的线程)</li>
<li>BLOCKED(被阻塞并且在等待监视器锁释放)</li>
<li>WAITING(等待被唤醒)</li>
<li>TIMED_WAITING(等待或睡眠一定时间被唤醒)</li>
<li>TERMINATED（线程终止，消亡）</li>
</ul>
<p>这些状态对应<code>Thread</code>源码中的<code>State</code>枚举，通过<code>getState()</code>方法可以获取该线程的运行状态</p>
<p>其中<code>BLOCKED</code>表示等待监视器锁的过程，那么什么是监视器锁呢，监视器锁是为了解决线程不安全而诞生的方法，当多个进程同时操作一个数据结构并修改时，这时数据结构是不确定的，我们称之为“线程不安全”,于是我们使用<code>synchronized(同步锁)</code>和<code>lock锁</code>等机制来解决这种线程不安全，套上此锁，当前有且只有一个线程能修改此数据结构，其他的线程则需要等待，这就保证了数据结构的一致性，而其他线程会进入等待的状态，也就是我们的<code>BLOCKED</code>状态。<br><code>synchronized</code>使用示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class MyThread extends Thread &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            //这里写修改数据源的代码</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>lock</code>使用示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class MyThread extends Thread &#123;</span><br><span class="line">    private final ReentrantLock lock = new ReentrantLock ();</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">            //这里写修改数据源的代码</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然这两者的应用不仅仅是在线程中，在必要的方法调用上也可使用</p>
<h4 id="线程的源码以及方法使用"><a href="#线程的源码以及方法使用" class="headerlink" title="线程的源码以及方法使用"></a>线程的源码以及方法使用</h4><p><code>Thread</code>源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class Thread implements Runnable &#123;</span><br><span class="line"> ...........</span><br><span class="line">    /* Some of these are accessed directly by the VM; do not rename them. */</span><br><span class="line">    private volatile long nativePeer;</span><br><span class="line">    volatile ThreadGroup group;</span><br><span class="line">    volatile boolean daemon;</span><br><span class="line">    volatile String name;</span><br><span class="line">    volatile int priority;</span><br><span class="line">    volatile long stackSize;</span><br><span class="line">    Runnable target;</span><br><span class="line">    private static int count = 0;</span><br><span class="line">    private long threadInitNumber ;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Normal thread local values.</span><br><span class="line">     */</span><br><span class="line">    ThreadLocal.Values localValues;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Inheritable thread local values.</span><br><span class="line">     */</span><br><span class="line">    ThreadLocal.Values inheritableValues;</span><br><span class="line"></span><br><span class="line">    /** Callbacks to run on interruption. */</span><br><span class="line">    private final List&lt;Runnable&gt; interruptActions = new ArrayList&lt;Runnable&gt;();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Holds the class loader for this Thread, in case there is one.</span><br><span class="line">     */</span><br><span class="line">    private ClassLoader contextClassLoader;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Holds the handler for uncaught exceptions in this Thread,</span><br><span class="line">     * in case there is one.</span><br><span class="line">     */</span><br><span class="line">    private UncaughtExceptionHandler uncaughtHandler;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Holds the default handler for uncaught exceptions, in case there is one.</span><br><span class="line">     */</span><br><span class="line">    private static UncaughtExceptionHandler defaultUncaughtHandler;</span><br><span class="line"></span><br><span class="line">   .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Thread实现了Runnable接口，并声明了一些线程常用的一些变量:</p>
<ul>
<li><p>group<br>线程组，线程组包含其他的线程组，形成了一个树结构，除了初始的线程组外，其他的线程组都会有个父进程，其中线程能访问当前线程组的信息，但不能访问父线程组的信息</p>
</li>
<li><p>daemon<br>是否是守护线程，啥是守护线程呢，守护线程是依赖于创建它的线程的一种线程，与普通线程的区别是当创建它的线程关闭了那它也会关闭，而普通线程不会，像我们的垃圾收集器线程就是一个守护线程</p>
</li>
<li>threadInitNumber 当前线程的标识符，它是按照线程的创建顺序来叠加的</li>
<li>name 线程的名称，未指定的话就以<code>&quot;Thread-&quot; + threadInitNumber</code>的逻辑命名</li>
<li>priority<br>线程优先级，有三个状态<code>MIN_PRIORITY</code>,<code>NORM_PRIORITY</code>,<code>MAX_PRIORITY</code>,分别对应低，中，高</li>
<li>stackSize 堆栈大小</li>
<li>target 当前的目标线程</li>
<li>contextClassLoader 类加载器，用于保存该线程的信息，断点续传等功能可以用到</li>
<li>uncaughtHandler<br>线程未捕获异常调用类，如果没有对其进行设置，将会默认使用<code>defaultUncaughtHandler</code>来处理异常，由于我们的主线程也是一个Thread,所以我们可以通过实现<code>UncaughtExceptionHandler</code>接口并调用<code>Thread.setDefaultUncaughtExceptionHandler（）</code>方法将我们自定义的异常捕获类设置给Thread,这样我们就可以捕获全局的异常</li>
</ul>
<p>了解了一些常用变量后，我们再来看一下其中的一些常用方法:</p>
<h5 id="start-方法"><a href="#start-方法" class="headerlink" title="start()方法"></a>start()方法</h5><p>用于启动一个线程，只有调用此方法，系统才会新开启一个线程并分配给其必要的资源。我们看一下Thread的构造方法，发现最终都是调用了<code>init</code>方法，里面也只是对基本变量进行初始化，并没有分配到任何的资源：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private void init(ThreadGroup g, Runnable target, String name, long stackSize) &#123;</span><br><span class="line">    Thread parent = currentThread();</span><br><span class="line">    if (g == null) &#123;</span><br><span class="line">        g = parent.getThreadGroup();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g.addUnstarted();</span><br><span class="line">    this.group = g;</span><br><span class="line"></span><br><span class="line">    this.target = target;</span><br><span class="line">    this.priority = parent.getPriority();</span><br><span class="line">    this.daemon = parent.isDaemon();</span><br><span class="line">    setName(name);</span><br><span class="line"></span><br><span class="line">    init2(parent);</span><br><span class="line"></span><br><span class="line">    /* Stash the specified stack size in case the VM cares */</span><br><span class="line">    this.stackSize = stackSize;</span><br><span class="line">    tid = nextThreadID();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以，新建一个线程不会消耗资源，只有当star后才会去分配必要的资源，此时线程状态由<code>NEW</code>变为了<code>RUNNABLE</code></p>
<h5 id="run-方法"><a href="#run-方法" class="headerlink" title="run()方法"></a>run()方法</h5><p>此方法用于处理线程中执行的逻辑，如果继承Thread类则必须重写该方法</p>
<h5 id="sleep-方法"><a href="#sleep-方法" class="headerlink" title="sleep()方法"></a>sleep()方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sleep(long millis)     //参数为毫秒</span><br><span class="line">sleep(long millis,int nanoseconds)    //第一参数为毫秒，第二个参数为纳秒</span><br></pre></td></tr></table></figure>
<p>让线程休眠一段时间，相当于让线程进入阻塞状态。注意即使线程休眠了其锁机制依旧生效，其他的线程依旧不能访问其被锁的数据结构，直到其释放对象锁，此时线程状态由<code>RUNNABLE</code>进入<code>TIMED_WAITING</code></p>
<h5 id="yield-方法"><a href="#yield-方法" class="headerlink" title="yield()方法"></a>yield()方法</h5><p>让当前线程交出相应的权限，为其他线程让步，这是防止CPU过度使用的一种有效手段。效果与<code>sleep</code>差不多，但不能指定具体的时间，并且并不是让线程进入到阻塞状态，而是进入就绪状态.此时线程状态由<code>RUNNABLE</code>进入<code>WAITING</code></p>
<h5 id="join-方法"><a href="#join-方法" class="headerlink" title="join()方法"></a>join()方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">join()</span><br><span class="line">join(long millis)     //参数为毫秒</span><br><span class="line">join(long millis,int nanoseconds)    //第一参数为毫秒，第二个参数为纳秒</span><br></pre></td></tr></table></figure>
<p>此方法是让线程优先来执行，其余的线程会暂停，直到此线程执行完毕才会继续执行。你可以将线程看成一些正常行驶的车辆(在线程队列中)，当给其中一辆车使用了join(弯道超车),那其余的车会给其让行（线程进入暂停状态），优先让它行驶(join的线程运行)，直到它到达终点(运行完成)，才会继续行驶（继续执行）<br>而<code>join</code>源码中是调用的<code>wait()</code>方法，而<code>wait()</code>方法能使线程进入阻塞状态并释放对象锁，所以<code>join</code>方法也是能释放对象锁的</p>
<h5 id="interrupt（）方法"><a href="#interrupt（）方法" class="headerlink" title="interrupt（）方法"></a>interrupt（）方法</h5><p>中断线程，我们知道，线程执行完run方法里的逻辑就会进入终止状态。调用此方法会使一个阻塞的线程抛出<code>InterruptedException</code>异常，从而终止线程，可以调用<code>isInterrupted()</code>判断是否终止了线程，但非阻塞线程如何中断呢，请看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class MyThread extends Thread&#123;</span><br><span class="line">        private volatile boolean isStop = false;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            int i = 0;</span><br><span class="line">            while(!isStop)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        public void setStop(boolean stop)&#123;</span><br><span class="line">            this.isStop = stop;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以设置一个变量来控制是否执行完毕，从而结束线程，此时线程状态进入<code>TERMINATED</code>状态</p>
]]></content>
      
        <categories>
            
            <category> 多线程编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[安卓小白之ndk编译打包成so供第三方调用]]></title>
      <url>/ndkbuildproject.html</url>
      <content type="html"><![CDATA[<p><strong>版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起.</strong></p>
<hr>
<blockquote>
<p>本文接着上篇文章内容来,主要讲述如何生成so库以及将类编译成jar包供第三方调用<br><a href="http://www.huangjie.name/androidndkstudyfirst.html">安卓小白之ndk入门篇</a><br><a id="more"></a></p>
</blockquote>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>在build.gradle中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">externalNativeBuild &#123;</span><br><span class="line">    cmake &#123;</span><br><span class="line">        cppFlags &quot;&quot;</span><br><span class="line">         //在这里指定需要生成什么类型的so</span><br><span class="line">        abiFilters &quot;armeabi&quot;,&quot;armeabi-v7a&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在CMakeList文件中可以指定生成的so库的名称<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">add_library( # Sets the name of the library.</span><br><span class="line">        native-lib  #修改此处</span><br><span class="line"></span><br><span class="line">        # Sets the library as a shared library.</span><br><span class="line">        SHARED</span><br><span class="line"></span><br><span class="line">        # Provides a relative path to your source file(s).</span><br><span class="line">        src/main/cpp/native-lib.cpp)</span><br><span class="line"></span><br><span class="line">.....</span><br><span class="line">target_link_libraries( # Specifies the target library.</span><br><span class="line">        native-lib #修改此处</span><br><span class="line"></span><br><span class="line">        # Links the target library to the log library</span><br><span class="line">        # included in the NDK.</span><br><span class="line">        $&#123;log-lib&#125;)</span><br></pre></td></tr></table></figure></p>
<p>注意<code>add_library</code>的名称和<code>target_link_libraries</code>的名称必须相同<br>还有另外一种配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">defaultConfig&#123;</span><br><span class="line">   ndk&#123;</span><br><span class="line">       //指定生成的so库名称</span><br><span class="line">       moduleName &quot;native&quot;</span><br><span class="line">      //在这里指定需要生成什么类型的so</span><br><span class="line">       abiFilters &quot;armeabi&quot;,&quot;armeabi-v7a&quot;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以直接在gradle中都配置好，不需要更改CMakeList</p>
<p>配置好后，点击<code>Build</code>-&gt;<code>Make Project</code>等待编译完成,如果你是通过第一种方法配置的，那么生成的so库位于<code>app</code>-&gt;<code>build</code>-&gt;<code>intermediates</code>-&gt;<code>cmake</code>-&gt;<code>debug</code>-&gt;<code>obj</code>目录下，如果是第二种方法，那么so库位于<code>app</code>-&gt;<code>build</code>-&gt;<code>intermediates</code>-&gt;<code>ndk</code>-&gt;<code>debug</code>-&gt;<code>obj</code>目录下。</p>
<h4 id="生成jar包"><a href="#生成jar包" class="headerlink" title="生成jar包"></a>生成jar包</h4><p>看cpp文件里的方法就知道，方法声明都是与包名绑定的，那我要是给第三方app调用呢，总不能让它们用我们的包名吧，所以，我们就需要将我们的类都打成jar包供第三方间接调用，让第三方调用我们的类，我们的类来调用c代码，这样问题就解决啦。</p>
<p>1.要编译jar包，前提条件是你的这个项目必须是一个类库，也就是library,在app gradle<br>的最上面查看是否为<code>apply plugin: &#39;com.android.library&#39;</code></p>
<p>2.在build defaultConfig目录里加入以下代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">task makeJar(type: Copy) &#123;</span><br><span class="line">        //删除存在的</span><br><span class="line">        delete &apos;build/libs/jar.jar&apos;</span><br><span class="line">        //设置拷贝的文件</span><br><span class="line">        from(&apos;build/intermediates/bundles/debug/&apos;)</span><br><span class="line">        //打进jar包后的文件目录</span><br><span class="line">        into(&apos;build/libs/&apos;)</span><br><span class="line">        //将classes.jar放入build/libs/目录下</span><br><span class="line">        //include ,exclude参数来设置过滤</span><br><span class="line">        //（我们只关心classes.jar这个文件）</span><br><span class="line">        include(&apos;classes.jar&apos;)</span><br><span class="line">        //重命名</span><br><span class="line">        rename (&apos;classes.jar&apos;, &apos;jar.jar&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    makeJar.dependsOn(build)</span><br></pre></td></tr></table></figure></p>
<p>看注释，名字任意取，然后再Terminal中执行命令<code>gradlew makeJar</code>, Terminal在AndroidStudio的左下角。<br>执行完，提示BUILD SUCCESSFUL后，在以下路径可以找到生成的jar包：<br><code>app/build/intermediates/bundles/debug/</code></p>
<h4 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h4><p>jar包和so库都生成好后，就可以使用了，将jar包放入app-&gt;libs目录，将so库放入app-&gt;src-&gt;main-&gt;jinLibs<br><img src="https://upload-images.jianshu.io/upload_images/3468978-e6d758fb1916b250.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="s"><br>根据你的需要在jinLibs中建立不同的cpu架构目录，一般创建一个armeabi和armeabi-v7a就可以了，注意不要写错，同时注意在gradle中申明你需要的架构类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ndk&#123;</span><br><span class="line">      //在这里指定需要生成什么类型的so</span><br><span class="line">       abiFilters &quot;armeabi&quot;,&quot;armeabi-v7a&quot;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>都配置好后，重新Sync Project下项目，就能愉快的使用了。</p>
<p>在使用中，有同学经常会遇到so库文件找不到的问题，这时你就需要检查你的架构目录下的so的数量是不是相同的，千万不要出现单个目录没有的情况。这是因为so库都是向下兼容，假如一台v7架构的手机，你把两个需要使用的so库都放到armeabi目录中，没问题，因为系统在v7中找不到会去armeabi目录找。但是如果你将一个so放到armeabi和armeabi-v7a，另一个只放了到了armeabi，当一个v7架构的手机使用的时候，如果发现armeabi-v7中没有是不会去armeabi中找的，因为另一个so也放到了armeabi-v7目录下，代表你兼容了armeabi-v7的情况，此时是不会向下兼容的。所以，解决方案就是要么删除v7里的so,要么把缺少的so补齐。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[安卓小白之ndk入门篇]]></title>
      <url>/androidndkstudyfirst.html</url>
      <content type="html"><![CDATA[<p><strong>版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起.</strong></p>
<hr>
<blockquote>
<p>本文是本人总结ndk的一个入门篇，希望对学习ndk的同学有所帮助哦<br><a id="more"></a></p>
</blockquote>
<h4 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1.环境搭建"></a>1.环境搭建</h4><p>开发工具：AndroidStudio<br>打开AndroidStudio，进入<code>settings</code>,找到<code>Android SDK</code>目录，点击<code>SDK tools</code>，分别找到如图三个配置，勾上，下载。<br><img src="https://upload-images.jianshu.io/upload_images/3468978-d330db63b148bb2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="环境搭建"><br>分别介绍一下：</p>
<ul>
<li>cmake<br>类似于Android studio中的gradle,是对ndk的一个配置管理</li>
<li>LLDB<br>c/c++的一个调试工具，安装后可以对c/c++代码进行debug</li>
<li>NDK<br>ndk的开发工具包</li>
</ul>
<p>安装完成后，新建一个工程，注意勾选下方的<code>include c++ support</code>,一路<code>next</code>，直到项目构建完成，这样，我们的整体的ndk项目开发环境就配置好了。</p>
<h4 id="2-配置文件介绍"><a href="#2-配置文件介绍" class="headerlink" title="2.配置文件介绍"></a>2.配置文件介绍</h4><p>项目构建完毕后，我们会发现多了配置和文件，如图：<br><img src="https://upload-images.jianshu.io/upload_images/3468978-b0d32f23e2b25a5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="配置"></p>
<p>先介绍一下这几个参数的作用：<br>点开<code>CMakeLists.txt</code>，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"># For more information about using CMake with Android Studio, read the</span><br><span class="line"># documentation: https://d.android.com/studio/projects/add-native-code.html</span><br><span class="line"></span><br><span class="line"># Sets the minimum version of CMake required to build the native library.</span><br><span class="line"></span><br><span class="line">cmake_minimum_required(VERSION 3.4.1)</span><br><span class="line"></span><br><span class="line"># Creates and names a library, sets it as either STATIC</span><br><span class="line"># or SHARED, and provides the relative paths to its source code.</span><br><span class="line"># You can define multiple libraries, and CMake builds them for you.</span><br><span class="line"># Gradle automatically packages shared libraries with your APK.</span><br><span class="line"></span><br><span class="line"># 配置so库信息</span><br><span class="line">add_library( # Sets the name of the library.</span><br><span class="line">            # 生成的so库名称，此处生成的so文件名称是libnative-lib.so</span><br><span class="line">             native-lib</span><br><span class="line"></span><br><span class="line">             # Sets the library as a shared library.</span><br><span class="line">             # STATIC：静态库，是目标文件的归档文件，在链接其它目标的时候使用</span><br><span class="line">             # SHARED：动态库，会被动态链接，在运行时被加载</span><br><span class="line">             # MODULE：模块库，是不会被链接到其它目标中的插件，但是可能会在运行时使用dlopen-系列的函数动态链接</span><br><span class="line">             SHARED</span><br><span class="line"></span><br><span class="line">             # Provides a relative path to your source file(s).</span><br><span class="line">             # 资源文件，可以多个，</span><br><span class="line">             # 资源路径是相对路径，相对于本CMakeLists.txt所在目录</span><br><span class="line">             src/main/cpp/native-lib.cpp )</span><br><span class="line"></span><br><span class="line"># Searches for a specified prebuilt library and stores the path as a</span><br><span class="line"># variable. Because CMake includes system libraries in the search path by</span><br><span class="line"># default, you only need to specify the name of the public NDK library</span><br><span class="line"># you want to add. CMake verifies that the library exists before</span><br><span class="line"># completing its build.</span><br><span class="line"></span><br><span class="line"># 从系统查找依赖库</span><br><span class="line">find_library( # Sets the name of the path variable.</span><br><span class="line">              # android系统每个类型的库会存放一个特定的位置，而log库存放在log-lib中</span><br><span class="line">              log-lib</span><br><span class="line"></span><br><span class="line">              # Specifies the name of the NDK library that</span><br><span class="line">              # you want CMake to locate.</span><br><span class="line">              # android系统在c环境下打log到logcat的库</span><br><span class="line">              log )</span><br><span class="line"></span><br><span class="line"># Specifies libraries CMake should link to your target library. You</span><br><span class="line"># can link multiple libraries, such as libraries you define in this</span><br><span class="line"># build script, prebuilt third-party libraries, or system libraries.</span><br><span class="line"></span><br><span class="line"># 配置库的链接（依赖关系）</span><br><span class="line">target_link_libraries( # Specifies the target library.</span><br><span class="line"></span><br><span class="line">                       # 目标库</span><br><span class="line">                       native-lib</span><br><span class="line"></span><br><span class="line">                       # Links the target library to the log library</span><br><span class="line">                       # included in the NDK.</span><br><span class="line">                       # 依赖于</span><br><span class="line">                       $&#123;log-lib&#125; )</span><br></pre></td></tr></table></figure></p>
<p>看注释就能明白每个方法参数代表什么意思了，如果你觉得里面注释太多，看起来不是很顺眼，可以下载<code>CMake simple highligher</code>插件来提高代码亮度<br><img src="https://upload-images.jianshu.io/upload_images/3468978-3a20de031b648789.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="cmakehigh.png"><br><img src="https://upload-images.jianshu.io/upload_images/3468978-b01cf2af3cc17232.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果图"><br>关于cmake的配置还有许多，这里只是先简单介绍一个。<br>我们再来看一下build.gradle中的配置方法的作用,在<code>defultConfig</code>中有个这个参数，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">externalNativeBuild &#123;</span><br><span class="line">           cmake &#123;</span><br><span class="line">               cppFlags &quot;&quot;</span><br><span class="line">                abiFilters &apos;armeabi&apos;,&apos;arm64-v8a&apos;, &apos;armeabi-v7a&apos;, &apos;x86&apos;, &apos;x86_64&apos;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p>
<p>我们主要关注 <code>abiFilters</code>，它是用来设置编译生成什么类型的so的，我们的cup架构主要有以下几种:</p>
<ul>
<li>armeabi</li>
<li>armeabi-v7a</li>
<li>arm64-v8a</li>
<li>x86</li>
<li>x86_64</li>
<li>mips</li>
<li>mips_64<br>其中，<code>armeabi-v7a</code>是目前大部分手机的主流架构，它是基于<code>armeabi</code>的一种升级架构，因此，它们是互相兼容的，但目前各手机厂商的旗舰级，都已经开始采用<code>arm64-v8a</code>的cpu,不过不要慌，它也是兼容<code>armeabi</code>的，所以，如果我们只需要开发普通应用的话，我们只需要关注<code>armeabi</code>和<code>armeabi-v7a</code>就可以了，而像<code>x86</code>等这种类型的架构多用于平板等设备，因此我们只需要了解即可。<br>与此相同的还有一个配置：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ndk&#123;</span><br><span class="line">            abiFilters &quot;armeabi&quot;,&quot;armeabi-v7a&quot;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>它也是用来配置需要什么类型的so的，但它是负责打包到apk里有什么类型的so,而不是编译出什么so,两者还是有区别的。例如我在<code>cmake</code>里设置一个 “armeabi”,”armeabi-v7a”，在<code>ndk</code>里设置一个armeabi，我<code>make project</code>一下，它会生成两个cpu类型的so,但是我运行打包apk，在apk的lib目录里就只有一个armeabi的so了，所以：<br>当我们不需要编译so库时，例如引用的第三方库，可以使用<code>ndk</code>来过滤，完全不需要<code>cmake</code><br>接下来说一下<code>android</code>下的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">externalNativeBuild &#123;</span><br><span class="line">        cmake &#123;</span><br><span class="line">            path &quot;CMakeLists.txt&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>其实很显然，它就是指定我们的<code>CMakeLists</code>文件路径的，当然我们的这个路径是可以更改的。<br>这里教大家一个小技巧，在cmd中执行：<code>adb shell</code> <code>cat  /proc/cpuinfo</code>可以查看当前手机的cpu架构哦，效果图如下：<br><img src="https://upload-images.jianshu.io/upload_images/3468978-13a9d77a060d8557.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="adb"><br><code>CPU architecture: 8</code>说明我的手机是<code>arm64-v8a</code>架构</p>
<p>接下来我们来看cpp文件，这个文件是干嘛的呢，它是c里.h文件的实现的源文件，你可以把它看作是与java交互的桥梁，里面包含了java层需要调用到的函数方法，点开可以看到以下函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;jni.h&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; JNIEXPORT jstring JNICALL</span><br><span class="line">Java_com_jie_ndkdemo_MainActivity_stringFromJNI(</span><br><span class="line">        JNIEnv *env,</span><br><span class="line">        jobject /* this */) &#123;</span><br><span class="line">    std::string hello = &quot;Hello from C++&quot;;</span><br><span class="line">    return env-&gt;NewStringUTF(hello.c_str());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主要是看这个函数：<br><code>Java_com_jie_ndkdemo_MainActivity_stringFromJNI</code>,它是有格式要求的，由Java<em>包名</em>类名_函数名组成，定义的时候一定要按照这个格式来，其中，<code>MainActivity</code>是我声明native方法的类的类名。</p>
]]></content>
      
        <categories>
            
            <category> ndk </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Kotlin高阶函数使用(二)]]></title>
      <url>/kotlin-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8.html</url>
      <content type="html"><![CDATA[<p><strong>版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起.</strong></p>
<hr>
<blockquote>
<p>上一篇文章带大家认识到了什么是高阶函数，那这一章就带大家看看高阶函数的实际使用场景吧</p>
</blockquote>
<a id="more"></a>
<h4 id="提问"><a href="#提问" class="headerlink" title="提问"></a>提问</h4><p>我们想一想，高阶函数带给我们的是什么，我们为什么要使用它呢？因为他可以让我们的方法更简单高效，能去掉冗余的样板代码，让我们关注的逻辑更清晰的展现在我们的面前，所以高阶函数一定是用在我们的方法实现上，而官方api其实已经将我们常用的快捷操作用高阶函数给封装好了，比如<code>with</code>,<code>apply</code>等操作符，所以剩下的就是接口调用了。</p>
<p>不知道大家用Kotlin实现过OnClickListener接口没有，有3种写法：</p>
<p>青铜版:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">view.setOnClickListener(object :View.OnClickListener&#123;</span><br><span class="line">           override fun onClick(v: View?) &#123;</span><br><span class="line">                 //啊！我被点击了</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;)</span><br></pre></td></tr></table></figure></p>
<p>黄金版<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">view.setOnClickListener &#123; v -&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                //啊！我被点击了  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>钻石版<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">view.setOnClickListener &#123;</span><br><span class="line">               //啊！我被点击了  </span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p>
<p>我们一对比发现，代码是一步一步被省略的，首先是省略了接口声明(转化为了lambda)，其次是省略了lambda的花括号(Kotlin的特性，当参数只有一个lambda参数的时候，括号可以省略),所以我们要实现的是如何将接口声明转化为lambda,哈哈，这不正是我们高阶函数所擅长的吗</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>虽然我们不能直接看到kotlin内部的高阶函数的实现方式，但是我们按住<code>ctrl</code>键将鼠标移到方法上是可以看到高阶函数的声明方式的，如你所见是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public final fun setOnClickListener( l: ((v: View!) → Unit)! ): Unit</span><br></pre></td></tr></table></figure></p>
<p>看过我上篇文章的一眼就能看明白，这是声明了一个以view为参数的无返回值的高阶函数，但他是如何实现的呢，请看以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public final fun setOnClickListener( l: ((v: View!) → Unit)! ): Unit&#123;</span><br><span class="line">    //将接口实现并赋值给全局变量接口方便接口方法调用</span><br><span class="line">    mOnClickListener = object :View.OnClickListener&#123;</span><br><span class="line">                  override fun onClick(v: View?) &#123;</span><br><span class="line">                           l.invoke(v) //关键是这句</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>原理就是内部将接口给实例化，然后将逻辑通过invoke方法代理出去，这样我们点击事件内部就会走invoke方法啦。而invoke实际是一个接口(翻译成java代码你就明白啦),所以我们在方法外面实现的其实是invoke的接口实现逻辑，注意，这种接口的实现方式只能在接口只有一个方法的时候哦，因为invoke只有一个，哈哈，怎么样，setOnClickListener的处理逻辑小伙伴们明白了吗，举一反三的事情就交给各位勤奋的小伙伴了.</p>
]]></content>
      
        <categories>
            
            <category> Kotlin </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Kotlin高阶函数使用(一)]]></title>
      <url>/Kotlin-Higher-order-function1.html</url>
      <content type="html"><![CDATA[<p><strong>版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起.</strong></p>
<hr>
<blockquote>
<p>用过Kotlin的同学都知道，那些扩展方法用起来简直不要太爽，那么这些扩展方法是怎么定义实现的呢，本文介绍了Kotlin高阶函数的使用,带你实现自己的超溜扩展方法，并且能让你能看懂扩展方法源码，阅读本文需要有一定的Kotlin基础，请谨慎阅读.</p>
</blockquote>
<a id="more"></a>
<h4 id="1-定义-什么是高阶函数"><a href="#1-定义-什么是高阶函数" class="headerlink" title="1.定义:什么是高阶函数"></a>1.定义:什么是高阶函数</h4><p>高阶函数就是以另一个函数作为参数或返回值的函数，Kotlin可以以lambda或参数引用作为参数或返回值，所以，任何以lambda或函数引用作为参数或返回值的都是高阶函数</p>
<h4 id="2-函数类型"><a href="#2-函数类型" class="headerlink" title="2.函数类型"></a>2.函数类型</h4><p>要使用Kotlin的高阶函数就必须遵循它的函数类型<br>先来看一个简单的例子，这是一个简单的函数类型申明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val sum = &#123; x: Int, y: Int -&gt; x + y &#125;</span><br></pre></td></tr></table></figure></p>
<p>之所以能这么写得益于Kotlin的类型推导，它的显示写法是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var sum:(Int,Int)-&gt; Int = &#123;x , y-&gt; x + y&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>(Int,Int)</code>是参数类型，<code>-&gt;</code>后面的值<code>Int</code>是返回类型,组合在一起就构成了一个函数类型,以上属于有参有返回值类型，下面列举其他几种类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var action:() -&gt;Unit = &#123;&#125; //无参无返回值</span><br><span class="line">var a = &#123;&#125; //类型推导后的简化写法</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var action:(Int) -&gt;Unit = &#123;&#125; //有参无返回值</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var action:() -&gt; Int = &#123;&#125; //无参有返回值</span><br></pre></td></tr></table></figure>
<h4 id="3-使用高阶函数-将函数类型作为参数"><a href="#3-使用高阶函数-将函数类型作为参数" class="headerlink" title="3.使用高阶函数(将函数类型作为参数)"></a>3.使用高阶函数(将函数类型作为参数)</h4><p>直接看代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> fun getNumResult(result: (Int, Int) -&gt; Int): Int &#123;</span><br><span class="line">        return result(1,2)                                                                                                                       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//调用</span><br><span class="line">var value = getNumResult&#123; a, b -&gt; a + b &#125;</span><br><span class="line">==&gt; value = 3</span><br><span class="line"></span><br><span class="line">var value = getNumResult&#123; a, b -&gt; a * b &#125;</span><br><span class="line">==&gt; value = 2</span><br></pre></td></tr></table></figure></p>
<p>依照函数类型所示，a和b对应两个Int类型的参数，这个名称可以任意定义，a+b为返回值，随后return 了一个lambda的返回值，看起来是不是很强大,而且依照Kotlin的特性，当参数只有一个lambda参数的时候，括号可以省略，因此就变成了实例中的那样简洁的调用</p>
<p>像Kotlin中的filter等操作符，都是这样定义实现的，感兴趣的可以研究下</p>
<p>看到这里，可能有同学会问了，Kotlin不是号称与JAVA兼容吗，那再Java中如何调用呢，这就要从Kotlin函数的生成原理说起了，Kotlin的这些函数类型其实会被申明成普通的接口，一个函数类型的参数就会变成Function1的实现，N个函数类型的参数就是FunctionN，这个接口定义了一个invoke方法，调用该方法就会执行函数，So,我们可以这么写:</p>
<p>Java8: 因为支持lambda，所以依旧可以这样写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int value = getNumResult(a ,b - &gt;a + b);</span><br></pre></td></tr></table></figure></p>
<p>Java8以下版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int value = getNumResult(</span><br><span class="line">    new Function2&lt;Integer, Integer, Integer&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Integer invoke(Integer a, Integer b) &#123;</span><br><span class="line">                return a + b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></p>
<p>注意，如果定义的返回值是Unit,例如forEach高阶函数，在Java中就必须显示返回一个Unit对象,因为Unit是一个单例对象，因此可以这样定义返回<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return Unit.INSTANCE；</span><br></pre></td></tr></table></figure></p>
<h4 id="4-使用高阶函数-将函数类型作为返回值"><a href="#4-使用高阶函数-将函数类型作为返回值" class="headerlink" title="4.使用高阶函数(将函数类型作为返回值)"></a>4.使用高阶函数(将函数类型作为返回值)</h4><p>顾名思义，相信同学们把作为参数的高阶函数理解透了这个很好理解，示例如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//定义一个类用于装载参数</span><br><span class="line">class Num(var num: Int)</span><br><span class="line"></span><br><span class="line">//此方法的作用是如果type等于1，那么就从Num类中取出num进行乘法操作，如果不等于一，就进行相加操作</span><br><span class="line">    fun getNum(type: Int): (Num) -&gt; Int &#123;</span><br><span class="line">        if (type == 1) &#123;</span><br><span class="line">          //这是一种写法</span><br><span class="line">            return &#123; entity -&gt;</span><br><span class="line">                entity.num * entity.num</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">         //这是另一种简写，可以用it代替entity参数</span><br><span class="line">            return &#123;</span><br><span class="line">                it.num + it.num</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">使用:</span><br><span class="line">var ride = getNum(1) //传递一个1进去代表使用乘法</span><br><span class="line">var result = ride(Num(3)) //得到一个以Num作为参数的高阶函数</span><br><span class="line">==&gt; result = 9</span><br><span class="line"></span><br><span class="line">var sum = getNum(2)</span><br><span class="line">var result = sum(Num(3))</span><br><span class="line">==&gt; result = 6</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Kotlin </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[gitlab加jitpack搭建免费私有依赖库]]></title>
      <url>/gitlabab-jitpack%E7%A7%81%E6%9C%89%E4%BE%9D%E8%B5%96%E5%BA%93%E6%90%AD%E5%BB%BA.html</url>
      <content type="html"><![CDATA[<p><strong>版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起.</strong></p>
<hr>
<blockquote>
<p>一直想为公司项目搭建一个依赖库，可以直接像引入第三方开源项目一样去引用它，方便集成到其他的项目中去，趁着这个周末将几大依赖库平台都研究了一番，顺便做一个总结<br><a id="more"></a></p>
</blockquote>
<h4 id="选择托管平台"><a href="#选择托管平台" class="headerlink" title="选择托管平台"></a>选择托管平台</h4><p> 搭建公司依赖库的前提是项目非公开，必须能托管私有项目，同时需要免费，对比现在比较火的只有两个：</p>
<ul>
<li><a href="https://gitlab.com" target="_blank" rel="noopener">gitlab</a></li>
</ul>
<pre><code>GitLab 是一个用于仓库管理系统的开源项目，使用Git作为代码管理工具，并在此基础上搭建起来的web服务。安装方法是参考GitLab在GitHub上的Wiki页面。
</code></pre><ul>
<li><a href="https://coding.net/" target="_blank" rel="noopener">Coding</a></li>
</ul>
<pre><code>有人说Coding就是中国的github,但从最近的产品演变方向看，coding更想做的是团队代码云端服务，通过它可以云端一键部署代码
</code></pre><p>两者相比较，虽然Coding是国内产品，上手程度上具有一定的优势，但是产品并没有gitlab发展的成熟，故笔者选择了gitlab来托管私有项目</p>
<h4 id="选择构建工具"><a href="#选择构建工具" class="headerlink" title="选择构建工具"></a>选择构建工具</h4><p>目前已知有以下平台供选择：</p>
<ul>
<li><p><a href="https://bintray.com/signup/oss" target="_blank" rel="noopener">Bintray</a><br>优点：响应快，结构清晰，当部署出错能迅速打印log，分析错误原因<br>缺点: 需要翻墙，配置稍显复杂</p>
<p>  配置可参考:<a href="https://www.jianshu.com/p/5a3d485fda1d" target="_blank" rel="noopener">发布 Android Library 到 JCenter 从入门到放弃</a></p>
</li>
<li><p><a href="https://jitpack.io" target="_blank" rel="noopener">jitpack</a><br>优点: 配置简单,支持度广泛<br>缺点: 管理平台较简单</p>
</li>
<li>使用<a href="https://www.sonatype.com/download-oss-sonatype" target="_blank" rel="noopener">Nexus Repository Manager OSS 3.x</a>来搭建私有maven服务<br>优点:较为开放，完全本地服务器运行<br>缺点：需要对gradle进行复杂的配置,需要本地服务器</li>
</ul>
<p>综合考虑，决定用jitpack来搭建</p>
<h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><ol>
<li>注册一个gitlab账号</li>
<li>注册一个jitpack账号</li>
<li>在gitlab中创建一个私有项目,并生成一个Access Tokens(Setting-&gt;Access Tokens),如果是管理者把权限全部勾上，Expires at不需要填，点击生成记下密钥(我比较懒就不放示例图了)</li>
<li>进入jitpack的设置界面（点击用户名可进入）,看到GitLab一栏，将此令牌输入</li>
<li>回到jitpack首页左边Repositories里应该就可以看到我们先前创建的私有项目了</li>
</ol>
<h4 id="上传library包"><a href="#上传library包" class="headerlink" title="上传library包"></a>上传library包</h4><ol>
<li><p>创建一个项目，添加一个library包</p>
</li>
<li><p>在此library的gradle里加入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: <span class="string">'com.github.dcendents.android-maven'</span></span><br><span class="line">group=<span class="string">'com.gitlab.UserName'</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>其中UserName是你的用户名</p>
<p> 3 在根目录的gradle中加入<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies&#123;</span><br><span class="line">    classpath <span class="string">'com.github.dcendents:android-maven-gradle-plugin:2.0'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意看你的gradle版本，如果是4.1+就使用2.0，如果是4.4+就使用2.1<br>配置完毕，使用git提交到gitlab,怎么提交不需要我说了吧，就是平常提交代码到github上一样</p>
<p> 4 版本控制<br>  提交成功后可以在gitlab中生成一个tag，tag的名称就是你在项目中引用的名称</p>
<p> 5 刷新jitpack, 项目结构如图:<br>  <img src="http://p2p0lrpx1.bkt.clouddn.com/jitpack1.png-gif" alt=""><br>  点击<code>Get it</code>即可获取你的配置地址了，复制它</p>
<h4 id="项目中使用"><a href="#项目中使用" class="headerlink" title="项目中使用"></a>项目中使用</h4><p>直接在项目的build.gradle中贴上这个地址，build………… 咦，怎么失败了，别急，这是因为权限问题造成的。由于我们在gitlab上创建的是私有项目，所以我们需要在项目中配置一下令牌:<br>打开项目的<code>gradle.properties</code>,加上<code>authToken=你的令牌地址</code>,随后在项目根目录加上<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">       ........</span><br><span class="line">        maven &#123; url <span class="string">'https://jitpack.io'</span></span><br><span class="line">            credentials &#123; username authToken &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>重新rebuild一下，编译成功，试试在项目中使用library中的代码，大功告成，怎么样，配置是不是超级简单</p>
]]></content>
      
        <categories>
            
            <category> 安卓杂记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> tools </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Kotlin系列学习资料整理]]></title>
      <url>/Kotlin%E7%B3%BB%E5%88%97-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95.html</url>
      <content type="html"><![CDATA[<p><strong>版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起.</strong></p>
<hr>
<blockquote>
<p>时至今日,Kotlin在Android开发中越来越受欢迎,它的高效性，简介性,以及更高的容错率不禁让我感叹:一入Kotlin深似海，从此Java是路人，<br>入了Kotlin的门，保证让你回不去,哈哈哈，还等什么,快来和我一起学习Kotlin把<br> <a id="more"></a></p>
</blockquote>
<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>网上Kotlin的资料很多，我也不重复造‘资料’了，跟着我的资料索引来，一步一步的学习，相信你很快就能熟练使用了</p>
<h5 id="官网教程"><a href="#官网教程" class="headerlink" title="官网教程"></a>官网教程</h5><p><a href="https://github.com/JetBrains/kotlin" target="_blank" rel="noopener">Kotlin开源地址</a></p>
<p><a href="http://www.kotlincn.net/docs/reference/" target="_blank" rel="noopener">Kotlin中文文档</a><br>此文档应仔细熟读三遍，确保每一章节都有一个大概的印象，方便以后翻阅，同时这也是最重要的资料,应保存到书签.<br>读语法是应该联想一下使用java会如何实现，思考一下Kotlin的好处，下次遇见此场景就会联想到需要使用这个Api来编写代码了.</p>
<p><a href="https://github.com/enbandari/Kotlin-Tutorials" target="_blank" rel="noopener">视频教程</a></p>
<h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><p>熟悉了文档后就可以去Kotlin官网去在线练习一下语法啦，用来巩固你的知识点。<br>地址:<a href="https://try.kotlinlang.org/#/Examples/Hello,%20world!/Simplest%20version/Simplest%20version.kt" target="_blank" rel="noopener">Hello,Kotlin</a><br>可以点击<code>Kotlin Koans</code>来做上面的练习题，让你实践各种Api的使用</p>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><p>当你使用Kotlin得心应手之后,就可以参考一下别人是怎么使用Kotlin来编写代码的，这里列举几个可参考的开源项目</p>
<p><a href="https://github.com/git-xuhao/KotlinMvp" target="_blank" rel="noopener">基于Kotlin+MVP+Retrofit+RxJava+Glide 等架构实现的短视频类的APP练手项目，UI 简约风格，代码详细注释</a></p>
<p><a href="https://github.com/antoniolg/Kotlin-for-Android-Developers" target="_blank" rel="noopener">Kotlin for Android Developers (the book)</a><br>国外某Kotlin书籍中的示例代码..</p>
<p><a href="https://github.com/LRH1993/Eyepetizer-in-Kotlin" target="_blank" rel="noopener">仿开眼视频</a></p>
<p><a href="https://github.com/githubwing/GankClient-Kotlin" target="_blank" rel="noopener">使用干货集中营Api实现的App</a></p>
<p><a href="https://github.com/Yalantis/kotlin-mvp-example" target="_blank" rel="noopener">Kotlin的MVP示例</a></p>
<h4 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h4><p>最后说下通过书籍的阅读可以让你的知识点更成体系,推荐<code>Kotlin实战</code>这本书，内容不错,推荐</p>
]]></content>
      
        <categories>
            
            <category> Kotlin </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[安卓高级布局-flexboxLayout：最聪明的布局]]></title>
      <url>/%E5%AE%89%E5%8D%93%E9%AB%98%E7%BA%A7%E5%B8%83%E5%B1%80-flexboxLayout-%E6%9C%80%E8%81%AA%E6%98%8E%E7%9A%84%E5%B8%83%E5%B1%80.html</url>
      <content type="html"><![CDATA[<p><strong>版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起.</strong></p>
<hr>
<blockquote>
<p>ps:最近由于连接外接硬盘的数据线落朋友家了，而我hexo文档都存在外接硬盘上了，导致许久都没写文章啦，还别说，手还有点痒，以后还是尽量保持每周一更</p>
</blockquote>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天给大家介绍的是谷歌开源的新的一种布局，如果用css写过flexbox布局的朋友一定不会陌生,没错，<code>FlexboxLayou</code>t可以说是<code>Android</code>版的<code>flexbox</code>布局，它的作用是可以让子布局轻松填充父布局，并且可以对子布局进行排序，设置可以让子布局自动‘换行’,它还能够指定子布局的排列方向,相当于一个加强版的<code>LinearLayout</code>，怎么样，你是不是迫不及待想试试了？</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><code>FlexboxLayout</code>开源地址：<a href="https://github.com/google/flexbox-layout" target="_blank" rel="noopener">https://github.com/google/flexbox-layout</a></p>
<p>在<code>build.gradle</code>中添加：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">'com.google.android:flexbox:0.3.2'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在xml中使用：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;com.google.android.flexbox.FlexboxLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">    android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">    &gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:layout_width=<span class="string">"100dp"</span></span><br><span class="line">        android:layout_height=<span class="string">"20dp"</span></span><br><span class="line">        android:background=<span class="string">"#43eeff"</span></span><br><span class="line">        android:gravity=<span class="string">"center"</span></span><br><span class="line">        android:text=<span class="string">"1"</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:layout_width=<span class="string">"100dp"</span></span><br><span class="line">        android:layout_height=<span class="string">"20dp"</span></span><br><span class="line">        android:background=<span class="string">"#ef3344"</span></span><br><span class="line">        android:gravity=<span class="string">"center"</span></span><br><span class="line">        android:text=<span class="string">"2"</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:layout_width=<span class="string">"100dp"</span></span><br><span class="line">        android:layout_height=<span class="string">"20dp"</span></span><br><span class="line">        android:background=<span class="string">"#ee998f"</span></span><br><span class="line">        android:gravity=<span class="string">"center"</span></span><br><span class="line">        android:text=<span class="string">"3"</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:layout_width=<span class="string">"100dp"</span></span><br><span class="line">        android:layout_height=<span class="string">"50dp"</span></span><br><span class="line">        android:background=<span class="string">"#eeff22"</span></span><br><span class="line">        android:gravity=<span class="string">"center"</span></span><br><span class="line">        android:text=<span class="string">"4"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/com.google.android.flexbox.FlexboxLayout&gt;</span><br></pre></td></tr></table></figure></p>
<p>我们什么属性都不加,可以看到效果是这样的：<br><img src="http://p07lh1fh6.bkt.clouddn.com/flexboxlayout_noshuxin.png-suofang" alt=""></p>
<p>咦，好像并没有换行，别急，这其实是<code>flexboxLayout</code>默认属性的一个效果，下面我们就来学习它的一些常用属性吧：</p>
<h4 id="flexDirection"><a href="#flexDirection" class="headerlink" title="flexDirection"></a>flexDirection</h4><p><code>flexDirection</code>属性决定子布局的排列方向。类似LinearLayout 的 <code>orientation</code>属性，不过,flexboxLayout的属性更加强大,它除了决定子布局的排列方向,还可以决定子布局的起点位置：</p>
<ul>
<li>row（默认值）：子布局为水平方向，起点在左端</li>
<li>row_reverse：子布局为水平方向，起点在右端。</li>
<li>column：子布局为垂直方向，起点在上沿</li>
<li>column_reverse：子布局为垂直方向，起点在下沿</li>
</ul>
<p>使用<code>column_reverse</code>效果如下所示：</p>
<p><img src="http://p07lh1fh6.bkt.clouddn.com/flexboxlayout_column_reverse.png-suofang" alt=""></p>
<h4 id="flexWrap"><a href="#flexWrap" class="headerlink" title="flexWrap"></a>flexWrap</h4><p><code>flexWrap</code>是一个非常有用的属性，它可以让控件自动换行,</p>
<ul>
<li>nowrap （默认）：不换行</li>
<li>wrap：按正方向换行</li>
<li>wrap_reverse：按反方向换行</li>
</ul>
<p>使用<code>wrap</code>属性效果如下所示：</p>
<p><img src="http://p07lh1fh6.bkt.clouddn.com/flexboxlayout_warp.png-suofang" alt=""></p>
<h4 id="justifyContent"><a href="#justifyContent" class="headerlink" title="justifyContent"></a>justifyContent</h4><p><code>justifyContent</code>定义了子控件的对齐方式，把它看成<code>gravity</code>属性，子控件为一个整体就好理解了，属性如下：</p>
<ul>
<li>flex_start(默认):左对齐</li>
<li>flex_end：右对齐</li>
<li>center：居中</li>
<li>space_between：两端对齐，每个子控件之间的距离相等</li>
<li>space_around：每个子控件的两侧相等,项目之间的间隔比项目与边框的间隔大一倍。</li>
</ul>
<p>如下是设置了<code>space_around</code>的效果：</p>
<p><img src="http://p07lh1fh6.bkt.clouddn.com/flexboxlayout_space_around.png-suofang" alt=""></p>
<h4 id="alignItems"><a href="#alignItems" class="headerlink" title="alignItems"></a>alignItems</h4><p><code>alignltems</code>用于设置子布局的对齐方式,属性如下：</p>
<ul>
<li>flex-start：顶端对齐。：第一行内容的的基线对齐。</li>
<li>flex_end：底部对齐。</li>
<li>stretch （默认）：如果item没有设置高度，则充满容器高度。</li>
<li>center：居中对齐</li>
<li>baseline：第一行内容的基线对齐。</li>
</ul>
<p>这也是为什么我们一开始什么也不设置子布局会填充父布局的原因。这里还说下baseline属性，用过TextView一定对基线不会陌生,如果子控件有文字，基线对齐可以保证文字对齐而不必理会包裹它的控件是怎样的。<br>观看下图可以有助于理解：<br><img src="https://user-gold-cdn.xitu.io/2017/3/21/f471cc42ef5f9fdd3222b45972694493" alt=""></p>
<h4 id="alignContent"><a href="#alignContent" class="headerlink" title="alignContent"></a>alignContent</h4><p><code>alignContent</code>可以控制多行的对齐方式，如果子布局只有一行则不起作用，属性如下：</p>
<ul>
<li>stretch （默认值）：充满交叉轴的高度（测试发现，需要alignItems 的值也为stretch 才有效）。</li>
<li>flex_start：与交叉轴的起点对齐。</li>
<li>flex_end：与交叉轴的终点对齐。</li>
<li>center：与交叉轴的中点对齐。</li>
<li>space_between：与交叉轴两端对齐，轴线之间的间隔平均分布。</li>
<li>space_around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li>
</ul>
<h3 id="子布局属性"><a href="#子布局属性" class="headerlink" title="子布局属性"></a>子布局属性</h3><p>子布局也有非常给力的属性,父与子布局的结合使得排版非常灵活</p>
<h4 id="layout-flexBasisPercent"><a href="#layout-flexBasisPercent" class="headerlink" title="layout_flexBasisPercent"></a>layout_flexBasisPercent</h4><p><code>ayout_flexBasisPercent</code>的值为一个百分比，表示设置子元素的长度为它父容器长度的百分比,默认值是auto,即元素本来的大小。<br>如图，我设置每个子布局的宽度一样，第一个子布局我设置50%的百分比，效果如图：</p>
<p><img src="http://p07lh1fh6.bkt.clouddn.com/flexboxlayout_presenter.png-suofang" alt=""></p>
<h4 id="layout-order"><a href="#layout-order" class="headerlink" title="layout_order"></a>layout_order</h4><p><code>layout_order</code>属性用于给子布局排序，默认是按照从上到下依次排列的，如果加入该值，值越小位置就会越靠前</p>
<h4 id="layout-flexGrow"><a href="#layout-flexGrow" class="headerlink" title="layout_flexGrow"></a>layout_flexGrow</h4><p><code>layout_flexGrow</code>用于定义子布局的放大比例，其实就是<code>LinearLayout</code>的<code>weight</code>属性，相信这个不用过多介绍吧</p>
<h4 id="layout-flexShrink"><a href="#layout-flexShrink" class="headerlink" title="layout_flexShrink"></a>layout_flexShrink</h4><p><code>layout_flexShrink</code>定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。如果所有项目的 layout_flexShrink 属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。</p>
<h4 id="layout-alignSelf"><a href="#layout-alignSelf" class="headerlink" title="layout_alignSelf"></a>layout_alignSelf</h4><p><code>layout_alignSelf</code>属性允许单个子元素有与其他子元素不一样的对齐方式，可覆盖 alignItems 属性。默认值为auto，表示继承父元素的alignItems 属性，如果没有父元素，则等同于stretch。属性作用同<code>alignItems</code>一样。</p>
<p>flexboxLayout大部分常用的属性就介绍到这里，此布局可以轻松完成类似添加tag便签的布局样式，也可以把它当成百分比布局来用，甚至可以与RecyclerView搭配完成图片流效果，因此熟练掌握这个布局还是有必要的，跟着文章的讲解多敲敲代码，相信你很快就会上手的。</p>
]]></content>
      
        <categories>
            
            <category> Android基础进阶 </category>
            
            <category> 安卓控件 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[记一次重构项目心得]]></title>
      <url>/refactoring-project-learned.html</url>
      <content type="html"><![CDATA[<p><strong>版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起.</strong></p>
<hr>
<blockquote>
<p>这次花时间重构了下一年前的自定义键盘项目,收获了许多，忍不住想写出来分享一下,项目地址<a href="https://github.com/Jay-huangjie/EasyKeyBoardView" target="_blank" rel="noopener">EasyKeyBoardView</a>,该库旨在帮助开发者更快的实现自定义键盘，无需关注键盘自身的实现逻辑，详细用法见<a href="https://github.com/Jay-huangjie/EasyKeyBoardView/blob/master/README.md" target="_blank" rel="noopener">README.md</a></p>
</blockquote>
<a id="more"></a>
<h3 id="如何重构项目"><a href="#如何重构项目" class="headerlink" title="如何重构项目"></a>如何重构项目</h3><p>对于一个开源项目来说，首先要弄清楚它的意义在哪里，它的目的在哪里，俗话说，程序员都是懒惰的，为了偷懒，程序员创造了越来越方便的工具来帮自己偷懒，这就是一种进步。</p>
<p>基于此，我分析了下自定义键盘的使用场景，发现键盘的使用逻辑是差不多的，无非是UI及一些功能点上的不同，但终究是一个键盘，输入功能是刚需，所以简化输入功能就是这个库的意义所在了。</p>
<p>而这次我发现，一款优质的开源项目必须要有高度的扩展性，应此将功能模块化是我此次学习到的重要技能，每一个类都有着它自己的功能，然后再将这些类组装起来就变成了一台灵活运作的机器。<br>而其中那些点可对外修改，那些不能，这都需要自己判断的。</p>
<h3 id="学习到的技能"><a href="#学习到的技能" class="headerlink" title="学习到的技能"></a>学习到的技能</h3><p>更快的配置：上传项目到<code>JitPack</code><br>相比于<code>jcenter</code>,我发现<code>JitPack</code>可谓是神器，1分钟就可实现代码上传，强烈推荐，使用方法如下：<br>首先进入它的github地址:<a href="https://github.com/jitpack/jitpack.io" target="_blank" rel="noopener">jitpack.io</a>,找到它的最新版插件版本，在要上传的项目的root build.gradle中添加插件，大概长这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">       classpath <span class="string">'com.android.tools.build:gradle:3.0.0'</span></span><br><span class="line">       classpath <span class="string">'com.github.dcendents:android-maven-gradle-plugin:2.0'</span> <span class="comment">// 这是截至目前最新版的插件</span></span><br><span class="line">       <span class="comment">// <span class="doctag">NOTE:</span> Do not place your application dependencies here; they belong</span></span><br><span class="line">       <span class="comment">// in the individual module build.gradle files</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>然后在你要上传的library包中的build.gradle文件中添加：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: <span class="string">'com.github.dcendents.android-maven'</span></span><br><span class="line">group=<span class="string">'com.github.Jay-huangjie'</span>  <span class="comment">//这里写你自己的github名字，别写我的啊</span></span><br></pre></td></tr></table></figure></p>
<p>重新编译一下，然后将代码上传到github,上传成功后进入项目主页，点击releases创建一个版本，releases或tag都行，如图：<br><img src="http://p2p0lrpx1.bkt.clouddn.com/release.png-gif" alt=""></p>
<p>创建好后进入jitPack官网：<a href="https://jitpack.io/" target="_blank" rel="noopener">https://jitpack.io/</a>;<br>在输入框中输入你的项目地址，例如我的项目地址就是<a href="https://github.com/Jay-huangjie/EasyKeyBoardView" target="_blank" rel="noopener">https://github.com/Jay-huangjie/EasyKeyBoardView</a>,得到如图所示的信息：<br><img src="http://p2p0lrpx1.bkt.clouddn.com/jitpack1.png-gif" alt=""><br>点击<code>Get it</code>按钮即可获取你的地址啦，并且，通过此地址下载的是你的library包而不是整个项目，所以你可以将库的demo也一起上传到github上，是不是非常的方便简单呢</p>
]]></content>
      
        <categories>
            
            <category> 安卓杂记 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[okhttp3Wiki文档译文]]></title>
      <url>/okhttp3-wiki-chinese.html</url>
      <content type="html"><![CDATA[<p><strong>版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起.</strong></p>
<hr>
<blockquote>
<p>本文提供一些okhttp3的文档翻译,英文文档地址:<a href="https://github.com/square/okhttp/wiki" target="_blank" rel="noopener">https://github.com/square/okhttp/wiki</a></p>
</blockquote>
<a id="more"></a>
<h3 id="Calls-调用"><a href="#Calls-调用" class="headerlink" title="Calls(调用)"></a>Calls(调用)</h3><p>HTTP客户端的工作是接受你的请求并产生响应。这在理论上很简单，但在实践中会变得棘手。</p>
<h4 id="Requests"><a href="#Requests" class="headerlink" title="Requests"></a><a href="http://square.github.io/okhttp/3.x/okhttp/okhttp3/Request.html" target="_blank" rel="noopener">Requests</a></h4><p>每个HTTP请求都包含一个URL，一个方法（如GET或POST）和一个头部列表(headers)。请求也可能包含一个请求体(body)：特定内容类型的数据流。</p>
<h4 id="Responses"><a href="#Responses" class="headerlink" title="Responses"></a><a href="http://square.github.io/okhttp/3.x/okhttp/okhttp3/Response.html" target="_blank" rel="noopener">Responses</a></h4><p>每一个HTTP响应中都包含一个状态码（如200代表成功，404代表未找​​到），一个响应头列表（headers）和一个可选的响应体（body）。</p>
<h4 id="重写请求"><a href="#重写请求" class="headerlink" title="重写请求"></a>重写请求</h4><p>当你的OkHttp发送一个HTTP请求，你在描述一个高层次的要求：“给我获取这个网址中的这些请求头。”对于正确性和效率，OkHttp发送前会重写你的请求。</p>
<p>OkHttp可以在原先的请求中添加请求头（headers），包括Content-Length, Transfer-Encoding, User-Agent, Host, Connection, 和 Content-Type。除非请求头已经存在压缩响应，否则它还将添加一个Accept-Encoding请求头。如果你有cookies，OkHttp还将添加一个Cookie请求头。</p>
<p>一些请求会有一个缓存的响应。当这个缓存的响应不是最新的时候，OkHttp会发送一个有条件的GET来下载更新的响应，如果它比缓存还新。它将会添加需要的请求头，如IF-Modified-Since和If-None-Match。</p>
<h4 id="重写响应"><a href="#重写响应" class="headerlink" title="重写响应"></a>重写响应</h4><p>如果使用透明压缩，OkHttp将删除相应的响应头Content-Encoding，Content-Length因为它们不适用于解压缩的响应主体。</p>
<p>如果条件GET成功，则来自网络和缓存的响应将按照规范的指示进行合并。</p>
<h4 id="后续请求"><a href="#后续请求" class="headerlink" title="后续请求"></a>后续请求</h4><p>当您请求的URL已经移动时，Web服务器将返回一个响应代码，302以指示文档的新URL。OkHttp将按照重定向来检索最终响应。<br>如果响应发出授权质询，则OkHttp会询问<a href="http://square.github.io/okhttp/3.x/okhttp/okhttp3/Authenticator.html" target="_blank" rel="noopener">Authenticator</a>（如果已配置）以满足质询。如果认证者提供证书，则请求将会带着证书进行重试。</p>
<h4 id="重试请求"><a href="#重试请求" class="headerlink" title="重试请求"></a>重试请求</h4><p>有时连接失败：要么是连接池已经过时和断开，或是Web服务器本身无法达成。如果有一个是可用的，OkHttp将会使用不同的路由进行请求重试。</p>
<h4 id="呼叫"><a href="#呼叫" class="headerlink" title="呼叫"></a><a href="http://square.github.io/okhttp/3.x/okhttp/okhttp3/Call.html" target="_blank" rel="noopener">呼叫</a></h4><p>随着重写，重定向，后续和重试，你简单的要求可能会产生很多请求和响应。OkHttp使用呼叫（Call）并通过许多必要的中间请求和响应来满足你请求的任务模型。通常情况，这是不是很多！如果您的网址被重定向，或者如果您故障转移到另一个IP地址，但它会欣慰的知道你的代码会继续工作。</p>
<p>通过以下两种方式进行呼叫： </p>
<ul>
<li>同步：直到响应,你的线程块是可读的。 </li>
<li>异步：你在任何线程进行排队请求，并且当响应是可读的时候，你会在另一个线程得到回调。</li>
</ul>
<p>呼叫（Calls）可以在任何线程中取消。如果它尚未完成，它将作为失败的呼叫（Calls）！当呼叫（Call）被取消的时候，如果代码试图进行写请求体（request body）或读取响应体（response body）会遭受IOException异常。</p>
<h4 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h4><p>对于同步呼叫，您需要自带线程，并负责管理多少个同时发出的请求。同时连接的垃圾资源过多; 太少的危害等待时间。</p>
<p>对于异步调用，<a href="http://square.github.io/okhttp/3.x/okhttp/okhttp3/Dispatcher.html" target="_blank" rel="noopener">Dispatcher</a>实现最大同时请求的策略。您可以设置每个网络服务器的最大数量（默认值是5），总体（默认值是64）。</p>
<h3 id="Connections-连接"><a href="#Connections-连接" class="headerlink" title="Connections(连接)"></a>Connections(连接)</h3><p>虽然您只提供了URL，但是OkHttp计划使用三种类型连接到你的web服务器：URL, Address, 和 Route</p>
<h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><p>URL（如<a href="https://github.com/square/okhttp）是HTTP和Internet的基础。除了作为网络上所有内容的通用分散命名方案之外，他们还指定如何访问网络资源。" target="_blank" rel="noopener">https://github.com/square/okhttp）是HTTP和Internet的基础。除了作为网络上所有内容的通用分散命名方案之外，他们还指定如何访问网络资源。</a></p>
<p>网址是抽象的：</p>
<ul>
<li>他们指定的调用可能是明文（http）或加密（https），但不应该使用哪些加密算法。他们也没有指定如何验证对等方的证书（HostnameVerifier）或哪些证书可以信任（SSLSocketFactory）。他们也是具体的：每个URL标识一个特定的路径（如/square/okhttp）和查询（如?q=sharks&amp;lang=en）。每个网络服务器都有许多网址。</li>
<li>它们不指定是否应该使用特定的代理服务器，或者如何使用该代理服务器进行身份验证。</li>
</ul>
<p>他们也是具体的：每个URL标识一个特定的路径（如/square/okhttp）和查询（如?q=sharks&amp;lang=en）。每个网络服务器都有许多网址。</p>
<h4 id="Addresses"><a href="#Addresses" class="headerlink" title="Addresses"></a>Addresses</h4><p>地址指定一个网络服务器（如github.com）以及连接到该服务器所需的所有静态配置：端口号，HTTPS设置和首选网络协议（如HTTP / 2或SPDY）。</p>
<p>共享相同地址的URL也可能共享相同的底层TCP套接字连接。共享连接具有显着的性能优势：更低的延迟，更高的吞吐量（由于<a href="http://www.igvita.com/2011/10/20/faster-web-vs-tcp-slow-start/" target="_blank" rel="noopener">TCP启动缓慢</a>）和保存的电池。OkHttp使用<a href="http://square.github.io/okhttp/3.x/okhttp/okhttp3/ConnectionPool.html" target="_blank" rel="noopener">ConnectionPool</a>自动重用HTTP / 1.x连接并复用HTTP / 2和SPDY连接。</p>
<p>在OkHttp地址的一些字段来自URL（方案，主机名，端口），其余来自<a href="http://square.github.io/okhttp/3.x/okhttp/okhttp3/OkHttpClient.html" target="_blank" rel="noopener">OkHttpClient</a>。</p>
<h4 id="Routes"><a href="#Routes" class="headerlink" title="Routes"></a>Routes</h4><p>路由提供实际连接到Web服务器所需的动态信息。这是要尝试的特定IP地址（通过DNS查询发现），要使用的确切代理服务器（如果正在使用<a href="http://developer.android.com/reference/java/net/ProxySelector.html" target="_blank" rel="noopener">ProxySelector</a>）以及要协商哪个版本的TLS（用于HTTPS连接）。</p>
<p>单个地址可能有很多路线。例如，托管在多个数据中心中的Web服务器可能会在其DNS响应中产生多个IP地址。</p>
<h4 id="Connections"><a href="#Connections" class="headerlink" title="Connections"></a>Connections</h4><p>当你用OkHttp请求一个URL的时候，它的功能如下：</p>
<p>它使用URL并配置OkHttpClient来创建一个地址。该地址指定我们将如何连接到Web服务器。<br>它尝试从连接池中检索具有该地址的连接。<br>如果在池中找不到连接，则选择要尝试的路由。这通常意味着发出DNS请求来获取服务器的IP地址。然后根据需要选择TLS版本和代理服务器。<br>如果是新路由，则通过构建直接套接字连接，TLS隧道（用于通过HTTP代理的HTTPS）或直接TLS连接进行连接。它根据需要进行TLS握手。<br>它发送HTTP请求并读取响应。<br>如果连接有问题，OkHttp会选择另外一个路径，然后重试。这允许OkHttp在服务器地址的子集无法访问时恢复。当池连接失效或尝试的TLS版本不受支持时，这也很有用。</p>
<p>一旦接收到响应，连接将被返回到池中，以便将来可以重复使用。经过一段时间的不活动之后，连接被从池中逐出。</p>
<h3 id="Recipes-方法"><a href="#Recipes-方法" class="headerlink" title="Recipes(方法)"></a>Recipes(方法)</h3><p>我们已经写了一些方法，演示了如何解决OkHttp常见问题。通过阅读他们了解一切是如何正常工作的。可以自由剪切和粘贴这些例子。</p>
<h4 id="同步获取-Synchronous-Get"><a href="#同步获取-Synchronous-Get" class="headerlink" title="同步获取(Synchronous Get)"></a>同步获取(Synchronous Get)</h4><p>下载文件，打印其头部，并以字符串形式打印其响应体。</p>
<p>该<code>string()</code>方法在响应体中是方便快捷的小型文件。但是，如果响应体较大（大于1 MIB以上），它会将整个较大文件加载到内存中，所以应该避免<code>string()</code> 。在这种情况下，更倾向于将响应体作为流进行处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">      .url(<span class="string">"https://publicobject.com/helloworld.txt"</span>)</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> (Response response = client.newCall(request).execute()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!response.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response);</span><br><span class="line"></span><br><span class="line">    Headers responseHeaders = response.headers();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; responseHeaders.size(); i++) &#123;</span><br><span class="line">      System.out.println(responseHeaders.name(i) + <span class="string">": "</span> + responseHeaders.value(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(response.body().string());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="异步获取-Asynchronous-Get"><a href="#异步获取-Asynchronous-Get" class="headerlink" title="异步获取(Asynchronous Get)"></a>异步获取(Asynchronous Get)</h4><p>下载一个工作线程的文件，当响应是可读的时候，获取回调（Callback）。当响应头已经准备好后，将产生回调（Callback）。读取响应体可能一直阻塞。目前OkHttp不提供异步API来接收响应体的部位。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">        .url(<span class="string">"http://publicobject.com/helloworld.txt"</span>)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    client.newCall(request).enqueue(<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call call, IOException e)</span> </span>&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call call, Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ResponseBody responseBody = response.body()) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!response.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response);</span><br><span class="line"></span><br><span class="line">          Headers responseHeaders = response.headers();</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = responseHeaders.size(); i &lt; size; i++) &#123;</span><br><span class="line">            System.out.println(responseHeaders.name(i) + <span class="string">": "</span> + responseHeaders.value(i));</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          System.out.println(responseBody.string());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="访问头"><a href="#访问头" class="headerlink" title="访问头"></a>访问头</h4><p>典型的HTTP头工作就像一个Map<string, string=""> ：每个字段都有一个值或无值。但是，一些头部(headers)允许多个值，比如Guava的Multimap。例如，它共同为一个HTTP响应提供多个Vary头。OkHttp的API，试图使这两种情况下都能舒适使用。</string,></p>
<p>当写请求头，用header(name, value)来为唯一出现的name设置value。如果它本身存在值，在添加新的value之前，他们会被移除。使用addHeader(name, value)来添加头部不需要移除当前存在的headers。</p>
<p>当读取响应头，用header(name)返回最后设置name的value。如果没有value，header(name)将返回null。可以使用headers(name)来读取所有列表字段的值，。</p>
<p>要访问所有的头部，用Headers类，它支持索引访问。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">      .url(<span class="string">"https://api.github.com/repos/square/okhttp/issues"</span>)</span><br><span class="line">      .header(<span class="string">"User-Agent"</span>, <span class="string">"OkHttp Headers.java"</span>)</span><br><span class="line">      .addHeader(<span class="string">"Accept"</span>, <span class="string">"application/json; q=0.5"</span>)</span><br><span class="line">      .addHeader(<span class="string">"Accept"</span>, <span class="string">"application/vnd.github.v3+json"</span>)</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> (Response response = client.newCall(request).execute()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!response.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"Server: "</span> + response.header(<span class="string">"Server"</span>));</span><br><span class="line">    System.out.println(<span class="string">"Date: "</span> + response.header(<span class="string">"Date"</span>));</span><br><span class="line">    System.out.println(<span class="string">"Vary: "</span> + response.headers(<span class="string">"Vary"</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="提交一个文本-Posting-a-String"><a href="#提交一个文本-Posting-a-String" class="headerlink" title="提交一个文本(Posting a String)"></a>提交一个文本(Posting a String)</h4><p>使用HTTP POST的请求体发送到服务。下面例子post了一个markdown文档到一个的Web服务（将markdown作为HTML）。由于整个请求体是同时在内存中，应避免使用此API发送较大（大于1 MIB）的文件。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MediaType MEDIA_TYPE_MARKDOWN</span><br><span class="line">    = MediaType.parse(<span class="string">"text/x-markdown; charset=utf-8"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  String postBody = <span class="string">""</span></span><br><span class="line">      + <span class="string">"Releases\n"</span></span><br><span class="line">      + <span class="string">"--------\n"</span></span><br><span class="line">      + <span class="string">"\n"</span></span><br><span class="line">      + <span class="string">" * _1.0_ May 6, 2013\n"</span></span><br><span class="line">      + <span class="string">" * _1.1_ June 15, 2013\n"</span></span><br><span class="line">      + <span class="string">" * _1.2_ August 11, 2013\n"</span>;</span><br><span class="line"></span><br><span class="line">  Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">      .url(<span class="string">"https://api.github.com/markdown/raw"</span>)</span><br><span class="line">      .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, postBody))</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> (Response response = client.newCall(request).execute()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!response.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response);</span><br><span class="line"></span><br><span class="line">    System.out.println(response.body().string());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="发布一个流-Post-Streaming"><a href="#发布一个流-Post-Streaming" class="headerlink" title="发布一个流(Post Streaming)"></a>发布一个流(Post Streaming)</h4><p>在这里，我们POST请求体作为stream。将正在生成请求体的内容写入到stream中。下面例子streams直接进入<a href="https://github.com/square/okio" target="_blank" rel="noopener">Okio</a>缓冲水槽。你的程序可能更喜欢使用OutputStream，你可以通过BufferedSink.outputStream（）获得 OutputStream。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MediaType MEDIA_TYPE_MARKDOWN</span><br><span class="line">    = MediaType.parse(<span class="string">"text/x-markdown; charset=utf-8"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  RequestBody requestBody = <span class="keyword">new</span> RequestBody() &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> MediaType <span class="title">contentType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> MEDIA_TYPE_MARKDOWN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeTo</span><span class="params">(BufferedSink sink)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      sink.writeUtf8(<span class="string">"Numbers\n"</span>);</span><br><span class="line">      sink.writeUtf8(<span class="string">"-------\n"</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">997</span>; i++) &#123;</span><br><span class="line">        sink.writeUtf8(String.format(<span class="string">" * %s = %s\n"</span>, i, factor(i)));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">factor</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = n / i;</span><br><span class="line">        <span class="keyword">if</span> (x * i == n) <span class="keyword">return</span> factor(x) + <span class="string">" × "</span> + i;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> Integer.toString(n);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">      .url(<span class="string">"https://api.github.com/markdown/raw"</span>)</span><br><span class="line">      .post(requestBody)</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> (Response response = client.newCall(request).execute()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!response.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response);</span><br><span class="line"></span><br><span class="line">    System.out.println(response.body().string());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="发布文件-Posting-a-File"><a href="#发布文件-Posting-a-File" class="headerlink" title="发布文件(Posting a File)"></a>发布文件(Posting a File)</h4><p>将文件作为请求体是很容易的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MediaType MEDIA_TYPE_MARKDOWN</span><br><span class="line">    = MediaType.parse(<span class="string">"text/x-markdown; charset=utf-8"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  File file = <span class="keyword">new</span> File(<span class="string">"README.md"</span>);</span><br><span class="line"></span><br><span class="line">  Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">      .url(<span class="string">"https://api.github.com/markdown/raw"</span>)</span><br><span class="line">      .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, file))</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> (Response response = client.newCall(request).execute()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!response.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response);</span><br><span class="line"></span><br><span class="line">    System.out.println(response.body().string());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="发布表单-Posting-form-parameters"><a href="#发布表单-Posting-form-parameters" class="headerlink" title="发布表单(Posting form parameters)"></a>发布表单(Posting form parameters)</h4><p>使用<code>FormBody.Builder</code>建立一个请求体，它就像一个HTML的<code>&lt;form&gt;</code>标记。<code>Names</code>和<code>values</code>将使用<code>HTML</code>兼容的表单URL编码进行编码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  RequestBody formBody = <span class="keyword">new</span> FormBody.Builder()</span><br><span class="line">      .add(<span class="string">"search"</span>, <span class="string">"Jurassic Park"</span>)</span><br><span class="line">      .build();</span><br><span class="line">  Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">      .url(<span class="string">"https://en.wikipedia.org/w/index.php"</span>)</span><br><span class="line">      .post(formBody)</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> (Response response = client.newCall(request).execute()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!response.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response);</span><br><span class="line"> </span><br><span class="line">    System.out.println(response.body().string());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="发布multipart请求-Posting-a-multipart-request"><a href="#发布multipart请求-Posting-a-multipart-request" class="headerlink" title="发布multipart请求(Posting a multipart request)"></a>发布multipart请求(Posting a multipart request)</h4><p><code>MultipartBody.Builder</code>可以构建与HTML文件上传表单兼容的复杂请求主体。multipart请求体的每一部分本身就是请求体，并且可以定义自己的头部。如果存在，这些头应该描述的部分请求体，如它的<code>Content-Disposition</code>。如果<code>Content-Length</code>和 <code>Content-Type</code>头部可以使用，则他们会自动添加。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The imgur client ID for OkHttp recipes. If you're using imgur for anything other than running</span></span><br><span class="line"><span class="comment"> * these examples, please request your own client ID! https://api.imgur.com/oauth2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String IMGUR_CLIENT_ID = <span class="string">"..."</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MediaType MEDIA_TYPE_PNG = MediaType.parse(<span class="string">"image/png"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="comment">// Use the imgur image upload API as documented at https://api.imgur.com/endpoints/image</span></span><br><span class="line">  RequestBody requestBody = <span class="keyword">new</span> MultipartBody.Builder()</span><br><span class="line">      .setType(MultipartBody.FORM)</span><br><span class="line">      .addFormDataPart(<span class="string">"title"</span>, <span class="string">"Square Logo"</span>)</span><br><span class="line">      .addFormDataPart(<span class="string">"image"</span>, <span class="string">"logo-square.png"</span>,</span><br><span class="line">          RequestBody.create(MEDIA_TYPE_PNG, <span class="keyword">new</span> File(<span class="string">"website/static/logo-square.png"</span>)))</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">  Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">      .header(<span class="string">"Authorization"</span>, <span class="string">"Client-ID "</span> + IMGUR_CLIENT_ID)</span><br><span class="line">      .url(<span class="string">"https://api.imgur.com/3/image"</span>)</span><br><span class="line">      .post(requestBody)</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> (Response response = client.newCall(request).execute()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!response.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response);</span><br><span class="line"></span><br><span class="line">    System.out.println(response.body().string());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="用Moshi解析JSON响应"><a href="#用Moshi解析JSON响应" class="headerlink" title="用Moshi解析JSON响应"></a>用<code>Moshi</code>解析JSON响应</h4><p><a href="https://github.com/square/moshi" target="_blank" rel="noopener">Moshi</a>是一个便捷的API，用于在JSON和Java对象之间进行转换。这里我们使用它来解码来自GitHub API的JSON响应。</p>
<p>请注意，<code>ResponseBody.charStream()</code>使用<code>Content-Type</code>响应头来选择解码响应主体时使用哪个字符集。如果没有指定字符集，它默认为<code>UTF-8</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Moshi moshi = <span class="keyword">new</span> Moshi.Builder().build();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> JsonAdapter&lt;Gist&gt; gistJsonAdapter = moshi.adapter(Gist.class);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">      .url(<span class="string">"https://api.github.com/gists/c2a7c39532239ff261be"</span>)</span><br><span class="line">      .build();</span><br><span class="line">  <span class="keyword">try</span> (Response response = client.newCall(request).execute()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!response.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response);</span><br><span class="line"></span><br><span class="line">    Gist gist = gistJsonAdapter.fromJson(response.body().source());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, GistFile&gt; entry : gist.files.entrySet()) &#123;</span><br><span class="line">      System.out.println(entry.getKey());</span><br><span class="line">      System.out.println(entry.getValue().content);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Gist</span> </span>&#123;</span><br><span class="line">  Map&lt;String, GistFile&gt; files;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">GistFile</span> </span>&#123;</span><br><span class="line">  String content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="响应缓存"><a href="#响应缓存" class="headerlink" title="响应缓存"></a>响应缓存</h4><p>要缓存响应，你需要有一个缓存目录来进行读取和写入，并限制缓存的大小。缓存目录应该是私有的，不被信任的应用程序不能够阅读其内容！</p>
<p>多个缓存同时访问相同的缓存目录，这是错误的。大多数应用程序应该调用一次new OkHttpClient()，在任何地方都使用相同的实例和自己的缓存配置。否则，这两个缓存实例将踩到对方，破坏响应缓存，这可能使你的程序崩溃。</p>
<p>响应缓存使用HTTP头进行配置。您可以添加请求头Cache-Control: max-stale=3600，这样OkHttp的缓存就会遵循他们。你的网络服务器可以通过自己的响应头配置缓存多长时间的响应，如Cache-Control: max-age=9600。有缓存头强制缓存的响应，强制网络响应，或强制使用条件GET验证的网络响应。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CacheResponse</span><span class="params">(File cacheDirectory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> cacheSize = <span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>; <span class="comment">// 10 MiB</span></span><br><span class="line">  Cache cache = <span class="keyword">new</span> Cache(cacheDirectory, cacheSize);</span><br><span class="line"></span><br><span class="line">  client = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">      .cache(cache)</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">      .url(<span class="string">"http://publicobject.com/helloworld.txt"</span>)</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">  String response1Body;</span><br><span class="line">  <span class="keyword">try</span> (Response response1 = client.newCall(request).execute()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!response1.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response1);</span><br><span class="line"></span><br><span class="line">    response1Body = response1.body().string();</span><br><span class="line">    System.out.println(<span class="string">"Response 1 response:          "</span> + response1);</span><br><span class="line">    System.out.println(<span class="string">"Response 1 cache response:    "</span> + response1.cacheResponse());</span><br><span class="line">    System.out.println(<span class="string">"Response 1 network response:  "</span> + response1.networkResponse());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  String response2Body;</span><br><span class="line">  <span class="keyword">try</span> (Response response2 = client.newCall(request).execute()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!response2.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response2);</span><br><span class="line"></span><br><span class="line">    response2Body = response2.body().string();</span><br><span class="line">    System.out.println(<span class="string">"Response 2 response:          "</span> + response2);</span><br><span class="line">    System.out.println(<span class="string">"Response 2 cache response:    "</span> + response2.cacheResponse());</span><br><span class="line">    System.out.println(<span class="string">"Response 2 network response:  "</span> + response2.networkResponse());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">"Response 2 equals Response 1? "</span> + response1Body.equals(response2Body));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>CacheControl.FORCE_NETWORK</code>可以禁止使用缓存的响应。使<code>用</code>CacheControl.FORCE_CACHE<code>可以禁止使用网络。警告：如果您使用FORCE_CACHE</code>和响应来自网络，OkHttp将会返回一个504不可满足请求的响应。</p>
<h4 id="取消Call"><a href="#取消Call" class="headerlink" title="取消Call"></a>取消Call</h4><p>通过<code>Call.cancel()</code>来立即停止正在进行的Call。如果一个线程目前正在写请求或读响应，它还将收到一个<code>IOException</code>异常。当一个Call不需要时，使用取消Call来保护网络; 例如，当用户从应用程序导航离开。同步和异步调用可以被取消。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService executor = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">      .url(<span class="string">"http://httpbin.org/delay/2"</span>) <span class="comment">// This URL is served with a 2 second delay.</span></span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">long</span> startNanos = System.nanoTime();</span><br><span class="line">  <span class="keyword">final</span> Call call = client.newCall(request);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Schedule a job to cancel the call in 1 second.</span></span><br><span class="line">  executor.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.printf(<span class="string">"%.2f Canceling call.%n"</span>, (System.nanoTime() - startNanos) / <span class="number">1e9f</span>);</span><br><span class="line">      call.cancel();</span><br><span class="line">      System.out.printf(<span class="string">"%.2f Canceled call.%n"</span>, (System.nanoTime() - startNanos) / <span class="number">1e9f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">  System.out.printf(<span class="string">"%.2f Executing call.%n"</span>, (System.nanoTime() - startNanos) / <span class="number">1e9f</span>);</span><br><span class="line">  <span class="keyword">try</span> (Response response = call.execute()) &#123;</span><br><span class="line">    System.out.printf(<span class="string">"%.2f Call was expected to fail, but completed: %s%n"</span>,</span><br><span class="line">        (System.nanoTime() - startNanos) / <span class="number">1e9f</span>, response);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    System.out.printf(<span class="string">"%.2f Call failed as expected: %s%n"</span>,</span><br><span class="line">        (System.nanoTime() - startNanos) / <span class="number">1e9f</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h4><p>当无法访问查询时，将调用超时失败。超时在网络划分中可以是由于客户端连接问题，服务器可用性的问题，或两者之间的任何东西。OkHttp支持连接，读取和写入超时。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConfigureTimeouts</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  client = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">      .connectTimeout(<span class="number">10</span>, TimeUnit.SECONDS)</span><br><span class="line">      .writeTimeout(<span class="number">10</span>, TimeUnit.SECONDS)</span><br><span class="line">      .readTimeout(<span class="number">30</span>, TimeUnit.SECONDS)</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">      .url(<span class="string">"http://httpbin.org/delay/2"</span>) <span class="comment">// This URL is served with a 2 second delay.</span></span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> (Response response = client.newCall(request).execute()) &#123;</span><br><span class="line">    System.out.println(<span class="string">"Response completed: "</span> + response);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="每个呼叫配置"><a href="#每个呼叫配置" class="headerlink" title="每个呼叫配置"></a>每个呼叫配置</h4><p>所有的HTTP客户端都在<code>OkHttpClient</code>中配置，这包括代理设置，超时和缓存。当你需要改变单一Call的配置时，调用<code>OkHttpClient.newBuilder()</code>。这将返回共享相同的连接池，调度和配置的原客户端的建造器。在下面的例子中，我们做了500毫秒超时，另外一个3000毫秒超时请求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">      .url(<span class="string">"http://httpbin.org/delay/1"</span>) <span class="comment">// This URL is served with a 1 second delay.</span></span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Copy to customize OkHttp for this request.</span></span><br><span class="line">  OkHttpClient client1 = client.newBuilder()</span><br><span class="line">      .readTimeout(<span class="number">500</span>, TimeUnit.MILLISECONDS)</span><br><span class="line">      .build();</span><br><span class="line">  <span class="keyword">try</span> (Response response = client1.newCall(request).execute()) &#123;</span><br><span class="line">    System.out.println(<span class="string">"Response 1 succeeded: "</span> + response);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">"Response 1 failed: "</span> + e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Copy to customize OkHttp for this request.</span></span><br><span class="line">  OkHttpClient client2 = client.newBuilder()</span><br><span class="line">      .readTimeout(<span class="number">3000</span>, TimeUnit.MILLISECONDS)</span><br><span class="line">      .build();</span><br><span class="line">  <span class="keyword">try</span> (Response response = client2.newCall(request).execute()) &#123;</span><br><span class="line">    System.out.println(<span class="string">"Response 2 succeeded: "</span> + response);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">"Response 2 failed: "</span> + e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="认证处理"><a href="#认证处理" class="headerlink" title="认证处理"></a>认证处理</h4><p>OkHttp能够自动重试未经授权的请求。当响应是<code>401 Not Authorized</code>，一个<code>Authenticator</code>被要求提供凭据。应该建立一个包含缺少凭据的新要求。如果没有凭证可用，则返回null跳过重试。</p>
<p>使用<code>Response.challenges（）</code>获得任何认证挑战方案和领域。当完成一个基本的挑战，用<code>Credentials.basic(username, password)</code>编码请求头。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Authenticate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  client = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">      .authenticator(<span class="keyword">new</span> Authenticator() &#123;</span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Request <span class="title">authenticate</span><span class="params">(Route route, Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (response.request().header(<span class="string">"Authorization"</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// Give up, we've already attempted to authenticate.</span></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          System.out.println(<span class="string">"Authenticating for response: "</span> + response);</span><br><span class="line">          System.out.println(<span class="string">"Challenges: "</span> + response.challenges());</span><br><span class="line">          String credential = Credentials.basic(<span class="string">"jesse"</span>, <span class="string">"password1"</span>);</span><br><span class="line">          <span class="keyword">return</span> response.request().newBuilder()</span><br><span class="line">              .header(<span class="string">"Authorization"</span>, credential)</span><br><span class="line">              .build();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">      .url(<span class="string">"http://publicobject.com/secrets/hellosecret.txt"</span>)</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> (Response response = client.newCall(request).execute()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!response.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response);</span><br><span class="line"></span><br><span class="line">    System.out.println(response.body().string());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了避免验证时不工作的重试，你可以返回null放弃。例如，当这些确切的凭据已经尝试,您可以跳过重试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (credential.equals(response.request().header(<span class="string">"Authorization"</span>))) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 如果我们已经使用这些凭据失败，不重试</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>当你的应用尝试的次数超过了限制的次数时，你可以跳过重试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (responseCount(response) &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">//如果我们已经失败了3次，放弃。 .</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>这上面的代码依赖于下面的<code>responseCount()</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">responseCount</span><span class="params">(Response response)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">while</span> ((response = response.priorResponse()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">     result++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Interceptors-拦截器"><a href="#Interceptors-拦截器" class="headerlink" title="Interceptors(拦截器)"></a>Interceptors(拦截器)</h3><p>拦截器是一个强大的机制，它可以监控，重写和重试Calls。下面是一个简单记录传出请求和响应传入的拦截器。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Interceptor.Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Request request = chain.request();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">    logger.info(String.format(<span class="string">"Sending request %s on %s%n%s"</span>,</span><br><span class="line">        request.url(), chain.connection(), request.headers()));</span><br><span class="line"></span><br><span class="line">    Response response = chain.proceed(request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> t2 = System.nanoTime();</span><br><span class="line">    logger.info(String.format(<span class="string">"Received response for %s in %.1fms%n%s"</span>,</span><br><span class="line">        response.request().url(), (t2 - t1) / <span class="number">1e6</span>d, response.headers()));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用<code>chain.proceed(request)</code>是每个拦截器实现的关键部分。这个看起来很简单的方法就是所有HTTP工作发生的地方，产生满足请求的响应。</p>
<p>拦截器可以被链接。假设你有一个压缩拦截器和一个校验和拦截器：你需要决定数据是压缩的，然后进行校验和，或者校验和压缩。OkHttp使用列表来跟踪拦截器，拦截器是按顺序调用的。<br><img src="https://raw.githubusercontent.com/wiki/square/okhttp/interceptors@2x.png" alt=""></p>
<h4 id="应用程序拦截器"><a href="#应用程序拦截器" class="headerlink" title="应用程序拦截器"></a>应用程序拦截器</h4><p>拦截器可以注册为应用拦截器或网络拦截器。我们将使用<code>LoggingInterceptor</code>来区别。</p>
<p>通过在<code>OkHttpClient.Builder</code>上调用<code>addInterceptor（）</code>来注册应用程序拦截器：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">    .addInterceptor(<span class="keyword">new</span> LoggingInterceptor())</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">    .url(<span class="string">"http://www.publicobject.com/helloworld.txt"</span>)</span><br><span class="line">    .header(<span class="string">"User-Agent"</span>, <span class="string">"OkHttp Example"</span>)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">Response response = client.newCall(request).execute();</span><br><span class="line">response.body().close();</span><br></pre></td></tr></table></figure></p>
<p>该URL：<a href="http://www.publicobject.com/helloworld.txt" target="_blank" rel="noopener">http://www.publicobject.com/helloworld.txt</a> 重定向到<a href="https://publicobject.com/helloworld.txt" target="_blank" rel="noopener">https://publicobject.com/helloworld.txt</a>, OkHttp自动重定向。我们的应用程序拦截器被调用一次，返回的响应chain.proceed()具有重定向的响应：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">INFO: Sending request http:<span class="comment">//www.publicobject.com/helloworld.txt on null</span></span><br><span class="line">User-Agent: OkHttp Example</span><br><span class="line"></span><br><span class="line">INFO: Received response <span class="keyword">for</span> https:<span class="comment">//publicobject.com/helloworld.txt in 1179.7ms</span></span><br><span class="line">Server: nginx/<span class="number">1.4</span>.6 (Ubuntu)</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Length: <span class="number">1759</span></span><br><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到，我们被重定向了，因为<code>response.request().url()</code>不同于<code>request.url()</code>。这两个日志语句记录两个不同的URL。</p>
<h4 id="网络拦截器"><a href="#网络拦截器" class="headerlink" title="网络拦截器"></a>网络拦截器</h4><p>注册网络拦截器很类似。调用<code>addNetworkInterceptor()</code>代替<code>addInterceptor()</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">    .addNetworkInterceptor(<span class="keyword">new</span> LoggingInterceptor())</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">    .url(<span class="string">"http://www.publicobject.com/helloworld.txt"</span>)</span><br><span class="line">    .header(<span class="string">"User-Agent"</span>, <span class="string">"OkHttp Example"</span>)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">Response response = client.newCall(request).execute();</span><br><span class="line">response.body().close();</span><br></pre></td></tr></table></figure></p>
<p>当我们运行这个代码时，拦截器运行两次。一次为最初的请求<code>http://www.publicobject.com/helloworld.txt</code>，另一个为重定向<code>https://publicobject.com/helloworld.txt</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">INFO: Sending request http:<span class="comment">//www.publicobject.com/helloworld.txt on Connection&#123;www.publicobject.com:80, proxy=DIRECT hostAddress=54.187.32.157 cipherSuite=none protocol=http/1.1&#125;</span></span><br><span class="line">User-Agent: OkHttp Example</span><br><span class="line">Host: www.publicobject.com</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Accept-Encoding: gzip</span><br><span class="line"></span><br><span class="line">INFO: Received response <span class="keyword">for</span> http:<span class="comment">//www.publicobject.com/helloworld.txt in 115.6ms</span></span><br><span class="line">Server: nginx/<span class="number">1.4</span>.6 (Ubuntu)</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: <span class="number">193</span></span><br><span class="line">Connection: keep-alive</span><br><span class="line">Location: https:<span class="comment">//publicobject.com/helloworld.txt</span></span><br><span class="line"></span><br><span class="line">INFO: Sending request https:<span class="comment">//publicobject.com/helloworld.txt on Connection&#123;publicobject.com:443, proxy=DIRECT hostAddress=54.187.32.157 cipherSuite=TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA protocol=http/1.1&#125;</span></span><br><span class="line">User-Agent: OkHttp Example</span><br><span class="line">Host: publicobject.com</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Accept-Encoding: gzip</span><br><span class="line"></span><br><span class="line">INFO: Received response <span class="keyword">for</span> https:<span class="comment">//publicobject.com/helloworld.txt in 80.9ms</span></span><br><span class="line">Server: nginx/<span class="number">1.4</span>.6 (Ubuntu)</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Length: <span class="number">1759</span></span><br><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure></p>
<p>网络请求还包含很多数据，如<code>OkHttp</code>加入<code>Accept-Encoding: gzip</code>头部通知支持压缩响应。网络拦截器的链具有非空的连接，它可用于询问IP地址和连接到网络服务器的TLS配置。</p>
<h4 id="应用程序和网络拦截之间进行选择"><a href="#应用程序和网络拦截之间进行选择" class="headerlink" title="应用程序和网络拦截之间进行选择"></a>应用程序和网络拦截之间进行选择</h4><p>每个拦截器链(interceptor chain)都具有相对优势。</p>
<h5 id="应用拦截器"><a href="#应用拦截器" class="headerlink" title="应用拦截器"></a>应用拦截器</h5><ul>
<li>不必担心像重定向和重试的中间响应。</li>
<li>总是被调用一次，即使HTTP响应来自缓存服务。</li>
<li>观察应用程序的原意。不关心OkHttp注入的头文件，如 If-None-Match。</li>
<li>允许短路和不调用Chain.proceed（） 。</li>
<li>允许重试，并多次调用Chain.proceed（） 。</li>
</ul>
<h5 id="网络拦截器-1"><a href="#网络拦截器-1" class="headerlink" title="网络拦截器"></a>网络拦截器</h5><ul>
<li>能够操作像重定向和重试的中间响应。</li>
<li>在短路网络上不调用缓存的响应。</li>
<li>观察在网络上传输的数据。</li>
<li>访问Connection承载请求。</li>
</ul>
<h4 id="重写请求-1"><a href="#重写请求-1" class="headerlink" title="重写请求"></a>重写请求</h4><p>拦截器可以添加，删除或替换请求头。他们还可以转换请求体。例如，如果你连接到已知支持它的网络服务器，你可以使用应用程序拦截器添加请求体的压缩。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** This interceptor compresses the HTTP request body. Many webservers can't handle this! */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">GzipRequestInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Interceptor.Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Request originalRequest = chain.request();</span><br><span class="line">    <span class="keyword">if</span> (originalRequest.body() == <span class="keyword">null</span> || originalRequest.header(<span class="string">"Content-Encoding"</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> chain.proceed(originalRequest);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Request compressedRequest = originalRequest.newBuilder()</span><br><span class="line">        .header(<span class="string">"Content-Encoding"</span>, <span class="string">"gzip"</span>)</span><br><span class="line">        .method(originalRequest.method(), gzip(originalRequest.body()))</span><br><span class="line">        .build();</span><br><span class="line">    <span class="keyword">return</span> chain.proceed(compressedRequest);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> RequestBody <span class="title">gzip</span><span class="params">(<span class="keyword">final</span> RequestBody body)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RequestBody() &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> MediaType <span class="title">contentType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> body.contentType();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">contentLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// We don't know the compressed length in advance!</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeTo</span><span class="params">(BufferedSink sink)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedSink gzipSink = Okio.buffer(<span class="keyword">new</span> GzipSink(sink));</span><br><span class="line">        body.writeTo(gzipSink);</span><br><span class="line">        gzipSink.close();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="重写响应-1"><a href="#重写响应-1" class="headerlink" title="重写响应"></a>重写响应</h4><p>相对应的，拦截器也可以重写响应头和转换响应体。通常不要重写请求头，因为它可能违反了Web服务器的期望导致更危险！</p>
<p>在一个棘手的情况下，如果已经做好应对的后果，重写响应头是解决问题的有效方式。例如，您可以修复服务器的配置错误的Cache-Control响应头以便更好地响应缓存：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Dangerous interceptor that rewrites the server's cache-control header. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Interceptor REWRITE_CACHE_CONTROL_INTERCEPTOR = <span class="keyword">new</span> Interceptor() &#123;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Interceptor.Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Response originalResponse = chain.proceed(chain.request());</span><br><span class="line">    <span class="keyword">return</span> originalResponse.newBuilder()</span><br><span class="line">        .header(<span class="string">"Cache-Control"</span>, <span class="string">"max-age=60"</span>)</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>通常此方法效果最好，它补充了在Web服务器上相应的修复！</p>
<h4 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h4><p>OkHttp的拦截器需要OkHttp 2.2或更高版本。不幸的是，拦截器不适<code>OkUrlFactory</code>用于构建它的库，包括<a href="http://square.github.io/retrofit/" target="_blank" rel="noopener">Retrofit≤1.8</a>和<a href="http://square.github.io/picasso/" target="_blank" rel="noopener">Picasso≤2.4</a>。</p>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>OkHttp试图平衡两个相互竞争的担忧：</p>
<ul>
<li>连接到尽可能多的主机。这包括运行最新版本的<a href="https://boringssl.googlesource.com/boringssl/" target="_blank" rel="noopener">boringssl</a>的高级主机，以及运行旧版本<a href="https://www.openssl.org/" target="_blank" rel="noopener">OpenSSL</a>的过时主机。</li>
<li>连接的安全性。这包括验证具有证书的远程网络服务器以及与强密码交换的数据的私密性。<br>协商连接到HTTPS服务器时，OkHttp需要知道提供哪些<a href="http://square.github.io/okhttp/3.x/okhttp/okhttp3/TlsVersion.html" target="_blank" rel="noopener">TLS</a>版本和<a href="http://square.github.io/okhttp/3.x/okhttp/okhttp3/CipherSuite.html" target="_blank" rel="noopener">密码套件</a>。希望最大化连接的客户端将包括过时的TLS版本和弱设计密码套件。一个想要最大限度地提高安全性的严格的客户端将仅限于最新的TLS版本和最强的密码套件。</li>
</ul>
<p><a href="http://square.github.io/okhttp/3.x/okhttp/okhttp3/ConnectionSpec.html" target="_blank" rel="noopener">ConnectionSpec</a>实现特定的安全性和连接性决定。OkHttp包含三个内置的连接规范：</p>
<ul>
<li><code>MODERN_TLS</code>是连接到现代HTTPS服务器的安全配置。</li>
<li><code>COMPATIBLE_TLS</code>是一种连接到安全但不是当前HTTPS服务器的安全配置。</li>
<li><code>CLEARTEXT</code>是用于<code>http://</code>URL 的不安全配置。</li>
</ul>
<p>默认情况下，OkHttp将尝试<code>MODERN_TLS</code>连接，<code>COMPATIBLE_TLS</code>如果现代配置失败，则回退连接。</p>
<p>每个规范中的TLS版本和密码套件可随每个版本而改变。例如，在OkHttp 2.2中，我们放弃了对SSL 3.0的支持来响应<code>POODLE</code>攻击。而在OkHttp 2.3我们放弃了对<code>RC4</code>的支持。与您的桌面网络浏览器一样，保持OkHttp的最新状态是保持安全的最佳方式。</p>
<p>您可以使用自定义的TLS版本和密码套件来构建自己的连接规范。例如，这种配置仅限于三个备受好评的密码套件。它的缺点是它需要Android 5.0+和一个类似的当前网络服务器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ConnectionSpec spec = <span class="keyword">new</span> ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)  </span><br><span class="line">    .tlsVersions(TlsVersion.TLS_1_2)</span><br><span class="line">    .cipherSuites(</span><br><span class="line">          CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,</span><br><span class="line">          CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,</span><br><span class="line">          CipherSuite.TLS_DHE_RSA_WITH_AES_128_GCM_SHA256)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient.Builder() </span><br><span class="line">    .connectionSpecs(Collections.singletonList(spec))</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>
<h4 id="证书锁定"><a href="#证书锁定" class="headerlink" title="证书锁定"></a>证书锁定</h4><p>默认情况下，OkHttp信任主机平台的证书权限。这一战略最大限度地提高了连接性，但是它受到证书颁发机构的攻击，例如[<a href="http://www.computerworld.com/article/2510951/cybercrime-hacking/hackers-spied-on-300-000-iranians-using-fake-google-certificate.html" target="_blank" rel="noopener">2011年DigiNotar攻击</a>。它还假定您的HTTPS服务器的证书由证书颁发机构签名。</p>
<p>使用<a href="http://square.github.io/okhttp/3.x/okhttp/okhttp3/CertificatePinner.html" target="_blank" rel="noopener">CertificatePinner</a>来限制哪些证书和证书颁发机构是可信的。证书固定增加了安全性，但是限制了您的服务器团队更新其TLS证书的能力。<strong>如果没有服务器的TLS管理员的同意，请勿使用证书锁定！</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CertificatePinning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  client = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">      .certificatePinner(<span class="keyword">new</span> CertificatePinner.Builder()</span><br><span class="line">          .add(<span class="string">"publicobject.com"</span>, <span class="string">"sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig="</span>)</span><br><span class="line">          .build())</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">      .url(<span class="string">"https://publicobject.com/robots.txt"</span>)</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">  Response response = client.newCall(request).execute();</span><br><span class="line">  <span class="keyword">if</span> (!response.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (Certificate certificate : response.handshake().peerCertificates()) &#123;</span><br><span class="line">    System.out.println(CertificatePinner.pin(certificate));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="自定义可信证书"><a href="#自定义可信证书" class="headerlink" title="自定义可信证书"></a>自定义可信证书</h4><p>完整的代码示例显示了如何用自己的集合替换主机平台的证书颁发机构。如上所述，<strong>请勿在没有服务器的TLS管理员同意的情况下使用自定义证书！</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CustomTrust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  SSLContext sslContext = sslContextForTrustedCertificates(trustedCertificatesInputStream());</span><br><span class="line">  client = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">      .sslSocketFactory(sslContext.getSocketFactory())</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">      .url(<span class="string">"https://publicobject.com/helloworld.txt"</span>)</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">  Response response = client.newCall(request).execute();</span><br><span class="line">  System.out.println(response.body().string());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> InputStream <span class="title">trustedCertificatesInputStream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ... <span class="comment">// Full source omitted. See sample.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> SSLContext <span class="title">sslContextForTrustedCertificates</span><span class="params">(InputStream in)</span> </span>&#123;</span><br><span class="line">  ... <span class="comment">// Full source omitted. See sample.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Events-事件监听"><a href="#Events-事件监听" class="headerlink" title="Events(事件监听)"></a>Events(事件监听)</h3><p>事件允许您在应用程序的HTTP调用中捕获度量值。使用事件进行监视：</p>
<ul>
<li>HTTP调用您的应用程序的大小和频率。如果你声明了太多的calls，或者你的calls太大，你应该知道它的一切</li>
<li>这些调用在底层网络上的性能。如果网络性能不足，则需要改善网络或少用网络。</li>
</ul>
<p><strong>警告：这是一个非最终的API。<br>从OkHttp 3.9开始，此功能是一个不稳定的预览：API可能会更改，并且实现不完整。我们预计OkHttp 3.10或3.11将完成这个API。在此之前，当您更新您的OkHttp依赖关系时，请准备API和行为更改。</strong></p>
<h4 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h4><p>子类<a href="https://square.github.io/okhttp/3.x/okhttp/okhttp3/EventListener.html" target="_blank" rel="noopener"> EventListener</a>,覆盖您感兴趣的事件的方法。在没有重定向或重试的成功HTTP调用中，事件序列由此流程描述。<br><img src="https://raw.githubusercontent.com/wiki/square/okhttp/events@2x.png" alt=""><br>以下是一个<a href="https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/PrintEventsNonConcurrent.java" target="_blank" rel="noopener">示例事件侦听器</a>，它使用时间戳打印每个事件。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintingEventListener</span> <span class="keyword">extends</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> callStartNanos;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printEvent</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> nowNanos = System.nanoTime();</span><br><span class="line">    <span class="keyword">if</span> (name.equals(<span class="string">"callStart"</span>)) &#123;</span><br><span class="line">      callStartNanos = nowNanos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> elapsedNanos = nowNanos - callStartNanos;</span><br><span class="line">    System.out.printf(<span class="string">"%.3f %s%n"</span>, elapsedNanos / <span class="number">1000000000</span>d, name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callStart</span><span class="params">(Call call)</span> </span>&#123;</span><br><span class="line">    printEvent(<span class="string">"callStart"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callEnd</span><span class="params">(Call call)</span> </span>&#123;</span><br><span class="line">    printEvent(<span class="string">"callEnd"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dnsStart</span><span class="params">(Call call, String domainName)</span> </span>&#123;</span><br><span class="line">    printEvent(<span class="string">"dnsStart"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dnsEnd</span><span class="params">(Call call, String domainName, List&lt;InetAddress&gt; inetAddressList)</span> </span>&#123;</span><br><span class="line">    printEvent(<span class="string">"dnsEnd"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们做几个calls：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">    .url(<span class="string">"https://publicobject.com/helloworld.txt"</span>)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"REQUEST 1 (new connection)"</span>);</span><br><span class="line"><span class="keyword">try</span> (Response response = client.newCall(request).execute()) &#123;</span><br><span class="line">  <span class="comment">// Consume and discard the response body.</span></span><br><span class="line">  response.body().source().readByteString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"REQUEST 2 (pooled connection)"</span>);</span><br><span class="line"><span class="keyword">try</span> (Response response = client.newCall(request).execute()) &#123;</span><br><span class="line">  <span class="comment">// Consume and discard the response body.</span></span><br><span class="line">  response.body().source().readByteString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>监听器打印相应的事件：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">REQUEST <span class="number">1</span> (<span class="keyword">new</span> connection)</span><br><span class="line"><span class="number">0.000</span> callStart</span><br><span class="line"><span class="number">0.010</span> dnsStart</span><br><span class="line"><span class="number">0.017</span> dnsEnd</span><br><span class="line"><span class="number">0.025</span> connectStart</span><br><span class="line"><span class="number">0.117</span> secureConnectStart</span><br><span class="line"><span class="number">0.586</span> secureConnectEnd</span><br><span class="line"><span class="number">0.586</span> connectEnd</span><br><span class="line"><span class="number">0.587</span> connectionAcquired</span><br><span class="line"><span class="number">0.588</span> requestHeadersStart</span><br><span class="line"><span class="number">0.590</span> requestHeadersEnd</span><br><span class="line"><span class="number">0.591</span> responseHeadersStart</span><br><span class="line"><span class="number">0.675</span> responseHeadersEnd</span><br><span class="line"><span class="number">0.676</span> responseBodyStart</span><br><span class="line"><span class="number">0.679</span> responseBodyEnd</span><br><span class="line"><span class="number">0.679</span> connectionReleased</span><br><span class="line"><span class="number">0.680</span> callEnd</span><br><span class="line">REQUEST <span class="number">2</span> (pooled connection)</span><br><span class="line"><span class="number">0.000</span> callStart</span><br><span class="line"><span class="number">0.001</span> connectionAcquired</span><br><span class="line"><span class="number">0.001</span> requestHeadersStart</span><br><span class="line"><span class="number">0.001</span> requestHeadersEnd</span><br><span class="line"><span class="number">0.002</span> responseHeadersStart</span><br><span class="line"><span class="number">0.082</span> responseHeadersEnd</span><br><span class="line"><span class="number">0.082</span> responseBodyStart</span><br><span class="line"><span class="number">0.082</span> responseBodyEnd</span><br><span class="line"><span class="number">0.083</span> connectionReleased</span><br><span class="line"><span class="number">0.083</span> callEnd</span><br></pre></td></tr></table></figure></p>
<p>注意第二次调用没有连接事件。它重用了第一个请求的连接，以显着提高性能。</p>
<h4 id="EventListener-Factory"><a href="#EventListener-Factory" class="headerlink" title="EventListener.Factory"></a>EventListener.Factory</h4><p>在前面的例子中，我们使用了一个字段<code>callStartNanos</code>来跟踪每个事件的经过时间。这很方便，但是如果多个调用同时执行，它将不起作用。为了适应这个，使用一个<code>Factory</code>创建一个新的<code>EventListener</code>为每个<code>Call</code>。这允许每个监听者保持特定于呼叫的状态。</p>
<p>此<a href="https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/PrintEvents.java" target="_blank" rel="noopener">示例工厂</a>为每个呼叫创建一个唯一的ID，并使用该ID区分日志消息中的呼叫。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintingEventListener</span> <span class="keyword">extends</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Factory FACTORY = <span class="keyword">new</span> Factory() &#123;</span><br><span class="line">    <span class="keyword">final</span> AtomicLong nextCallId = <span class="keyword">new</span> AtomicLong(<span class="number">1L</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> EventListener <span class="title">create</span><span class="params">(Call call)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">long</span> callId = nextCallId.getAndIncrement();</span><br><span class="line">      System.out.printf(<span class="string">"%04d %s%n"</span>, callId, call.request().url());</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> PrintingEventListener(callId, System.nanoTime());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">long</span> callId;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">long</span> callStartNanos;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PrintingEventListener</span><span class="params">(<span class="keyword">long</span> callId, <span class="keyword">long</span> callStartNanos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.callId = callId;</span><br><span class="line">    <span class="keyword">this</span>.callStartNanos = callStartNanos;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printEvent</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> elapsedNanos = System.nanoTime() - callStartNanos;</span><br><span class="line">    System.out.printf(<span class="string">"%04d %.3f %s%n"</span>, callId, elapsedNanos / <span class="number">1000000000</span>d, name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callStart</span><span class="params">(Call call)</span> </span>&#123;</span><br><span class="line">    printEvent(<span class="string">"callStart"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callEnd</span><span class="params">(Call call)</span> </span>&#123;</span><br><span class="line">    printEvent(<span class="string">"callEnd"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以使用这个侦听器来竞争一对并发的HTTP请求：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Request washingtonPostRequest = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">    .url(<span class="string">"https://www.washingtonpost.com/"</span>)</span><br><span class="line">    .build();</span><br><span class="line">client.newCall(washingtonPostRequest).enqueue(<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Request newYorkTimesRequest = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">    .url(<span class="string">"https://www.nytimes.com/"</span>)</span><br><span class="line">    .build();</span><br><span class="line">client.newCall(newYorkTimesRequest).enqueue(<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>运行这场比赛的家庭无线网络显示，Times（<code>0002</code>）比Post（<code>0001</code>）略快一点：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0001</span> https:<span class="comment">//www.washingtonpost.com/</span></span><br><span class="line"><span class="number">0001</span> <span class="number">0.000</span> callStart</span><br><span class="line"><span class="number">0002</span> https:<span class="comment">//www.nytimes.com/</span></span><br><span class="line"><span class="number">0002</span> <span class="number">0.000</span> callStart</span><br><span class="line"><span class="number">0002</span> <span class="number">0.010</span> dnsStart</span><br><span class="line"><span class="number">0001</span> <span class="number">0.013</span> dnsStart</span><br><span class="line"><span class="number">0001</span> <span class="number">0.022</span> dnsEnd</span><br><span class="line"><span class="number">0002</span> <span class="number">0.019</span> dnsEnd</span><br><span class="line"><span class="number">0001</span> <span class="number">0.028</span> connectStart</span><br><span class="line"><span class="number">0002</span> <span class="number">0.025</span> connectStart</span><br><span class="line"><span class="number">0002</span> <span class="number">0.072</span> secureConnectStart</span><br><span class="line"><span class="number">0001</span> <span class="number">0.075</span> secureConnectStart</span><br><span class="line"><span class="number">0001</span> <span class="number">0.386</span> secureConnectEnd</span><br><span class="line"><span class="number">0002</span> <span class="number">0.390</span> secureConnectEnd</span><br><span class="line"><span class="number">0002</span> <span class="number">0.400</span> connectEnd</span><br><span class="line"><span class="number">0001</span> <span class="number">0.403</span> connectEnd</span><br><span class="line"><span class="number">0002</span> <span class="number">0.401</span> connectionAcquired</span><br><span class="line"><span class="number">0001</span> <span class="number">0.404</span> connectionAcquired</span><br><span class="line"><span class="number">0001</span> <span class="number">0.406</span> requestHeadersStart</span><br><span class="line"><span class="number">0002</span> <span class="number">0.403</span> requestHeadersStart</span><br><span class="line"><span class="number">0001</span> <span class="number">0.414</span> requestHeadersEnd</span><br><span class="line"><span class="number">0002</span> <span class="number">0.411</span> requestHeadersEnd</span><br><span class="line"><span class="number">0002</span> <span class="number">0.412</span> responseHeadersStart</span><br><span class="line"><span class="number">0001</span> <span class="number">0.415</span> responseHeadersStart</span><br><span class="line"><span class="number">0002</span> <span class="number">0.474</span> responseHeadersEnd</span><br><span class="line"><span class="number">0002</span> <span class="number">0.475</span> responseBodyStart</span><br><span class="line"><span class="number">0001</span> <span class="number">0.554</span> responseHeadersEnd</span><br><span class="line"><span class="number">0001</span> <span class="number">0.555</span> responseBodyStart</span><br><span class="line"><span class="number">0002</span> <span class="number">0.554</span> responseBodyEnd</span><br><span class="line"><span class="number">0002</span> <span class="number">0.554</span> connectionReleased</span><br><span class="line"><span class="number">0002</span> <span class="number">0.554</span> callEnd</span><br><span class="line"><span class="number">0001</span> <span class="number">0.624</span> responseBodyEnd</span><br><span class="line"><span class="number">0001</span> <span class="number">0.624</span> connectionReleased</span><br><span class="line"><span class="number">0001</span> <span class="number">0.624</span> callEnd</span><br></pre></td></tr></table></figure></p>
<p>该<code>EventListener.Factory</code>还能够指标限制呼叫的子集。这一个随机捕获指标为10％：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MetricsEventListener</span> <span class="keyword">extends</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Factory FACTORY = <span class="keyword">new</span> Factory() &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> EventListener <span class="title">create</span><span class="params">(Call call)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (Math.random() &lt; <span class="number">0.10</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MetricsEventListener(call);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> EventListener.NONE;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="事件与失败"><a href="#事件与失败" class="headerlink" title="事件与失败"></a>事件与失败</h4><p>当操作失败时，调用失败方法。这是<code>connectFailed()</code>在建立到服务器的连接<code>callFailed()</code>时，以及HTTP调用永久失败时的失败。发生故障时，<code>start</code>事件可能没有相应的<code>end</code>事件。<br><img src="https://raw.githubusercontent.com/wiki/square/okhttp/events_with_failures@2x.png" alt=""></p>
<h4 id="事件与重试和跟进"><a href="#事件与重试和跟进" class="headerlink" title="事件与重试和跟进"></a>事件与重试和跟进</h4><p>OkHttp具有弹性，可以自动从一些连接失败中恢复。在这种情况下，<code>connectFailed()</code>事件不是终端，也不是随之而来的<code>callFailed()</code>。当尝试重试时，事件监听器将收到多个相同类型的事件。</p>
<p>单个HTTP调用可能需要后续请求来处理认证挑战，重定向和HTTP层超时。在这种情况下，可能会尝试多个连接，请求和响应。跟进是单个电话可能触发多个相同类型事件的另一个原因。<br><img src="https://raw.githubusercontent.com/wiki/square/okhttp/events_with_failures_and_retries@2x.png" alt=""></p>
<h4 id="可用性-1"><a href="#可用性-1" class="headerlink" title="可用性"></a>可用性</h4><p>OkHttp 3.9中的预览版本提供了事件。我们预计OkHttp 3.10或3.11将完成这个API。未来版本可能会引入新的事件类型; 您将需要覆盖相应的方法来处理它们。</p>
<h3 id="FAQs-常见问题解答"><a href="#FAQs-常见问题解答" class="headerlink" title="FAQs(常见问题解答))"></a>FAQs(常见问题解答))</h3><h4 id="如何修复dalvikvm中的验证警告？"><a href="#如何修复dalvikvm中的验证警告？" class="headerlink" title="如何修复dalvikvm中的验证警告？"></a>如何修复dalvikvm中的验证警告？</h4><p>OkHttp支持一些需要Java 7+或Android API 20+的API。如果你在早期的Android版本上运行OkHttp，dalvikvm的验证器会警告你缺少的方法。这不是一个问题，你可以忽略警告。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">I/dalvikvm﹕ Could not find method okhttp3.internal.huc.HttpURLConnectionImpl.getContentLengthLong, referenced from method okhttp3.internal.huc.HttpsURLConnectionImpl.getContentLengthLong</span><br><span class="line">W/dalvikvm﹕ VFY: unable to resolve virtual method <span class="number">21498</span>: Lokhttp3/internal/huc/HttpURLConnectionImpl;.getContentLengthLong ()J</span><br><span class="line">D/dalvikvm﹕ VFY: replacing opcode <span class="number">0x6e</span> at <span class="number">0x0002</span></span><br><span class="line">I/dalvikvm﹕ Could not find method okhttp3.internal.huc.HttpURLConnectionImpl.getHeaderFieldLong, referenced from method okhttp3.internal.huc.HttpsURLConnectionImpl.getHeaderFieldLong</span><br><span class="line">W/dalvikvm﹕ VFY: unable to resolve virtual method <span class="number">21503</span>: Lokhttp3/internal/huc/HttpURLConnectionImpl;.getHeaderFieldLong (Ljava/lang/String;J)J</span><br><span class="line">D/dalvikvm﹕ VFY: replacing opcode <span class="number">0x6e</span> at <span class="number">0x0002</span></span><br><span class="line">W/dalvikvm﹕ VFY: <span class="function">unable to find class referenced in <span class="title">signature</span> <span class="params">(Ljava/nio/file/Path;)</span></span></span><br><span class="line"><span class="function">W/dalvikvm﹕ VFY: unable to find class referenced in <span class="title">signature</span> <span class="params">([Ljava/nio/file/OpenOption;)</span></span></span><br><span class="line"><span class="function">I/dalvikvm﹕ Could not find method java.nio.file.Files.newOutputStream, referenced from method okio.Okio.sink</span></span><br><span class="line"><span class="function">W/dalvikvm﹕ VFY: unable to resolve <span class="keyword">static</span> method 24080: Ljava/nio/file/Files</span>;.newOutputStream (Ljava/nio/file/Path;[Ljava/nio/file/OpenOption;)Ljava/io/OutputStream;</span><br><span class="line">D/dalvikvm﹕ VFY: replacing opcode <span class="number">0x71</span> at <span class="number">0x000a</span></span><br><span class="line">W/dalvikvm﹕ VFY: <span class="function">unable to find class referenced in <span class="title">signature</span> <span class="params">(Ljava/nio/file/Path;)</span></span></span><br><span class="line"><span class="function">W/dalvikvm﹕ VFY: unable to find class referenced in <span class="title">signature</span> <span class="params">([Ljava/nio/file/OpenOption;)</span></span></span><br><span class="line"><span class="function">I/dalvikvm﹕ Could not find method java.nio.file.Files.newInputStream, referenced from method okio.Okio.source</span></span><br><span class="line"><span class="function">W/dalvikvm﹕ VFY: unable to resolve <span class="keyword">static</span> method 24079: Ljava/nio/file/Files</span>;.newInputStream (Ljava/nio/file/Path;[Ljava/nio/file/OpenOption;)Ljava/io/InputStream;</span><br><span class="line">D/dalvikvm﹕ VFY: replacing opcode <span class="number">0x71</span> at <span class="number">0x000a</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 安卓开源库使用教程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> okhttp3 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Studio使用技巧和资源]]></title>
      <url>/AndroidStudio_uses_skills_and_resources.html</url>
      <content type="html"><![CDATA[<p><strong>版权声明：本文转载自:<br><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/1116/6776.html" target="_blank" rel="noopener">http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/1116/6776.html</a>.<br>版权归原作者所有</strong></p>
<hr>
<blockquote>
<p>对于AndroidStudio的使用，日常使用没问题，但依旧有些快捷技巧没有习惯使用,因此转载本篇文章常读，希望对文章的技巧有些记忆，做到以后的熟练使用</p>
</blockquote>
<a id="more"></a>
<p>本文列举出一些可以提高整体效率的Android Studio技巧和资源。</p>
<p>显然有太多太多这方面的东西，但是为了文章的简洁性，我把它限制在50个以内，希望你能喜欢！</p>
<h3 id="视觉效果"><a href="#视觉效果" class="headerlink" title="视觉效果"></a>视觉效果</h3><p><strong>1.Android Logcat的Material颜色主题。</strong><br><img src="http://www.jcodecraeer.com/uploads/20161114/1479092916140309.png" alt=""><br>要改变Android Studio的Logcat你需要这样做：进入Preferences (Windows上是Settings / Linux machines) → Editor → Colors &amp; Fonts → Android Logcat，然后为每种类型的log设置前景颜色（foreground）。</p>
<p>我使用的material颜色：</p>
<p>Assert #BA68C8<br>Debug #2196F3<br>Error #F44336<br>Info #4CAF50<br>Verbose #BBBBBB<br>Warning #FF9800<br>注意里面有几个现有的主题，可以直接修改现有主题（不建议），或者点击save  as按钮拷贝一个主题并改名为Material theme Color然后再改变每种类型log的颜色。</p>
<p><strong>2.防止当前应用崩溃时Logcat清除log。</strong></p>
<p>在Android Monitor面板的右上方点击下拉菜单中的Edit filter configuration：<br><img src="http://www.jcodecraeer.com/uploads/20161114/1479110913240289.gif" alt=""><br>注意是在工程界面的底部Android Monitor面板，而不是单独的Android Monitor工具中。</p>
<p><strong>3.使用一个适合自己的代码主题 (IntelliJ / Android Studio).</strong></p>
<p>找到Preferences → Code Style → Java，在Scheme下拉菜单中你可以选择一个代码风格（或者设置一个新的）。</p>
<p>有两个风格值得专门提一下：</p>
<ul>
<li><a href="https://github.com/square/java-code-styles" target="_blank" rel="noopener">Square Java Code Styles with Android</a></li>
<li><a href="https://github.com/google/styleguide/blob/gh-pages/intellij-java-google-style.xml" target="_blank" rel="noopener">Google Java Code Style</a></li>
</ul>
<p>你可以按照下面gif图中的做法导入主题：<br><img src="http://www.jcodecraeer.com/uploads/20161115/1479152735132116.gif" alt=""></p>
<p><strong>.使用分屏提高效率</strong><br><img src="http://www.jcodecraeer.com/uploads/20161115/1479184670241838.png" alt=""></p>
<p>要打开这个功能，右键主屏幕的选项卡（tab）选择 Split Vertically / Horizontally。<br><img src="http://www.jcodecraeer.com/uploads/20161115/1479185280137120.png" alt=""><br>但是为了尽量提高效率我们需要设置一个自定义的快捷方式。为此找到到Preferences → Keymap，搜索Split Vertically。然后打开一个上下文菜单，点击Add Keyboard Shortcut。</p>
<p>我的分屏（vertical）快捷键设置的是control + alt + v。做法如下面的gif图所示。同样的你还可以为 horizontal split设置快捷键。<br><img src="http://www.jcodecraeer.com/uploads/20161115/1479186609392277.gif" alt=""></p>
<p><strong>5.无干扰模式</strong><br>你可以到View → Enter Distraction Free Mode里启用它<br><img src="http://www.jcodecraeer.com/uploads/20161115/1479186797587469.png" alt=""></p>
<blockquote>
<p>在无干扰模式下，编辑器占据了整个IntelliJIDEA窗口，没有任何tab或者工具按钮。代码居中显示<br><img src="http://www.jcodecraeer.com/uploads/20161115/1479187051576195.png" alt=""></p>
</blockquote>
<p><strong>6.使用Live Templates</strong></p>
<ul>
<li>你可以使用快捷键：cmd + j (Windows / Linux: ctrl + j)。<br><img src="http://www.jcodecraeer.com/uploads/20161115/1479207132117532.gif" alt=""></li>
<li>可以使用已经定义好了的Live Templates，比如Toasts 或者if语句。<br><img src="http://www.jcodecraeer.com/uploads/20161115/1479207307260987.gif" alt=""></li>
<li>可以使用自定义的templates。这里是Reto Meier的一篇不错的参考文章。你也可以参考<a href="https://www.jetbrains.com/help/idea/2016.2/live-templates.html" target="_blank" rel="noopener">IntelliJ IDEA</a>的文档.</li>
</ul>
<h3 id="快捷键以及有用的命令"><a href="#快捷键以及有用的命令" class="headerlink" title="快捷键以及有用的命令"></a>快捷键以及有用的命令</h3><p>1.最有用的命令是搜索命令的命令：cmd + shift + a (Windows / Linux: ctrl + shift + a)。</p>
<p>假设你想关闭当前tab却不知道怎么做，你只需输入close你就可以得到一个正确的快捷键/命令。</p>
<p>2.选择最近的复制粘贴（管理剪切版）：cmd + shift + v (Windows / Linux: ctrl + shift + v)。<br>默认有5个最近的复制/粘贴元素。<br><img src="http://www.jcodecraeer.com/uploads/20161115/1479209676110910.png" alt=""></p>
<p>3.启用多光标功能：control + g (alt + j for Windows / Linux)。<br><img src="http://www.jcodecraeer.com/uploads/20161115/1479209848645605.gif" alt=""></p>
<p>4.打开一个类： cmd + o (Windows / Linux: ctrl + n)。</p>
<p>5.打开任意文件： cmd + shift + o (Windows / Linux: ctrl + shift + n)。</p>
<p>6.打开symbol：cmd + option + o (Windows / Linux: alt + shift + n)。</p>
<p>7.跳到实现：cmd + option + b (Windows / Linux:<br>ctrl + alt + b)。</p>
<p>假如你有一个interface。通过点击接口的名字，然后按下快捷键就可以跳转到这个接口的实现。如果有多个实现会出现下拉选择。</p>
<p>8.跳转到定义：cmd + b (Windows / Linux: ctrl + b)。</p>
<p>可以让你快速跳转到一个类，方法或者变量被定义的地方。</p>
<p>9.跳转到类型定义处：control + shift + b (Windows / Linux:<br>ctrl + shift + b)。</p>
<p>假设你定义了：</p>
<p>Employee employee = new Employee(“Michal”);</p>
<p>当你的插入符号在employee上，这时你按下快捷键，你将跳转到Employee类中。</p>
<p>10.跳转到super： cmd + u (Windows / Linux: ctrl + u)。</p>
<p>比如，你重写了一些方法,当你的插入符号在方法名上，按下这个快捷键你将跳转到parent的这个方法。</p>
<p>11.Move between tabs: cmd + shift + <a href="move right"> (move left) or cmd + shift + </a> (Windows / Linux: alt + ← / →).</p>
<p>12 Move between Design / Text tabs in layout’s view:<br>control + shift + ← / → (Windows / Linux: alt + shift + ← / →).</p>
<p>13.关闭当前的tab：cmd + w (Windows / Linux: ctrl + shift + a)。</p>
<p>14.隐藏所有窗口：cmd + shift + F12 (Windows / Linux:<br>ctrl + shift + F12)。</p>
<p>15.最小化 Android Studio instance: cmd + m (Windows / Linux:<br>ctrl + m)。</p>
<p>16.格式化代码: cmd + option + l (Windows / Linux:<br>ctrl + alt + l)。</p>
<p>17.Auto-indent lines: control + option + i (Windows / Linux:<br>ctrl + alt + i).</p>
<p>18.实现接口的方法: control + i (Windows / Linux: ctrl + i)。</p>
<p>假设你要实现一个接口。这个快捷键可以让你快速导入这个接口的所有方法。</p>
<p>19.Smart code completion (filters the list of methods and variables by expected type): control + shift + space (Windows / Linux: ctrl + shift + space).</p>
<p>20.查找: cmd + f (Windows / Linux: ctrl + f)。</p>
<p>21.查找并替换: cmd + r (Windows / Linux: ctrl + r)。</p>
<p>22.把一个硬编码的字符串放到资源文件中：option + return (Windows / Linux: alt + enter)。光标必须在这个文字之上时才能使用这个快捷键。看下面的gif图：<br><img src="http://www.jcodecraeer.com/uploads/20161116/1479268452113436.gif" alt=""></p>
<h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>1.<a href="https://plugins.jetbrains.com/plugin/4455" target="_blank" rel="noopener">Key promoter</a> - 快捷键提示插件 当你点击鼠标一个功能的时候,可以提示 你这个功能快捷键是什么 ,和这个按钮你的使用频率 </p>
<p>2.<a href="https://plugins.jetbrains.com/plugin/2162" target="_blank" rel="noopener">String Manipulation</a> - a plugin which provides actions for text manipulation (e.g. toggling styles like camelCase, hyphen-lowercase etc., capitalize text and many more).</p>
<p>3.<a href="https://github.com/konifar/android-material-design-icon-generator-plugin" target="_blank" rel="noopener">Android Material Design Icon Generator</a> -这个插件帮助你为工程添加Material Design图标。安装之后使用快捷键cmd + shift + m生成一个图标。</p>
<p>4.<a href="https://github.com/avast/android-butterknife-zelezny" target="_blank" rel="noopener">ButterKnifeZelezny</a> - 一键从 布局文件中 生成对于的 View 声明和 ButterKnife 注解：<br><img src="http://www.jcodecraeer.com/uploads/20161116/1479269691116405.gif" alt=""></p>
<p>5.<a href="https://github.com/mcharmas/android-parcelable-intellij-plugin" target="_blank" rel="noopener">IntelliJ/Android Studio Plugin for Android Parcelable boilerplate code generation</a> - 一个根据类的成员生成Parcelable的插件。</p>
<p>6.<a href="https://github.com/pbreault/adb-idea" target="_blank" rel="noopener">ADB Idea</a> - 一个帮助你使用adb命令的插件：卸载，杀死，启动，重启，清除数据等命令。</p>
<p>7.<a href="https://www.genymotion.com/plugins/" target="_blank" rel="noopener">Genymotion plugin</a> - 一个让你可以在Android Studio中创建和开启Genymotion虚拟设备的插件。</p>
<p>8.<a href="http://www.methodscount.com/plugins" target="_blank" rel="noopener">Android Methods Count</a> - a plugin that parses your Android library dependencies and shows the methods count as an handy hint.</p>
<p>9.<a href="https://plugins.jetbrains.com/plugin/7315" target="_blank" rel="noopener">Git Flow Integration</a> - a plugin for introducing a Git Flow branching model.</p>
<p>10.<a href="https://plugins.jetbrains.com/plugin/7567" target="_blank" rel="noopener">Builder plugin</a> - a plugin (from Square) that generates a static nested Builder for a class.</p>
<h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p>1.<a href="">Android Studio Tips of the Day by Philippe Breault</a><br>2.<a href="https://developer.android.com/studio/intro/keyboard-shortcuts.html" target="_blank" rel="noopener">快捷键参考</a><br>3.<a href="http://www.jcodecraeer.com/a/anzhuokaifa/Android_Studio/2016/0424/4172.html" target="_blank" rel="noopener">(About) 10 Things You (Probably) Didn’t Know You Could do in Android Studio by Reto Meier。中文版：10个你可能不知道的 Android Studio技巧。 </a><br>4.<a href="https://vimeo.com/98922030
5.[Android Studio Like a Boss by Philippe Breault](https://realm.io/news/360andev-philippe-breault-android-studio-ide-like-boss-structural-search-refactoring-java/" target="_blank" rel="noopener">无鼠标开发 by Hadi Hariri</a><br>6.<a href="https://www.youtube.com/watch?v=Y2GC6P5hPeA" target="_blank" rel="noopener">Android Studio for Experts (Android Dev Summit 2015)</a><br>7.<a href="http://michaelevans.org/blog/2016/01/06/android-studio-tips-and-tricks/" target="_blank" rel="noopener">Android Studio Tips and Tricks by Michael Evans</a><br>8.<a href="https://developer.android.com/studio/intro/index.html" target="_blank" rel="noopener">认识 Android Studio</a><br>9.<a href="http://www.donnfelker.com/android-studio-tips-and-tricks-part-1/" target="_blank" rel="noopener">Android Studio - Tips and Tricks by Donn Felker</a><br>10.<a href="https://developer.android.com/studio/debug/index.html" target="_blank" rel="noopener">Debug Your App with Android Studio</a><br>11.<a href="https://www.reddit.com/r/androiddev/comments/3ktqyb/what_are_some_of_your_musthave_plugins_for/" target="_blank" rel="noopener">What are some of your must-have plugins for - Reddit discussion</a></p>
]]></content>
      
        <categories>
            
            <category> AndroidStudio </category>
            
        </categories>
        
        
        <tags>
            
            <tag> AndroidStudio </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android5.0新控件学习]]></title>
      <url>/Android5-0-control-study-AppBarLayout-Toolbar-CoordinateLayout-cardView.html</url>
      <content type="html"><![CDATA[<p><strong>版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起.</strong></p>
<hr>
<blockquote>
<p>本文记录一些Androd5.0的新控件的一些学习总结，由于网上的博文总结的比较全面，我就不写博文总结了，这里主要是列举一些控件的学习资料</p>
</blockquote>
<a id="more"></a>
<h3 id="CoordinateLayout"><a href="#CoordinateLayout" class="headerlink" title="CoordinateLayout"></a>CoordinateLayout</h3><p>简介：协调布局,配合<code>Behavior</code>使用，特点是能根据一个<code>View</code>的动作协调另一个<code>View</code>的动作。<br>参考文章:<a href="https://www.jianshu.com/p/72d45d1f7d55" target="_blank" rel="noopener">CoordinatorLayout的使用如此简单</a></p>
<h3 id="ToolBar"><a href="#ToolBar" class="headerlink" title="ToolBar"></a>ToolBar</h3><p>简介：代替<code>ActionBar</code>，比它更加的灵活，实质是一个<code>ViewGroup</code></p>
<p>参考资料:<a href="http://blog.csdn.net/lmj623565791/article/details/45303349" target="_blank" rel="noopener">Android 5.x Theme 与 ToolBar 实战</a><br><a href="http://blog.csdn.net/kebi007/article/details/71247295" target="_blank" rel="noopener">xamarin android toolbar(踩坑完全入门详解)</a></p>
<h3 id="AppBarLayout"><a href="#AppBarLayout" class="headerlink" title="AppBarLayout"></a>AppBarLayout</h3><p>简介：继承自<code>LinearLayout</code>,它可以让你定制当某个可滚动<code>View</code>手势发生变化时，其内部子<code>View</code>会实现何种动作.</p>
<h3 id="CollapsingToolbarLayout"><a href="#CollapsingToolbarLayout" class="headerlink" title="CollapsingToolbarLayout"></a>CollapsingToolbarLayout</h3><p>简介：用来对<code>ToolBar</code>进行再次包装的<code>ViewGroup</code>，可以实现一些折叠的效果（更像是缩放），比如向上滑动标题文字逐渐缩小至左上角，它需要作为<code>AppBarLayout</code>布局里面并作为它的直接子<code>View</code>.</p>
<h3 id="NestedScrollView"><a href="#NestedScrollView" class="headerlink" title="NestedScrollView"></a>NestedScrollView</h3><p>简介：为了配合<code>AppBarLayout</code>的滚动效果而编写的滚动控件，继承自<code>FrameLayout</code>,随后使用<code>appbar_scrolling_view_behavior</code>即可实现相应的效果</p>
<p>参考文章:<a href="https://www.jianshu.com/p/d159f0176576" target="_blank" rel="noopener">玩转AppBarLayout，更酷炫的顶部栏</a></p>
<h3 id="CardView"><a href="#CardView" class="headerlink" title="CardView"></a>CardView</h3><p>简介：卡片布局，继承自<code>FrameLayout</code>，可实现阴影效果,通常与<code>RecycleView</code>或<code>ListView</code>配合使用作为<code>item</code>的容器<br>参考资料:<a href="https://www.jianshu.com/p/33b1d21d6ba6" target="_blank" rel="noopener">CardView的基本用法</a></p>
<h3 id="RecyclerView"><a href="#RecyclerView" class="headerlink" title="RecyclerView"></a>RecyclerView</h3><p>简介：比<code>ListView</code>更加灵活，更低耦合的列表展示控件，可轻易实现<code>ListView</code>,<code>GridView</code>,和瀑布流的效果</p>
<p>参考资料:<a href="http://blog.csdn.net/lmj623565791/article/details/45059587" target="_blank" rel="noopener"> Android RecyclerView 使用完全解析 体验艺术般的控件</a></p>
<h3 id="FloatingActionButton"><a href="#FloatingActionButton" class="headerlink" title="FloatingActionButton"></a>FloatingActionButton</h3><p>简介：用来在界面上显示一个悬浮的按钮<br>参考资料：<a href="http://blog.csdn.net/lmj623565791/article/details/46678867" target="_blank" rel="noopener">FloatingActionButton 完全解析[Design Support Library(2)]</a></p>
<h3 id="TextInputLayout"><a href="#TextInputLayout" class="headerlink" title="TextInputLayout"></a>TextInputLayout</h3><p>简介：通常与<code>EditText</code>配合使用，能在<code>EditText</code>输入时将<code>hint</code>放入到上方，还具有空校验的功能</p>
<p>参考资料：<br><a href="https://www.jianshu.com/p/c06b2a41f611" target="_blank" rel="noopener">TextInputlayout入门讲解</a><br><a href="http://blog.csdn.net/u011051627/article/details/48177095" target="_blank" rel="noopener">Android Design TextInputLayout 解析,带你深入TextInputLayout</a></p>
<h3 id="TabLayout"><a href="#TabLayout" class="headerlink" title="TabLayout"></a>TabLayout</h3><p>简介：提供一个水平的布局来展示<code>TAB</code></p>
<p>参考资料：<br><a href="https://www.jianshu.com/p/2b2bb6be83a8" target="_blank" rel="noopener">Design库-TabLayout属性详解</a><br><a href="https://www.jianshu.com/p/be1e8a1da639?nomobile=yes" target="_blank" rel="noopener">TabLayout的高端用法</a></p>
<h3 id="NavigationView"><a href="#NavigationView" class="headerlink" title="NavigationView"></a>NavigationView</h3><p>简介:在<code>Material Design</code>中，<code>Navigation drawer</code>导航抽屉，被设计用于应用导航，提供了一种通用的导航方式，体现了设计的一致性。<br>而<code>NavigationView</code>的典型用途就是配合之前v4包的<code>DrawerLayout</code>，作为其中的<code>Drawer</code>部分，即导航菜单的本体部分。<code>NavigationView</code>是一个导航菜单框架，使用<code>menu</code>资源填充数据，使我们可以更简单高效的实现导航菜单。它提供了不错的默认样式、选中项高亮、分组单选、分组子标题、以及可选的<code>Header</code>。</p>
<p>参考资料：<a href="http://blog.csdn.net/u012702547/article/details/51253222" target="_blank" rel="noopener"> Android5.0之NavigationView的使用</a></p>
<h3 id="Snackbar"><a href="#Snackbar" class="headerlink" title="Snackbar"></a>Snackbar</h3><p>简介：与<code>Toast</code>相似,弹出一个提示框</p>
<p>参考资料：<a href="https://www.jianshu.com/p/cd1e80e64311/" target="_blank" rel="noopener">没时间解释了，快使用Snackbar!——Android Snackbar花式使用指南
</a></p>
<h3 id="Palette"><a href="#Palette" class="headerlink" title="Palette"></a>Palette</h3><p>简介：取色器，从图片中提取关键的颜色，并将该颜色设置到别的控件上,可以和<code>ToolBar</code>配合使用动态改变颜色<br>参考资料:<br><a href="http://blog.csdn.net/u013278099/article/details/49887463" target="_blank" rel="noopener">安卓5.x的Palette之你不知道的事</a></p>
<p><a href="http://blog.csdn.net/bbld_/article/details/41439715" target="_blank" rel="noopener">Android Material Design之Toolbar与Palette实践</a></p>
<h3 id="RippleDrawable"><a href="#RippleDrawable" class="headerlink" title="RippleDrawable"></a>RippleDrawable</h3><p>简介：5.0以上的涟漪效果,需要兼容5.0以下需要使用开源库<a href="https://github.com/traex/RippleEffect" target="_blank" rel="noopener">RippleEffect</a>.<br>参考资料：<a href="http://blog.csdn.net/oqihaogongyuan/article/details/53102615" target="_blank" rel="noopener">Material Design之RippleDrawable详解</a></p>
]]></content>
      
        <categories>
            
            <category> Android基础进阶 </category>
            
            <category> 安卓控件 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android5.0 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一些关于安卓非编码问题的解决方案记录]]></title>
      <url>/%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8E%E5%AE%89%E5%8D%93%E9%9D%9E%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E8%AE%B0%E5%BD%95.html</url>
      <content type="html"><![CDATA[<p><strong>版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起.</strong></p>
<hr>
<blockquote>
<p>安卓的一些非编码问题的一些解决方案记录，如打包，加密等..</p>
</blockquote>
<a id="more"></a>
<h3 id="安卓自动化打包发布工作流-签名加密"><a href="#安卓自动化打包发布工作流-签名加密" class="headerlink" title="安卓自动化打包发布工作流,签名加密"></a>安卓自动化打包发布工作流,签名加密</h3><p>解决方案：<br>可使用Travis CI项目框架</p>
<p>未自动化前安卓开发的工作流程：</p>
<ol>
<li>开发一些新功能，提交代码</li>
<li>完成一部分功能后，打包一个测试版APK</li>
<li>将测试版APK上传到QQ群 / 网盘 / Fir.im / 蒲公英等</li>
<li>在QQ群或发布平台解释当前版本所完成的功能</li>
<li>通知测试人员测试</li>
</ol>
<p>实现了这套自动化发布后，工作流程被简化成：</p>
<ol>
<li>开发新功能，提交代码</li>
<li>通过git tag对代码打一个内测版的tag，在tag的描述中对写当前完成的功能</li>
</ol>
<p>此外还支持签名加密：<br>加密前:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    signingConfigs &#123;</span><br><span class="line">        releaseConfig &#123;</span><br><span class="line">            storeFile file(&quot;../keys/evandroid.jks&quot;)</span><br><span class="line">            storePassword &quot;123456&quot;</span><br><span class="line">            keyAlias &quot;evandroid_alias&quot;</span><br><span class="line">            keyPassword &quot;654321&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled false</span><br><span class="line">            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;</span><br><span class="line">            signingConfig signingConfigs.releaseConfig</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>加密后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">releaseConfig &#123;</span><br><span class="line">    storeFile file(&quot;../keys/evandroid.jks&quot;)</span><br><span class="line">    storePassword project.hasProperty(&quot;KEYSTORE_PASS&quot;) ? KEYSTORE_PASS : System.getenv(&quot;KEYSTORE_PASS&quot;)</span><br><span class="line">    keyAlias project.hasProperty(&quot;ALIAS_NAME&quot;) ? ALIAS_NAME : System.getenv(&quot;ALIAS_NAME&quot;)</span><br><span class="line">    keyPassword project.hasProperty(&quot;ALIAS_PASS&quot;) ? ALIAS_PASS : System.getenv(&quot;ALIAS_PASS&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>密钥完全从后台获取</p>
<p>关于<a href="https://travis-ci.org/" target="_blank" rel="noopener">Travis CI</a>的资料:</p>
<ul>
<li><a href="https://avnpc.com/pages/android-auto-deploy-workflow-on-travis-ci" target="_blank" rel="noopener">基于Travis CI搭建Android自动打包发布工作流（支持Github Release及fir.im)</a></li>
</ul>
<h3 id="安卓多渠道打包-同时打900个渠道包怎么办？？？"><a href="#安卓多渠道打包-同时打900个渠道包怎么办？？？" class="headerlink" title="安卓多渠道打包(同时打900个渠道包怎么办？？？)"></a>安卓多渠道打包(同时打900个渠道包怎么办？？？)</h3><p>解决方案：<br>V1签名下的快速打包工具：<a href="https://github.com/GavinCT/AndroidMultiChannelBuildTool" target="_blank" rel="noopener">AndroidMultiChannelBuildTool</a></p>
<p>不管多少渠道包，分分钟打完。</p>
<p>V2签名打包:<br>如果公司需要升级到V2签名,那么上面那个就不在适用，请移步到这个:<a href="https://github.com/Meituan-Dianping/walle" target="_blank" rel="noopener">walle</a>,美团针对V2签名设计的打包工具，不过使用方式与上面的那个不同，需要在项目中添加插件并用Gradle构建打包.</p>
]]></content>
      
        <categories>
            
            <category> 安卓杂记 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[objectBox数据库使用教程]]></title>
      <url>/objectBox%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B-objectbox-java.html</url>
      <content type="html"><![CDATA[<p><strong>版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起.</strong></p>
<hr>
<h2 id="数据库简介"><a href="#数据库简介" class="headerlink" title="数据库简介"></a>数据库简介</h2><p><a href="https://github.com/objectbox/objectbox-java" target="_blank" rel="noopener">objectbox</a>数据库是greenrobot团队开发的全新非关系型数据库框架，该团队还开发过greenDao,EventBus等热门框架，可谓实力雄厚。按照官方介绍，该库有如下特点:<br><a id="more"></a></p>
<ul>
<li>超快速:号称胜过测试过的所有嵌入式数据库</li>
<li>面向对象的 API: 没有 rows、columns 和 SQL，完全从0开始的对象（没有ORM，没有SQLite）</li>
<li>反应性:对数据变化的反应简单而强大,使用ObjectBox中的反应数据观察器或与RxJava集成。</li>
<li>多平台:已经支持安卓和java,ios和MacOs正在集成</li>
<li>简单的线程:ObjectBox返回的对象可以在所以线程中运行</li>
<li>没有手动模式迁移:ObjectBox负责添加，删除和重命名属性的新对象版本，意味着数据库的升级不再需要我们自己管理版本号，ObjectBox内部会自动帮我们管理</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>注意，本教程是基于截至于目前最新版1.4.0编写</p>
<p>根目录build.gradle中添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ext.objectboxVersion = &apos;1.4.0&apos;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123; url &quot;http://objectbox.net/beta-repo/&quot; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath &quot;io.objectbox:objectbox-gradle-plugin:$objectboxVersion&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123; url &quot;http://objectbox.net/beta-repo/&quot; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>app  build.gradle中添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;io.objectbox&apos; // after applying Android plugin</span><br></pre></td></tr></table></figure></p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>在Application中的<code>onCreate()</code>中初始化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boxStore = MyObjectBox.builder().androidContext(<span class="keyword">this</span>).build();</span><br></pre></td></tr></table></figure></p>
<p>初始化后得到一个<code>BoxStore</code>对象,该对象可以简单理解为获取查询对象的入口,因此，我们可以申明一个<code>get()</code>方法，像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class BaseApp extends Application &#123;</span><br><span class="line">    private static BaseApp baseApp;</span><br><span class="line">    private BoxStore boxStore; //数据库表的管理者</span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">        baseApp = this;</span><br><span class="line">        boxStore = MyObjectBox.builder().androidContext(this).build();</span><br><span class="line">        if (BuildConfig.DEBUG) &#123;</span><br><span class="line">            new AndroidObjectBrowser(boxStore).start(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BoxStore getBoxStore()&#123;</span><br><span class="line">        return boxStore;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static BaseApp getInstence()&#123;</span><br><span class="line">        return baseApp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="实体类的建立"><a href="#实体类的建立" class="headerlink" title="实体类的建立"></a>实体类的建立</h4><p>objectbox是通过注解来标明哪个类是实体，常用的注解如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Entity   //表示这是一个需要持久化的实体</span><br><span class="line">public class Student &#123;</span><br><span class="line">    @Id </span><br><span class="line">    public long id;</span><br><span class="line"></span><br><span class="line">    @Index</span><br><span class="line">    public String name;</span><br><span class="line"> </span><br><span class="line">    @Transient</span><br><span class="line">    public int tempUsageCount;</span><br><span class="line"></span><br><span class="line">    @NameInDb(&quot;USERNAME&quot;)</span><br><span class="line">    public String name;</span><br><span class="line"></span><br><span class="line">    public ToOne&lt;Class&gt; classToOne;</span><br><span class="line"></span><br><span class="line">    public int age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>@Entity：</strong>这个对象需要持久化。</p>
<p><strong>@Id：</strong>这个对象的主键,默认情况下，id是会被objectbox管理的，也就是自增id，如果你想手动管理id需要在注解的时候加上@Id(assignable = true)即可。当你在自己管理id的时候如果超过long的最大值，objectbox 会报错.id的值不能为负数。当id等于0时objectbox会认为这是一个新的实体对象,因此会新增到数据库表中</p>
<p><strong>@Index：</strong>这个对象中的索引。对经常大量进行查询的字段创建索引，会提高你的查询性能。</p>
<p><strong>@Transient:</strong>如果你有某个字段不想被持久化，可以使用此注解,那么该字段将不会保存到数据库</p>
<p><strong>@NameInDb：</strong>有的时候数据库中的字段跟你的对象字段不匹配的时候，可以使用此注解。</p>
<p><strong>@ToOne:</strong>做一对一的关联注解，例如示例中表示一张学生表（Student）关联一张班级表（Class）,此外还有一对多，多对多的关联，例如Class的示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Entity</span><br><span class="line">public class Class&#123;</span><br><span class="line">    @Id</span><br><span class="line">    long id;</span><br><span class="line">    </span><br><span class="line">    @Backlink(to = &quot;classToOne&quot;)</span><br><span class="line">    public ToMany&lt;Student&gt; studentEntitys;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>@ToMany:</strong>做一对多的关联注解，如示例中表示一张班级表(Class)关联多张学生表(Student)</p>
<p><strong>@Backlink:</strong>表示反向关联</p>
<h4 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h4><p>实体类建立完后，在Android Studio中使用Build&gt; Make project编译一次，objectbox会自动帮你生成相应的操作实体,例如·<code>Student</code>则会生成一个<code>Student_</code>的类，该类通常作为Params传递。</p>
<p><strong>增加一条数据</strong><br>首先我们获取该实体的<code>Box</code>对象，随后调用该对象的<code>put()</code>方法即可完成新增操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Box&lt;Student&gt; StudentBox = BaseApp.getInstence().getBoxStore().boxFor(Student.class);</span><br><span class="line">Student student = new Student();</span><br><span class="line">student.name = &quot;Jay&quot;;</span><br><span class="line">StudentBox.put(student);</span><br></pre></td></tr></table></figure></p>
<p><strong>删除数据</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StudentBox.remove(student);  //该参数可以传要删除的实体，也可以传入要删除的实体的id,可以批量传入</span><br></pre></td></tr></table></figure></p>
<p><strong>查询</strong><br>通过<code>Box</code>的<code>query()</code>方法可以得到一个<code>QueryBuilder</code>对象，该对象可以实现各种查询操作，里面包含<code>contains()</code>,<code>equal()</code>等各种便捷的查询方法，示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//查询一个名叫Jay的学生信息的表</span><br><span class="line">Student jayStudent = StudentBox.query().equal(Student_.name, &quot;Jay&quot;).build().find();</span><br></pre></td></tr></table></figure></p>
<p>里面的<code>Property</code>对象其实就是传入我们自动生成的<code>Student_</code>对象的参数。</p>
<p><strong>修改</strong><br>objectBox修改数据非常简单，首先得到要修改的实体类，直接修改数据，随后调用<code>put()</code>方法即可，示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//查询一个名叫Jay的学生信息的表</span><br><span class="line">Student jayStudent = StudentBox.query().equal(Student_.name, &quot;Jay&quot;).build().find();</span><br><span class="line">jayStudent.name = &quot;www.huangjie.name&quot;;</span><br><span class="line">StudentBox.put(jayStudent);</span><br></pre></td></tr></table></figure></p>
<p>这样就把Jay改成了我的博客地址,haha~</p>
<h4 id="数据库的其他操作"><a href="#数据库的其他操作" class="headerlink" title="数据库的其他操作"></a>数据库的其他操作</h4><p><strong>数据库的数据升级</strong><br>当我们需要新增和删除字段时，直接操作实体类即可，不需要做特殊的更改，如果需要重命名字段名或实体类名，可以按照如下步骤操作：<br>第一步：给需要修改的类名加上@UID注解<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Entity</span><br><span class="line">@Uid</span><br><span class="line">public class MyName &#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>第二步：编译项目，编译将失败，并且会给你一个UID<br><code>error: [ObjectBox] UID operations for entity &quot;MyName&quot;: 
  [Rename] apply the current UID using @Uid(6645479796472661392L) -
  [Change/reset] apply a new UID using @Uid(4385203238808477712L)</code><br>第三步：将Rename后面的UID放入到要修改的类中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Entity</span><br><span class="line">@Uid(6645479796472661392L)</span><br><span class="line">public class MyName &#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>第四步：进行数据的修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Entity</span><br><span class="line">@Uid(6645479796472661392L)</span><br><span class="line">public class MyNewName &#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>更改数据属性或重命名字段名同理操作。</p>
<h4 id="表关系"><a href="#表关系" class="headerlink" title="表关系"></a>表关系</h4><p>@ToOne和@ToMany可以看作JAVA中的T和List<t>的关系,拿班级和学生举例，设置相关的学生对象如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class class = new Class(); //先创建一个班级</span><br><span class="line">Student student = new Student();</span><br><span class="line">student.name = &quot;Jay&quot;;</span><br><span class="line">student.classToOne.setTarget(class);  //设置一对一的target对象，字段参见以上示例</span><br><span class="line">long studentId = StudentBox.put(student);</span><br></pre></td></tr></table></figure></t></p>
<p>获取该学生的班级信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student student = StudentBox.get(studentId);</span><br><span class="line">Class class = student.classToOne.getTarget();</span><br></pre></td></tr></table></figure></p>
<p>而一对多的关系更为简单，你可以像List集合一样去操作它：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Class class_ = new Class(); //先创建一个班级</span><br><span class="line">Student s1 = new Student(); //添加一个学生</span><br><span class="line">student.name = &quot;Jay&quot;;</span><br><span class="line"></span><br><span class="line">Student s2 = new Student();</span><br><span class="line">s2.name = &quot;Android&quot;;</span><br><span class="line"></span><br><span class="line">class_ .studentEntitys.add(s1);</span><br><span class="line">class_ .studentEntitys.add(s2);</span><br><span class="line">Box classBox = BaseApp.getInstence().getBoxStore().boxFor(Class.class);</span><br><span class="line">classBox.put(class);</span><br></pre></td></tr></table></figure></p>
<p>这样的话一张Class表中就有两个学生表的数据了，查询的话可以获取该Class的实体，随后像遍历List集合一样去遍历<code>studentEntitys</code>字段,objectBox提供的方法和List集合几乎一样，这里就不做示例了。</p>
<p><strong>求和等操作</strong><br>使用<code>Query</code>对象即可进行求和等操作,通过<code>QueryBuilder</code>的<code>build()</code>方法即可得到。随后调用<code>sumDouble()</code>等方法传入求和条件即可。我们获取实体类或实体类集合也是使用的该对象获取。</p>
<p>另外，objectBox还支持事务，Rxjava查询，Kotlin的支持，更多详情可以通过官方文档了解<a href="http://objectbox.io/" target="_blank" rel="noopener">http://objectbox.io</a>.</p>
<h4 id="End"><a href="#End" class="headerlink" title="End"></a>End</h4><p>emmmmmm…写了这么多，个人觉得objectBox挺好用的，目前没发现啥坑，唯一的坑是编译的时候提示找不到<code>MyObjectBox</code>这个类，这个不用担心，先确认一下配置是否有误，无误的话将项目<code>Make Project</code>一下或者重新编译一下就OK了，另外，推荐下我写的ObjectBox数据库的练手项目<a href="https://github.com/Jay-huangjie/Notes" target="_blank" rel="noopener">仿支付宝记账本</a>,仿的支付宝中的记账本功能，结合它看你的objectBox上手更快哦。</p>
]]></content>
      
        <categories>
            
            <category> 安卓开源库使用教程 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Android开发常见问题与技巧汇总]]></title>
      <url>/Android%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB.html</url>
      <content type="html"><![CDATA[<p><strong>版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起.</strong></p>
<hr>
<blockquote>
<p>此为开发中遇到的一些常见问题的整理，方便下次遇到问题能快速找到解决方案，此外还收集了一些常见的开发技巧，持续更新中~~</p>
</blockquote>
<h4 id="1-编译出现："><a href="#1-编译出现：" class="headerlink" title="1 编译出现："></a>1 编译出现：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">All com.android.<span class="function">support libraries must use the exact same version <span class="title">specification</span> <span class="params">(mixing versions can lead to runtime crashes)</span>......</span></span><br></pre></td></tr></table></figure>
<p>如果引用的第三方库的支持库版本低于（或者不一致）app build.gradle中的支持库版本，就会出现这种问题,修改第三方的依赖的话工作量太大,因此考虑所有模块强制使用相同的版本号的支持库，代码如下：</p>
<p>在app build.gradle中添加：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">configurations.all &#123;</span><br><span class="line">    resolutionStrategy.eachDependency &#123; DependencyResolveDetails details -&gt;</span><br><span class="line">        def requested = details.requested</span><br><span class="line">        <span class="keyword">if</span> (requested.group == <span class="string">'com.android.support'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!requested.name.startsWith(<span class="string">"multidex"</span>)) &#123;</span><br><span class="line">                details.useVersion <span class="string">'26.1.0'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此代码声明了除multdex外全部使用26.1.0的版本库</p>
<h4 id="2-SVG图片兼容问题-主要针对5-0以下机型"><a href="#2-SVG图片兼容问题-主要针对5-0以下机型" class="headerlink" title="2 SVG图片兼容问题(主要针对5.0以下机型)"></a>2 SVG图片兼容问题(主要针对5.0以下机型)</h4><p>参考博客：<a href="https://www.jianshu.com/p/e3614e7abc03" target="_blank" rel="noopener">Android Vector曲折的兼容之路</a></p>
<p>基本适配方法：<br>在app build.gradle 的<code>defaultConfig</code>中添加<code>defaultvectorDrawables.useSupportLibrary = true</code></p>
<p>xml中使用：<br>ImageView原本是使用<code>src</code>加载,改为<code>app:srcCompat</code>.</p>
<p>java中使用：<br><code>ImageView iv = (ImageView) findViewById(R.id.iv);
iv.setImageResource(R.drawable.vector_image);</code></p>
<h4 id="3-自定义View中在4-X版本上通过getContext-方法强转成Activity失效"><a href="#3-自定义View中在4-X版本上通过getContext-方法强转成Activity失效" class="headerlink" title="3.自定义View中在4.X版本上通过getContext()方法强转成Activity失效"></a>3.自定义View中在4.X版本上通过getContext()方法强转成Activity失效</h4><p>参考博客： <a href="http://blog.csdn.net/wingichoy/article/details/72868959" target="_blank" rel="noopener">记一次View.getContext()遇到的大坑</a></p>
<p>原因：兼容v7包将<code>Context</code>包裹成了<code>TintContextWrapper</code>,所以强转成<code>Activity</code>会出错</p>
<p>解决方法：使用构造方法中的Context来强转。</p>
<h4 id="4-引入的第三方库与自己的support包冲突"><a href="#4-引入的第三方库与自己的support包冲突" class="headerlink" title="4.引入的第三方库与自己的support包冲突"></a>4.引入的第三方库与自己的support包冲突</h4><p>解决方法：<br>将冲突的库改成以下写法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">implementation (<span class="string">'此处是你引入的库'</span>)&#123;</span><br><span class="line">        exclude group: <span class="string">'com.android.support'</span> <span class="comment">//什么包冲突了这里就声明什么,注意名称要写对写全</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>另外，在这里普及一下<code>implementation</code>的概念,现在升级了AS后引入三方库有多种方式，如<code>implementation</code>,<code>compile</code>,<code>api</code> ..其中，<br><code>implementation</code>主要是引用本模块的库，其他模块是调用不到该模块引用的库的,类似java中的private属性,而<code>compile</code>类似java中的public属性,只要模块之间相互依赖,引用的库都能相互调用,而<code>api</code>的作用与<code>compile</code>一样,使用这些不同的调用方式是为了加快编译速度，如果你的库不需要在其他模块之中使用,请使用<code>implementation</code>方式，这样当外部调用改变不会编译整个model而只会编译改变的那个model.</p>
<h4 id="5-在java代码中获取xml中设置的behavior"><a href="#5-在java代码中获取xml中设置的behavior" class="headerlink" title="5.在java代码中获取xml中设置的behavior"></a>5.在java代码中获取xml中设置的behavior</h4><p>在开发项目的时候需要获取behavior的实例做一些事情，发现<code>CoordinatorLayout</code>没有提供获取<code>behavior</code>的方法，后来查看源码发现是使用<code>CoordinatorLayout.LayoutParams</code>来设置<code>behavior</code>的，所以<code>behavior</code>自然是从这里来获取,示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子类获取上级的CoordinatorLayout.LayoutParams</span></span><br><span class="line">CoordinatorLayout.LayoutParams cl = (CoordinatorLayout.LayoutParams) mRecyclerView.getLayoutParams();</span><br><span class="line"> MyBehavior behavior = (MyBehavior) cl.getBehavior(); <span class="comment">//调用getBehavior方法</span></span><br></pre></td></tr></table></figure>
<h4 id="6-设置状态栏透明并使父布局移动到状态栏上去-适用于5-0以上"><a href="#6-设置状态栏透明并使父布局移动到状态栏上去-适用于5-0以上" class="headerlink" title="6.设置状态栏透明并使父布局移动到状态栏上去(适用于5.0以上)"></a>6.设置状态栏透明并使父布局移动到状态栏上去(适用于5.0以上)</h4><p>项目中需要用到状态栏颜色随着标题栏颜色改变,甚至还有渐变效果,如果单纯设置状态栏颜色非常不方便，并且实现颜色渐变也不简单，所有将采用将父布局上移的方法,这样状态栏的颜色就是标题栏的颜色啦,实现方法如下：</p>
<p>step1:定义主题文件<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;style name=<span class="string">"TransTheme"</span> parent=<span class="string">"Theme.AppCompat.Light.NoActionBar"</span>&gt;</span><br><span class="line">        &lt;item name="android:windowTranslucentStatus"&gt;true&lt;/item&gt;</span><br><span class="line">        &lt;item name="android:statusBarColor"&gt;@android:color/transparent&lt;/item&gt; //设置状态栏透明</span><br><span class="line">    &lt;/style&gt;</span><br></pre></td></tr></table></figure></p>
<p>step2:在清单文件的Activity中使用它<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity</span><br><span class="line">     android:name=<span class="string">".module.ScheduleActivity"</span></span><br><span class="line">     android:theme=<span class="string">"@style/TransTheme"</span> /&gt;</span><br></pre></td></tr></table></figure></p>
<p>step3:让你的父布局的控件向下偏移一个状态栏的高度:<br>获取状态栏的高度:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取状态栏高度</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> context context</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 状态栏高度</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getStatusBarHeight</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 获得状态栏高度</span></span><br><span class="line">       <span class="keyword">int</span> resourceId = context.getResources().getIdentifier(<span class="string">"status_bar_height"</span>, <span class="string">"dimen"</span>, <span class="string">"android"</span>);</span><br><span class="line">       <span class="keyword">return</span> context.getResources().getDimensionPixelSize(resourceId);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>然后需要偏移的控件就需要根据项目实际情况了，一般是自定义一个标题布局,然后在所有的Activity中使用这个标题布局,我的标题布局的父布局是一个FragmeLayout，因此做如下设置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT&gt;Build.VERSION_CODES.KITKAT)&#123;</span><br><span class="line">            FrameLayout.LayoutParams fl = (LayoutParams) mFrameLayout.getLayoutParams();</span><br><span class="line">            fl.topMargin = getStatusBarHeight(getContext());</span><br><span class="line">            mFrameLayout.setLayoutParams(fl);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后给<code>mFrameLayout</code>设置背景色,这样状态栏就和标题栏一个颜色啦。</p>
]]></content>
      
        <categories>
            
            <category> Android基础进阶 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[2017年终总结]]></title>
      <url>/2017%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93.html</url>
      <content type="html"><![CDATA[<p><strong>版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起.</strong></p>
<hr>
<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>从自己开始坚持写博客也有1个月了，感觉非常的充实，博客就是注重总结归纳嘛，既然2017都已经过去，那么也有必要总结归纳一下啦。其实我认为我的2017总结起来就是：行动起来，不再等待，重在参与！<br><a id="more"></a></p>
<h4 id="回首"><a href="#回首" class="headerlink" title="回首"></a>回首</h4><p>一眨眼2017就过去了，想想自己今年，的确是成长最快的一年，也是忙碌而又平淡的一年，收获了许多。</p>
<p>依稀记得年初，就有了技术进阶的想法，因为感觉自己在许多功能点上‘会做’，但‘不懂’，无法深入的解决问题。于是，我就寻求进阶的方法，我在帅张的公众号上读了他写的一遍文章，文章指出，习惯很重要，我结合自身的行为揣摩这句话，总结发现，学习并不需要强迫自己去学，而应该把它当成一种自然习惯，就像渴了会喝水一样的生活习惯，这种习惯的培养需要的是坚持，以及自律！为此我尝试慢慢去培养自己的学习习惯：</p>
<p>因为公司搬家，我从家到公司需要30-40分钟，在地铁上，以前是都是看一下新闻啊，刷一下微博啊，现在我都是看掘金有没有什么新鲜的框架，看看简书有没有好看的技术文章，看看github有没有火热的技术排名，那些微博什么的我再也没打开过，我已经坚持有大半年的，甚至现在但凡座地铁我也会习惯性打开这些app</p>
<p>以前的我工作回到家都是刷电视剧，现在都是有目的性的去学习一个知识点或者一门语言，这样时间过得非常的快，每天感觉时间不够用，果然当投入到某一件事时时间的流逝是非常快速的。</p>
<p>先前都是自己写demo,自己总结知识点，然后写到印象笔记中，但是我发现里面的知识点太散乱，无法成为一个体系。于是我就试着写博客，为此，我发现了一个新大陆，写博客对于知识的梳理简直太有用了，前提是你想写好一篇博客。</p>
<p>学习知识就要善于总结归纳，书本是最好的老师，为此2017我阅读了一些的书籍：</p>
<p>郭神的《第一行代码》第二版，这是一本基础书籍，它让我对安卓的基础有了更加完善的了解和夯实。</p>
<p>任玉刚的《安卓开发艺术探索》，这是一本进阶类的书籍，它让我突破了瓶颈，对安卓的了解更加的深入了。</p>
<p>我对这两位都非常的钦佩，正是他们让我们这些开发者的进阶至少能提前0.5-1年的时间，《开发艺术探索》我来回读了好几遍，每一次都会有新的收获，再次感谢~</p>
<p>晚上，我也会偶尔看下慕课网上的视频，我觉得里面的老师讲的还是比较好的，为此我也推荐给大家。</p>
<p>回首2017的技术有如下的总结：</p>
<ul>
<li><p>学习了自定义View,对自定义的流程有了较为完善的了解</p>
</li>
<li><p>学习了View体系，view的确是一个非常有魅力的控件，它可以带来无穷的创造力</p>
</li>
<li><p>对数据库框架都有所了解：如公司项目正在使用的<a href="https://github.com/pardom/ActiveAndroid" target="_blank" rel="noopener">ActiveAndroid</a>(作者貌似不维护了？),使用<a href="https://github.com/greenrobot/greenDAO" target="_blank" rel="noopener">greenDAO</a>做过一些简单的demo,后来发现了greenDao的作者正在开发一个全新的数据库，号称最快的数据库，于是就没有继续深入greenDao的研究，转而研究新的数据库，它就是我现在正在研究的<a href="https://github.com/objectbox/objectbox-java" target="_blank" rel="noopener">object-box</a>,不过现在资料还较少，届时我会出一个教程。</p>
</li>
<li><p>学习了ExoPlayer视频播放框架，Rxjava,okhttp,mvp等等的一些热门框架和架构</p>
</li>
<li><p>学习了一些kotlin的基本语法</p>
</li>
<li><p>学习了html5的一些基本语法，能制作一些静态页面</p>
</li>
<li><p>基于hexo和coding搭建的博客平台.先前本来是上传到github的，由于百度被墙的关系，就移到coding了。</p>
</li>
</ul>
<h4 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h4><p>对于2018，我坚信我的坚持会带给我更多的收获。我依旧会努力坚持2017正在做的事情：</p>
<ul>
<li>坚持写博客，至少1周一篇</li>
<li>坚持技术学习</li>
</ul>
<p>2018要刷的书有《kotlin实战》，《Android神兵利器》，《安卓群英传》。</p>
<p>2018需要进阶的技术有：</p>
<ul>
<li>kotlin的熟练使用</li>
<li>自定义View的总结，动画系列</li>
<li>直播，视频播放技术要点总结</li>
<li>设计模式</li>
<li>内存优化</li>
<li>gradle精通</li>
<li>简单了解下逆向，反编译等技术</li>
</ul>
<p>2018，让我们一起加油<del>~</del></p>
]]></content>
      
        <categories>
            
            <category> 感悟 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[ExoPlayer视频框架：自定义UI界面及源码解析]]></title>
      <url>/ExoPlayer%E8%A7%86%E9%A2%91%E6%A1%86%E6%9E%B6%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89UI%E7%95%8C%E9%9D%A2%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.html</url>
      <content type="html"><![CDATA[<p><strong>版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起.</strong></p>
<hr>
<blockquote>
<p>本文主要讲述使用ExoPlayer框架时如何自定义自己的视频播放界面，来达到满意的效果，以及SimpleExoPlayerView的源码解析</p>
</blockquote>
<h4 id="SimpleExoPlayerView"><a href="#SimpleExoPlayerView" class="headerlink" title="SimpleExoPlayerView"></a>SimpleExoPlayerView</h4><a id="more"></a>
<h5 id="类介绍"><a href="#类介绍" class="headerlink" title="类介绍"></a>类介绍</h5><p>SimpleExoPlayerView是一个自定义FrameLayout,内部封装了视频，字幕，播放封面，播放控制器的View逻辑</p>
<h5 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h5><p><strong>在xml中声明该控件：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;com.google.android.exoplayer2.ui.SimpleExoPlayerView</span><br><span class="line">        android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">        android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">        android:id=<span class="string">"@+id/simpleExoPlayerView"</span></span><br><span class="line">        app:resize_mode=<span class="string">"fixed_width"</span></span><br><span class="line">        /&gt;</span><br></pre></td></tr></table></figure></p>
<p>SimpleExoPlayerView内部的AspectRatioFrameLayout封装了视频宽高比的计算，它根据视频流的宽高比来动态设置控件的宽高来达到适应屏幕的目的，<code>resize_mode</code>可以指定这种视频的宽高比计算模式，共有四种模式，<code>fixed_width</code>代表根据宽度来动态计算高度，宽度不会变化，<code>fixed_height</code>与之相反，<code>fill</code>模式会忽略宽高比，不进行动态计算，<code>fit</code>为默认模式，如果高度变形就动态计算高度来适配，宽度变形就动态计算宽度来适配。<br><strong>activity中：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">simpleExoPlayerView.setPlayer(player);</span><br></pre></td></tr></table></figure></p>
<p>通过<code>setPlayer</code>方法来与<code>ExoPlayer</code>绑定</p>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>要随心所欲的使用该View，来定制自己理想的UI，就得先了解其中的原理，方能全面掌控，下面我们就来撸一遍源码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TargetApi</span>(<span class="number">16</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleExoPlayerView</span> <span class="keyword">extends</span> <span class="title">FrameLayout</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SURFACE_TYPE_NONE = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SURFACE_TYPE_SURFACE_VIEW = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SURFACE_TYPE_TEXTURE_VIEW = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> AspectRatioFrameLayout contentFrame;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> View shutterView;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> View surfaceView;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ImageView artworkView;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SubtitleView subtitleView;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> PlaybackControlView controller;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ComponentListener componentListener;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> FrameLayout overlayFrameLayout;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> SimpleExoPlayer player;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> useController;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> useArtwork;</span><br><span class="line">  <span class="keyword">private</span> Bitmap defaultArtwork;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> controllerShowTimeoutMs;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> controllerAutoShow;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> controllerHideOnTouch;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SimpleExoPlayerView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SimpleExoPlayerView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SimpleExoPlayerView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isInEditMode()) &#123;</span><br><span class="line">      contentFrame = <span class="keyword">null</span>;</span><br><span class="line">      shutterView = <span class="keyword">null</span>;</span><br><span class="line">      surfaceView = <span class="keyword">null</span>;</span><br><span class="line">      artworkView = <span class="keyword">null</span>;</span><br><span class="line">      subtitleView = <span class="keyword">null</span>;</span><br><span class="line">      controller = <span class="keyword">null</span>;</span><br><span class="line">      componentListener = <span class="keyword">null</span>;</span><br><span class="line">      overlayFrameLayout = <span class="keyword">null</span>;</span><br><span class="line">      ImageView logo = <span class="keyword">new</span> ImageView(context);</span><br><span class="line">      <span class="keyword">if</span> (Util.SDK_INT &gt;= <span class="number">23</span>) &#123;</span><br><span class="line">        configureEditModeLogoV23(getResources(), logo);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        configureEditModeLogo(getResources(), logo);</span><br><span class="line">      &#125;</span><br><span class="line">      addView(logo);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> shutterColorSet = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> shutterColor = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> playerLayoutId = R.layout.exo_simple_player_view;</span><br><span class="line">    <span class="keyword">boolean</span> useArtwork = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span> defaultArtworkId = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> useController = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span> surfaceType = SURFACE_TYPE_SURFACE_VIEW;</span><br><span class="line">    <span class="keyword">int</span> resizeMode = AspectRatioFrameLayout.RESIZE_MODE_FIT;</span><br><span class="line">    <span class="keyword">int</span> controllerShowTimeoutMs = PlaybackControlView.DEFAULT_SHOW_TIMEOUT_MS;</span><br><span class="line">    <span class="keyword">boolean</span> controllerHideOnTouch = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span> controllerAutoShow = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (attrs != <span class="keyword">null</span>) &#123;</span><br><span class="line">      TypedArray a = context.getTheme().obtainStyledAttributes(attrs,</span><br><span class="line">              R.styleable.SimpleExoPlayerView, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        shutterColorSet = a.hasValue(R.styleable.SimpleExoPlayerView_shutter_background_color);</span><br><span class="line">        shutterColor = a.getColor(R.styleable.SimpleExoPlayerView_shutter_background_color,</span><br><span class="line">                shutterColor);</span><br><span class="line">        playerLayoutId = a.getResourceId(R.styleable.SimpleExoPlayerView_player_layout_id,</span><br><span class="line">                playerLayoutId);</span><br><span class="line">        useArtwork = a.getBoolean(R.styleable.SimpleExoPlayerView_use_artwork, useArtwork);</span><br><span class="line">        defaultArtworkId = a.getResourceId(R.styleable.SimpleExoPlayerView_default_artwork,</span><br><span class="line">                defaultArtworkId);</span><br><span class="line">        useController = a.getBoolean(R.styleable.SimpleExoPlayerView_use_controller, useController);</span><br><span class="line">        surfaceType = a.getInt(R.styleable.SimpleExoPlayerView_surface_type, surfaceType);</span><br><span class="line">        resizeMode = a.getInt(R.styleable.SimpleExoPlayerView_resize_mode, resizeMode);</span><br><span class="line">        controllerShowTimeoutMs = a.getInt(R.styleable.SimpleExoPlayerView_show_timeout,</span><br><span class="line">                controllerShowTimeoutMs);</span><br><span class="line">        controllerHideOnTouch = a.getBoolean(R.styleable.SimpleExoPlayerView_hide_on_touch,</span><br><span class="line">                controllerHideOnTouch);</span><br><span class="line">        controllerAutoShow = a.getBoolean(R.styleable.SimpleExoPlayerView_auto_show,</span><br><span class="line">                controllerAutoShow);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        a.recycle();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LayoutInflater.from(context).inflate(playerLayoutId, <span class="keyword">this</span>);</span><br><span class="line">    componentListener = <span class="keyword">new</span> ComponentListener();</span><br><span class="line">    setDescendantFocusability(FOCUS_AFTER_DESCENDANTS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Content frame.</span></span><br><span class="line">    contentFrame = findViewById(R.id.exo_content_frame);</span><br><span class="line">    <span class="keyword">if</span> (contentFrame != <span class="keyword">null</span>) &#123;</span><br><span class="line">      setResizeModeRaw(contentFrame, resizeMode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Shutter view.</span></span><br><span class="line">    shutterView = findViewById(R.id.exo_shutter);</span><br><span class="line">    <span class="keyword">if</span> (shutterView != <span class="keyword">null</span> &amp;&amp; shutterColorSet) &#123;</span><br><span class="line">      shutterView.setBackgroundColor(shutterColor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a surface view and insert it into the content frame, if there is one.</span></span><br><span class="line">    <span class="keyword">if</span> (contentFrame != <span class="keyword">null</span> &amp;&amp; surfaceType != SURFACE_TYPE_NONE) &#123;</span><br><span class="line">      ViewGroup.LayoutParams params = <span class="keyword">new</span> ViewGroup.LayoutParams(</span><br><span class="line">              ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);</span><br><span class="line">      surfaceView = surfaceType == SURFACE_TYPE_TEXTURE_VIEW ? <span class="keyword">new</span> TextureView(context)</span><br><span class="line">              : <span class="keyword">new</span> SurfaceView(context);</span><br><span class="line">      surfaceView.setLayoutParams(params);</span><br><span class="line">      contentFrame.addView(surfaceView, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      surfaceView = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Overlay frame layout.</span></span><br><span class="line">    overlayFrameLayout = findViewById(R.id.exo_overlay);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Artwork view.</span></span><br><span class="line">    artworkView = findViewById(R.id.exo_artwork);</span><br><span class="line">    <span class="keyword">this</span>.useArtwork = useArtwork &amp;&amp; artworkView != <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (defaultArtworkId != <span class="number">0</span>) &#123;</span><br><span class="line">      defaultArtwork = BitmapFactory.decodeResource(context.getResources(), defaultArtworkId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Subtitle view.</span></span><br><span class="line">    subtitleView = findViewById(R.id.exo_subtitles);</span><br><span class="line">    <span class="keyword">if</span> (subtitleView != <span class="keyword">null</span>) &#123;</span><br><span class="line">      subtitleView.setUserDefaultStyle();</span><br><span class="line">      subtitleView.setUserDefaultTextSize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Playback control view.</span></span><br><span class="line">    PlaybackControlView customController = findViewById(R.id.exo_controller);</span><br><span class="line">    View controllerPlaceholder = findViewById(R.id.exo_controller_placeholder);</span><br><span class="line">    <span class="keyword">if</span> (customController != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.controller = customController;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (controllerPlaceholder != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Propagate attrs as playbackAttrs so that PlaybackControlView's custom attributes are</span></span><br><span class="line">      <span class="comment">// transferred, but standard FrameLayout attributes (e.g. background) are not.</span></span><br><span class="line">      <span class="keyword">this</span>.controller = <span class="keyword">new</span> PlaybackControlView(context, <span class="keyword">null</span>, <span class="number">0</span>, attrs);</span><br><span class="line">      controller.setLayoutParams(controllerPlaceholder.getLayoutParams());</span><br><span class="line">      ViewGroup parent = ((ViewGroup) controllerPlaceholder.getParent());</span><br><span class="line">      <span class="keyword">int</span> controllerIndex = parent.indexOfChild(controllerPlaceholder);</span><br><span class="line">      parent.removeView(controllerPlaceholder);</span><br><span class="line">      parent.addView(controller, controllerIndex);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.controller = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.controllerShowTimeoutMs = controller != <span class="keyword">null</span> ? controllerShowTimeoutMs : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.controllerHideOnTouch = controllerHideOnTouch;</span><br><span class="line">    <span class="keyword">this</span>.controllerAutoShow = controllerAutoShow;</span><br><span class="line">    <span class="keyword">this</span>.useController = useController &amp;&amp; controller != <span class="keyword">null</span>;</span><br><span class="line">    hideController();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  以下是一些暴露的方法</span><br><span class="line">  .......</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>我们看下它的构造方法，首先通过<code>isInEditMode()</code>方法判断了是否是在可视化编辑器中加载的，是的话就return。</p>
<p>接下来声明了一些默认的变量，并赋予了一些默认的值，我们看到有一个<code>playerLayoutId</code>声明了一个默认的布局文件<code>exo_simple_player_view</code>，跟踪去看下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</span><br><span class="line">&lt;merge xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span><br><span class="line"></span><br><span class="line">  &lt;com.google.android.exoplayer2.ui.AspectRatioFrameLayout android:id=<span class="string">"@id/exo_content_frame"</span></span><br><span class="line">      android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">      android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">      android:layout_gravity=<span class="string">"center"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Video surface will be inserted as the first child of the content frame. --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;View android:id=<span class="string">"@id/exo_shutter"</span></span><br><span class="line">        android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">        android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">        android:background=<span class="string">"@android:color/black"</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;ImageView android:id=<span class="string">"@id/exo_artwork"</span></span><br><span class="line">        android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">        android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">        android:scaleType=<span class="string">"fitXY"</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;com.google.android.exoplayer2.ui.SubtitleView android:id=<span class="string">"@id/exo_subtitles"</span></span><br><span class="line">        android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">        android:layout_height=<span class="string">"match_parent"</span>/&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/com.google.android.exoplayer2.ui.AspectRatioFrameLayout&gt;</span><br><span class="line"></span><br><span class="line">  &lt;FrameLayout android:id=<span class="string">"@id/exo_overlay"</span></span><br><span class="line">      android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">      android:layout_height=<span class="string">"match_parent"</span>/&gt;</span><br><span class="line"></span><br><span class="line">  &lt;View android:id=<span class="string">"@id/exo_controller_placeholder"</span></span><br><span class="line">      android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">      android:layout_height=<span class="string">"match_parent"</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/merge&gt;</span><br></pre></td></tr></table></figure></p>
<p>这个布局文件就是我们的ExoPlayer ui包中的默认ui布局。<br><code>AspectRatioFrameLayout</code>是继承自<code>FragmeLayout</code>,也就是源码中的<code>contentFrame</code>，它的作用是根据视频的宽高比和屏幕的宽高比来动态计算视频View的宽高比例。而<code>SimpleExoPlayerView</code>会将<code>surfaceView</code>动态插入到<code>AspectRatioFrameLayout</code>的第一个子View中来，来作为播放的View.</p>
<p><code>exo_shutter</code>也就是源码中的shutterView，它的背景可以通过代码动态设置，可以作为视频的一个蒙层.</p>
<p><code>exo_artwork</code>为源码中的<code>artworkView</code>，是一个ImageView,可以放一些图片上去.</p>
<p><code>SubtitleView</code>是一个字幕显示器，为源码中的<code>subtitleView</code>，可以定制字幕文件。</p>
<p><code>exo_overlay</code>为源码中的<code>overlayFrameLayout</code>，在源码中没有定制任何东西，可以根据需求放入一些逻辑。</p>
<p><code>exo_controller_placeholder</code>为源码中的<code>controllerPlaceholder</code>，定义了<code>PlaybackControlView</code>的布局属性，在代码中<code>SimpleExoPlayer</code>会将<code>controllerPlaceholder</code>的Param属性添加到<code>PlaybackControlView</code>上。<br><code>PlaybackControlView</code>是一个播放控制器View.内部封装了播放器控制逻辑，也可以定制自定义ui和实现自己的控制逻辑。</p>
<p>介绍了这么多，接下来继续分析源码<br><code>LayoutInflater.from(context).inflate(playerLayoutId, this);</code><br>可以看到，SimpleExoPlayerView将playerLayoutId添加进了该视图，因此，我们可以通过xml的属性来指定该View的视图id，接着声明了该焦点模式为只有当子View不需要焦点时才获取焦点。<br><code>setDescendantFocusability(FOCUS_AFTER_DESCENDANTS);</code><br>接下来通过findViewById的模式得到视图的控件来进行不同的设置，因此，如果我们自定义的ui中想用到里面的功能，就必须申明一样的id.也可以通过findViewById的方式得到该控件。<br>接下来继续走：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a surface view and insert it into the content frame, if there is one.</span></span><br><span class="line">   <span class="keyword">if</span> (contentFrame != <span class="keyword">null</span> &amp;&amp; surfaceType != SURFACE_TYPE_NONE) &#123;</span><br><span class="line">     ViewGroup.LayoutParams params = <span class="keyword">new</span> ViewGroup.LayoutParams(</span><br><span class="line">         ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);</span><br><span class="line">     surfaceView = surfaceType == SURFACE_TYPE_TEXTURE_VIEW ? <span class="keyword">new</span> TextureView(context)</span><br><span class="line">         : <span class="keyword">new</span> SurfaceView(context);</span><br><span class="line">     surfaceView.setLayoutParams(params);</span><br><span class="line">     contentFrame.addView(surfaceView, <span class="number">0</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     surfaceView = <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>SimpleExoPlayerView</code>根据<code>sufaceType</code>自动创建一个<code>SufaceView</code>或<code>TextureView</code>,并将其添加到<code>AspectRatioFrameLayout</code>的第一个子View上，用来播放视频。因此如果自定义UI，一定要定义一个<code>AspectRatioFrameLayout</code>来包裹该View.<br>接着我们看一下控制器的逻辑：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Playback control view.</span></span><br><span class="line">   PlaybackControlView customController = findViewById(R.id.exo_controller);</span><br><span class="line">   View controllerPlaceholder = findViewById(R.id.exo_controller_placeholder);</span><br><span class="line">   <span class="keyword">if</span> (customController != <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="keyword">this</span>.controller = customController;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (controllerPlaceholder != <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="comment">// Propagate attrs as playbackAttrs so that PlaybackControlView's custom attributes are</span></span><br><span class="line">     <span class="comment">// transferred, but standard FrameLayout attributes (e.g. background) are not.</span></span><br><span class="line">     <span class="keyword">this</span>.controller = <span class="keyword">new</span> PlaybackControlView(context, <span class="keyword">null</span>, <span class="number">0</span>, attrs);</span><br><span class="line">     controller.setLayoutParams(controllerPlaceholder.getLayoutParams());</span><br><span class="line">     ViewGroup parent = ((ViewGroup) controllerPlaceholder.getParent());</span><br><span class="line">     <span class="keyword">int</span> controllerIndex = parent.indexOfChild(controllerPlaceholder);</span><br><span class="line">     parent.removeView(controllerPlaceholder);</span><br><span class="line">     parent.addView(controller, controllerIndex);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">this</span>.controller = <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到<code>PlaybackControlView</code>也是通过找id的方式获取，因此我们需要定制控制器ui的话可以通过继承<code>PlaybackControlView</code>的方式来定制我们自己的控制UI。<br>如果我们没有定义<code>PlaybackControlView</code>，那么会先创建一个<code>PlaybackControlView</code>，然后去取<code>exo_controller_placeholder</code>的<code>param</code>属性赋给<code>PlaybackControlView</code>，如果没有的话，那么不会申明一个控制器。</p>
<h4 id="UI定制"><a href="#UI定制" class="headerlink" title="UI定制"></a>UI定制</h4><p>以上通过源码分析，相信对该控件也有个大概的了解了，接下来看看如何定制我们的UI：<br>首先，在xml中我们可以通过<code>controller_layout_id</code>属性申明我们自己的<code>Layout id</code>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;com.google.android.exoplayer2.ui.SimpleExoPlayerView</span><br><span class="line">      android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">      android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">      android:id=<span class="string">"@+id/simpleExoPlayerView"</span></span><br><span class="line">      app:resize_mode=<span class="string">"fixed_width"</span></span><br><span class="line">      app:controller_layout_id=<span class="string">"@layout/simple_player_view"</span></span><br><span class="line">      /&gt;</span><br></pre></td></tr></table></figure></p>
<p><code>simple_player_view</code>为我自定义布局文件，看一下<code>simple_player_view</code>的代码：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;com.google.android.exoplayer2.ui.AspectRatioFrameLayout</span><br><span class="line">    android:id=<span class="string">"@id/exo_content_frame"</span></span><br><span class="line">    android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">    android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">    android:layout_gravity=<span class="string">"top"</span>&gt;</span><br><span class="line">    &lt;com.jie.exoplayerdemo.PlayControlView</span><br><span class="line">        android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">        android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">        android:id=<span class="string">"@id/exo_controller"</span></span><br><span class="line">        android:layout_gravity=<span class="string">"bottom"</span></span><br><span class="line">        app:controller_layout_id=<span class="string">"@layout/exo_playback_control_view"</span></span><br><span class="line">        /&gt;</span><br><span class="line">&lt;/com.google.android.exoplayer2.ui.AspectRatioFrameLayout&gt;</span><br></pre></td></tr></table></figure></p>
<p>该布局只要id与源码中对应即可随意定制，我在里面只是申明了一个<code>AspectRatioFrameLayout</code>和一个自定义的控制器，如果我们不想用该框架的默认控制器<code>PlaybackControlView</code>，可以自定义该控制器，控制器的自定义逻辑和<code>SimpleExoPlayerView</code>一样，也是通过申明id的方式来控制View的逻辑，并且该View不是final类，因此可以继承<code>PlaybackControlView</code>来实现自己的逻辑。<code>PlayControlView</code>就是继承<code>PlaybackControlView</code>来实现的自定义逻辑，我们可以直接通过找id的方式来获取<code>PlaybackControlView</code>里的控件，因此，里面的所有控件是可定制的。<br>可是，我们的<code>SimpleExoPlayerView</code>是一个final类，如果需要实现<code>SimpleExoPlayerView</code>没有的功能，我们需要将<code>SimpleExoPlayerView</code>的代码复制一份出来来达到修改的目的。</p>
]]></content>
      
        <categories>
            
            <category> Android视频播放 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ExoPlayer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[高效资源搜罗合集，不看保证后悔(持续更新)]]></title>
      <url>/Efficientresourcessearchtogethernoguaranteeofregret.html</url>
      <content type="html"><![CDATA[<p><strong>版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起.</strong></p>
<hr>
<blockquote>
<p>恭喜你发现了这篇博文，看了这篇博文，jay帮你打开新世界的大门，多年老司机开车，请系好安全带。</p>
</blockquote>
<h4 id="搜索篇-什么？说起搜索你只知道baidu-那你就out了"><a href="#搜索篇-什么？说起搜索你只知道baidu-那你就out了" class="headerlink" title="搜索篇(什么？说起搜索你只知道baidu?那你就out了)"></a>搜索篇(什么？说起搜索你只知道baidu?那你就out了)</h4><a id="more"></a>
<p><strong>快搜</strong>：<a href="http://search.chongbuluo.com/" target="_blank" rel="noopener">http://search.chongbuluo.com/</a></p>
<p><img src="http://p07lh1fh6.bkt.clouddn.com/%E5%BF%AB%E6%90%9C%20-%20%E6%90%9C%E7%B4%A2%E5%BF%AB%E4%BA%BA%E4%B8%80%E6%AD%A5%20-%20Google.png" alt=""></p>
<p>看图就知道，各种资源应有尽有，只有你想不到，没有你搜不到，强烈推荐</p>
<p><strong>西林街搜索</strong>：<a href="http://www.xilinjie.com/" target="_blank" rel="noopener">http://www.xilinjie.com/</a></p>
<p><img src="http://p07lh1fh6.bkt.clouddn.com/xilingjie.png" alt=""></p>
<p>各种电影资源,考试资料，都有，搜索比较精准，推荐</p>
<p><strong>WolframAlpha</strong> :<a href="http://www.wolframalpha.com/" target="_blank" rel="noopener">http://www.wolframalpha.com/</a><br>国外网站，就不放图了，可以在线解答问题，不管是数学，历史，生活，等等，都能帮你回答</p>
<p><strong>StackExchange</strong>： <a href="https://stackexchange.com/" target="_blank" rel="noopener">https://stackexchange.com/</a><br>国外的’知乎’,里面的问题和回答的质量很高，英语好的可以经常逛逛</p>
<p><strong>Github</strong>：<a href="http://www.github.com/" target="_blank" rel="noopener">http://www.github.com/</a><br>全球最大代码托管平台，没有程序员不知道的吧，在这里你可以找到各种开源项目和共享资源，比如谷歌镜像，host地址分享等</p>
<p><strong>种子搜索类(实在太多，随便列几个)</strong></p>
<p><strong>BTZO</strong> :<a href="http://www.btzo.net/" target="_blank" rel="noopener">http://www.btzo.net/</a><br><img src="http://p07lh1fh6.bkt.clouddn.com/BTAVA%20-%20BTSOW%20-%20BTSO%20-%20AVMOO%20-%20BTAVMO%20-%20BTZO.com%20%281%29.png-suofang" alt=""><br>电影资源挺丰富的，各种vip电影都有</p>
<p><strong>胖次搜索</strong> ：<a href="http://www.panc.cc/" target="_blank" rel="noopener">http://www.panc.cc/</a><br><img src="http://p07lh1fh6.bkt.clouddn.com/Panc.cc-%E8%83%96%E6%AC%A1%E7%BD%91%E7%9B%98%E6%90%9C%E7%B4%A2%20-%20%E8%83%96%E6%AC%A1%E5%88%86%E4%BA%AB%E7%A4%BE%E5%8C%BA%20-%20%E6%88%91%E4%BB%AC%E7%83%AD%E7%88%B1%E5%88%86%E4%BA%AB%20%281%29.png" alt=""></p>
<p>界面相当可爱有木有，当然资源也是相当多的</p>
<p><strong>网盘搜索</strong></p>
<p><strong>网盘搜</strong> ：<a href="http://www.wangpansou.com/" target="_blank" rel="noopener">http://www.wangpansou.com/</a><br>你是不是经常遇到想要的资源百度链接又失效了，不要害怕，使用了网盘搜，全网资源一网打尽，再也不需要等待别人分享资源了。</p>
<h4 id="图片类（设计师福利）"><a href="#图片类（设计师福利）" class="headerlink" title="图片类（设计师福利）"></a>图片类（设计师福利）</h4><p><strong>Everypixel</strong> : <a href="https://everypixel.com/" target="_blank" rel="noopener">https://everypixel.com/</a><br>国外图片搜索类网站</p>
<p><strong>图虫网</strong>        <a href="https://tuchong.com/" target="_blank" rel="noopener">https://tuchong.com/</a></p>
<p><img src="http://p07lh1fh6.bkt.clouddn.com/%E5%9B%BE%E8%99%AB%E7%BD%91%20-%20%E6%9C%80%E5%A5%BD%E7%9A%84%E6%91%84%E5%BD%B1%E5%B8%88%E9%83%BD%E5%9C%A8%E8%BF%99%20%281%29%20%281%29.png" alt=""></p>
<p>摄影爱好者必备</p>
<p><strong>Pixabay</strong>  : <a href="https://pixabay.com/" target="_blank" rel="noopener">https://pixabay.com/</a></p>
<p><img src="http://p07lh1fh6.bkt.clouddn.com/%E5%85%8D%E8%B4%B9%E5%9B%BE%E7%89%87%20-%20Pixabay.png" alt=""></p>
<p>嗯，免费高清图片！！！！</p>
<p><strong>Pexels</strong> : <a href="https://www.pexels.com/" target="_blank" rel="noopener">https://www.pexels.com/</a><br><img src="http://p07lh1fh6.bkt.clouddn.com/Free%20stock%20photos%20%C2%B7%20Pexels%20%281%29.png" alt=""><br>国外网站，素材很多而且免费。</p>
<p><strong>500PX</strong>：<a href="https://500px.com/" target="_blank" rel="noopener">https://500px.com/</a><br><img src="http://p07lh1fh6.bkt.clouddn.com/%E6%9C%80%E5%87%BA%E8%89%B2%E7%9A%84%E6%91%84%E5%BD%B1%E7%A4%BE%E5%8C%BA%20%20%20500px%20%281%29.png" alt=""></p>
<p>号称最出色的摄影专区，嗯，值得一试</p>
<p>还有几个找icon的网站：<br><strong>iconFont</strong> <a href="http://www.iconfont.cn/" target="_blank" rel="noopener">http://www.iconfont.cn/</a><br>阿里矢量图库，里面有许多app的图片资源和icon，并且提供svg和图标颜色转换，我平时仿写app就是用的它来找icon的</p>
<p><strong>easyicon</strong> :<a href="http://www.easyicon.net/iconsearch/See/" target="_blank" rel="noopener">http://www.easyicon.net/iconsearch/See/</a><br>一个icon图标搜索网站</p>
<p>此外，还有百度的百度识图也不错，有时候找到了一张非高清的图可以通过它找到高清的图：<br><a href="http://image.baidu.com/?fr=shitu" target="_blank" rel="noopener">http://image.baidu.com/?fr=shitu</a></p>
<h4 id="影视类（高清电影在线观看）"><a href="#影视类（高清电影在线观看）" class="headerlink" title="影视类（高清电影在线观看）"></a>影视类（高清电影在线观看）</h4><p>推荐几个在线观看电影的网站，没有广告哦,当然，这种网站现在很多，毕竟流量很大<br><strong>yy6080</strong> ：<a href="http://www.yy6080.org/" target="_blank" rel="noopener">http://www.yy6080.org/</a>,<br>类似还有80s(老牌电影网站),人人影视，天天美剧,1905电影网，BT天堂，童话村，这里就不贴地址了，百度就能找到</p>
<h4 id="音乐类（high到停不下来）"><a href="#音乐类（high到停不下来）" class="headerlink" title="音乐类（high到停不下来）"></a>音乐类（high到停不下来）</h4><p>强烈安利一款听歌神器：<br><strong>listen1</strong> :<a href="http://listen1.github.io/listen1/" target="_blank" rel="noopener">http://listen1.github.io/listen1/</a><br><img src="http://p07lh1fh6.bkt.clouddn.com/%E2%96%B6%20%E9%9A%94%E7%83%9F%E6%B0%B4%EF%BC%88Cover%20%E6%99%83%E5%84%BF%EF%BC%89%20-%20%E7%89%B9%E6%9B%BC%20%281%29.png" alt=""><br>这是一款谷歌浏览器插件，当你想听某一首有版权的歌，QQ音乐有这首歌的版权，而网易云没有，而你使用的是网易云，而你又想听这首歌，这个时候你就不得不使用QQ音乐播放器，是不是很闹心，这个插件的作用就是集结了三大主流平台的音乐，让你免去切播放器的烦恼，从此一次性可以听3个音乐平台的歌了。</p>
<p><strong>5Sing</strong> : <a href="http://5sing.kugou.com/index.html" target="_blank" rel="noopener">http://5sing.kugou.com/index.html</a><br>它是一个原创音乐基地，有许多的原创和翻唱伴奏歌曲。</p>
<h4 id="软件工具类（谁用谁知道）"><a href="#软件工具类（谁用谁知道）" class="headerlink" title="软件工具类（谁用谁知道）"></a>软件工具类（谁用谁知道）</h4><p>手机app:<br><strong>藏书库</strong> : <a href="http://www.geeboo.com/" target="_blank" rel="noopener">http://www.geeboo.com/</a></p>
<p>藏书馆，是读书爱好者在移动互联网空间里的专属私人图书馆，它通过共享借阅的模式，实现了书友间海量书籍的线上互借。</p>
<p><strong>网易蜗牛读书</strong>：<a href="http://du.163.com/" target="_blank" rel="noopener">http://du.163.com/</a><br>全网每天有1小时的免费读书时间，比较有特色</p>
<p>网站：<br><strong>TinyPNG</strong>:<a href="https://tinypng.com/" target="_blank" rel="noopener">https://tinypng.com/</a><br>这是一款可以在线压缩图片的网站，压缩后图片质量还挺好的，本人一直在用</p>
<p><strong>135编辑器</strong>：<a href="http://www.135editor.com/" target="_blank" rel="noopener">http://www.135editor.com/</a><br>如果你正在运营一个公众号，那么在公众号里写文章就可以使用这个网站，里面的公众号模板和排版个人一直很喜欢</p>
<p>另外，安利一个淘软件的神器网站：52破解论坛:<a href="https://www.52pojie.cn/" target="_blank" rel="noopener">https://www.52pojie.cn/</a><br>里面汇聚360，腾讯，阿里等安全大牛，每天都有原创破解软件发布，惊喜多多哦~~</p>
<p>资源暂时分享到这，后期还会持续更新，码字不易，如果觉得对你有帮助，不如点击下方赞赏按钮请我喝杯咖啡，另外，你可以按下Ctrl+D收藏该网址或者分享给好友，防止下次找不到了哦~~</p>
]]></content>
      
        <categories>
            
            <category> 资源整合 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> tools </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一看就懂的自定义顶部粘性下拉控件TouchPullView全面剖析]]></title>
      <url>/%E4%B8%80%E7%9C%8B%E5%B0%B1%E6%87%82%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E9%A1%B6%E9%83%A8%E7%B2%98%E6%80%A7%E4%B8%8B%E6%8B%89%E6%8E%A7%E4%BB%B6TouchPullView%E5%85%A8%E9%9D%A2%E5%89%96%E6%9E%90.html</url>
      <content type="html"><![CDATA[<p><strong>版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起.</strong></p>
<hr>
<blockquote>
<p>昨天在慕课上看到了一个自定义粘性头部的实现，发现现在有许多的app都有这个效果，于是跟着慕课上得视频敲了一遍。因为慕课上的老师对于后半部分的坐标运算讲的并不是很细致，因此我自己分析了一下源代码，总结了这篇博客，希望对同学们有所帮助。</p>
</blockquote>
<p>慕课视频地址：<a href="https://www.imooc.com/learn/830" target="_blank" rel="noopener">https://www.imooc.com/learn/830</a><br>源码下载地址：<a href="https://github.com/Jay-huangjie/TouchPullView" target="_blank" rel="noopener">https://github.com/Jay-huangjie/TouchPullView</a><br>建议大家先下载源码再来观看<br><a id="more"></a></p>
<h4 id="用到的知识点"><a href="#用到的知识点" class="headerlink" title="用到的知识点"></a>用到的知识点</h4><p><strong>我们先来复习一下需要用到的数学知识点</strong></p>
<p>三角函数：</p>
<ul>
<li>sin =  a/c;     </li>
<li>cos = b/c;         </li>
<li>tan = a/b;<br><img src="https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268/sign=1966ca03a0cc7cd9fa2d33df01032104/9825bc315c6034a8eb16696fc81349540823766c.jpg" alt=""></li>
</ul>
<p>贝塞尔曲线：<br><img src="https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D325/sign=391820be267f9e2f74351b0a2a31e962/91529822720e0cf34f59dca30b46f21fbe09aa38.jpg" alt=""></p>
<p>阅读本文需要了解自定义View的基本流程和贝塞尔曲线的绘制。</p>
<p>好，进入正题，我们先看一下它的运行效果：</p>
<p><img src="http://p07lh1fh6.bkt.clouddn.com/touch_demo.gif-sy" alt="效果图"></p>
<p>emmmmm,效果感觉还不错~</p>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>既然是拖动，肯定是基于Touch事件来实现的，通过Touch的Y坐标获取到拖动进度progress,然后通过requestLayout方法不断重绘界面，在onSizeChanged方法中通过计算不断移动圆心坐标，圆的左右两边是经典的贝塞尔曲线，只要获取到控制点和结束点的坐标就能绘制出来，通过控制点的不断移动和onDraw方法中的画布的不断移动来达到弹性和顶部两个起始点向中心靠拢的效果，中间的圆心与旁边的间距部分则是使用的drawable的Bounds效果,回弹则是利用的属性动画的addUpdateListener接口将progress数值由大到小执行回去从而达到的回弹效果</p>
<h4 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h4><p>光看原理肯定是四脸蒙蔽，还是结合代码分析才能达到事半功倍的效果。<br>我们先看OnTouch部分的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">findViewById(R.id.ll_mainLayout).setOnTouchListener(<span class="keyword">new</span> View.OnTouchListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View v, MotionEvent event)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> actionMasked = event.getActionMasked();</span><br><span class="line">                <span class="keyword">switch</span> (actionMasked) &#123;</span><br><span class="line">                    <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                        mTouchStartY = event.getY();</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                        <span class="keyword">float</span> y = event.getY();</span><br><span class="line">                        <span class="keyword">if</span> (y &gt;= mTouchStartY) &#123;  <span class="comment">//表示向下移动</span></span><br><span class="line">                            <span class="keyword">float</span> moveSize = y - mTouchStartY;</span><br><span class="line">                            <span class="keyword">float</span> progress = moveSize &gt; TOUCH_MOVE_MAX_Y ?</span><br><span class="line">                                    <span class="number">1</span> : moveSize / TOUCH_MOVE_MAX_Y;   <span class="comment">//计算进度值</span></span><br><span class="line">                            touchView.setProgress(progress);</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                        touchView.release();</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></p>
<p>这里还是比较简单，通过getY获取滑动的距离，按下去有一个点，滑动后有一个点，两点之间的距离就是我们的<br>moveSize了，由于progress是指当前滑动的进度值，取值肯定是在0~1之间，因此，当moveSize大于我们预设的最大值时，progress就返回1，否则就返回具体的进度值，最后在设置给touchView，touchView就会进行重绘。</p>
<p>再来看下TouchPullView里面的代码：<br>我们先看一下变量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Paint mCirclePaint = <span class="keyword">new</span> Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> mCircleRadius = <span class="number">50</span>; <span class="comment">//圆的半径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> mCirclePointX, mCirclePointY; <span class="comment">//圆心坐标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mDargHeight = <span class="number">400</span>;  <span class="comment">//最大可下拉的高度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> mProgress;  <span class="comment">//下拉进度值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mTargetWidth = <span class="number">400</span>; <span class="comment">//目标宽度</span></span><br><span class="line">    <span class="keyword">private</span> Path mPath = <span class="keyword">new</span> Path(); <span class="comment">//贝塞尔路径</span></span><br><span class="line">    <span class="keyword">private</span> Paint mPathPaint = <span class="keyword">new</span> Paint(Paint.ANTI_ALIAS_FLAG); <span class="comment">//贝塞尔画笔</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mTargetGravityHeight = <span class="number">10</span>; <span class="comment">//重心点最终高度，决定控制点的Y坐标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mTargetAngle = <span class="number">105</span>; <span class="comment">//角度变换 0~135</span></span><br><span class="line">    <span class="keyword">private</span> Interpolator mProgessInterpolator = <span class="keyword">new</span> DecelerateInterpolator(); <span class="comment">//一个由快到慢的插值器</span></span><br><span class="line">    <span class="keyword">private</span> Interpolator mTanentAngleInterpolator;</span><br><span class="line">    <span class="keyword">private</span> Drawable content = <span class="keyword">null</span>; <span class="comment">//中心圆drawable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mContentDrawableMargin = <span class="number">0</span>; <span class="comment">//中心圆Drawable边距</span></span><br></pre></td></tr></table></figure></p>
<p>大部分变量都简洁明了，mTargetGravityHeight规定了控制点上下浮动的最大距离，该值越大，控制点越往下移，mTargetAngle规定了结束点与圆心连线的那个角度的最大变幻值，因为不规定可以看到结束点会围绕圆心做圆环运动，最终导致变形，这不是我们希望看到的。mTargetWidth则规定了该控件能缩小的最小宽度。</p>
<p>接下来看onDraw()方法的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line">        <span class="comment">//基础坐标系改变</span></span><br><span class="line">        <span class="keyword">int</span> count = canvas.save();</span><br><span class="line">        <span class="comment">//获取平移画布的X的值,随着下滑起始点的坐标移动</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> transX = (getWidth() - getValueByLine(getWidth(), mTargetWidth, mProgress)) / <span class="number">2</span>;</span><br><span class="line">        canvas.translate(transX, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//绘制贝塞尔</span></span><br><span class="line">        canvas.drawPath(mPath, mPathPaint);</span><br><span class="line">        <span class="comment">//画圆</span></span><br><span class="line">        canvas.drawCircle(mCirclePointX, mCirclePointY, mCircleRadius, mCirclePaint);</span><br><span class="line">        <span class="comment">//绘制Drawable</span></span><br><span class="line">        Drawable drawable = content;</span><br><span class="line">        <span class="keyword">if</span> (drawable != <span class="keyword">null</span>) &#123;</span><br><span class="line">            canvas.save();</span><br><span class="line">            canvas.clipRect(drawable.getBounds());</span><br><span class="line">            drawable.draw(canvas);</span><br><span class="line">            canvas.restore();</span><br><span class="line">        &#125;</span><br><span class="line">        canvas.restoreToCount(count);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>getValueByLine</code>方法的作用是获取某一时刻贝塞尔曲线上的点的坐标，看一下它的方法实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取某一时刻的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> star      起始点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end       结束点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mProgress 当前进度值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">float</span> <span class="title">getValueByLine</span><span class="params">(<span class="keyword">float</span> star, <span class="keyword">float</span> end, <span class="keyword">float</span> mProgress)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> star + (end - star) * mProgress;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>它就是一个贝塞尔曲线公式Bt = P0+(P1-P0)*t，传入初始坐标P0和结束坐标P1和时间t，就能获取到Bt了。<br>接着它得到了一个transX,它等于起始点与屏幕左右的距离，通过画布的移动来实现起始点不断靠拢的效果，接下来是绘制贝塞尔曲线，画圆，根据Bounds大小添加Drawable到画布上。</p>
<p>接下来分析我们的重点：onSizeChanged中的实现,关键是这个方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updatePathLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> progress = mProgessInterpolator.getInterpolation(mProgress);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取所有的可绘制的宽/高  此值会根据progress不断的变化</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> w = getValueByLine(getWidth(), mTargetWidth, mProgress);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> h = getValueByLine(<span class="number">0</span>, mDargHeight, mProgress);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//圆心X坐标</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> cPointX = w / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//半径</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> cRadius = mCircleRadius;</span><br><span class="line">        <span class="comment">//圆心Y坐标</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> cPaintY = h - cRadius;</span><br><span class="line">        <span class="comment">//控制点结束Y的值</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> endPointY = mTargetGravityHeight;</span><br><span class="line">        <span class="comment">//更新圆心坐标</span></span><br><span class="line">        mCirclePointX = cPointX;</span><br><span class="line">        mCirclePointY = cPaintY;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Path path = mPath;</span><br><span class="line">        path.reset(); <span class="comment">//重置</span></span><br><span class="line">        path.moveTo(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//坐标系是以最左边的起始点为原点</span></span><br><span class="line">        <span class="keyword">float</span> lEndPointX, lEndPointY; <span class="comment">//结束点的X,Y坐标</span></span><br><span class="line">        <span class="keyword">float</span> lControlPointX, lControlPointY; <span class="comment">//控制点的X，Y坐标</span></span><br><span class="line">        <span class="comment">//获取当前切线的弧度</span></span><br><span class="line">        <span class="keyword">double</span> angle = mTanentAngleInterpolator.getInterpolation(progress) * mTargetAngle;<span class="comment">//获取当前的角度</span></span><br><span class="line">        <span class="keyword">double</span> radian = Math.toRadians(angle); <span class="comment">//获取当前弧度</span></span><br><span class="line">        <span class="keyword">float</span> x = (<span class="keyword">float</span>) (Math.sin(radian) * cRadius);  <span class="comment">//求出“股”的长度（长的那条直角边）</span></span><br><span class="line">        <span class="keyword">float</span> y = (<span class="keyword">float</span>) (Math.cos(radian) * cRadius);  <span class="comment">//求出“勾”的长度（短的那条直角边）</span></span><br><span class="line">        lEndPointX = cPointX - x; <span class="comment">//以起始点为原点，x坐标就等于圆的X坐标减去股的长度</span></span><br><span class="line">        lEndPointY = cPaintY + y; <span class="comment">//以起始点为原点，y坐标就等于圆的y坐标加上勾的长度</span></span><br><span class="line">        lControlPointY = getValueByLine(<span class="number">0</span>, endPointY, progress);<span class="comment">//获取控制点的Y坐标</span></span><br><span class="line">        <span class="keyword">float</span> tHeight = lEndPointY - lControlPointY; <span class="comment">//结束点与控制点的Y坐标差值</span></span><br><span class="line">        <span class="keyword">float</span> tWidth = (<span class="keyword">float</span>) (tHeight / Math.tan(radian));  <span class="comment">//通过计算两个角度是相等的，因此弧度依旧适用</span></span><br><span class="line">        lControlPointX = lEndPointX - tWidth; <span class="comment">//结束点的x - ‘勾’ 的长度求出了控制点的X坐标</span></span><br><span class="line"></span><br><span class="line">        path.quadTo(lControlPointX, lControlPointY, lEndPointX, lEndPointY); <span class="comment">//画左边贝塞尔曲线</span></span><br><span class="line">        path.lineTo(cPointX + (cPointX - lEndPointX), lEndPointY); <span class="comment">//左右两个结束点相连</span></span><br><span class="line">        path.quadTo(cPointX + (cPointX - lControlPointX), lControlPointY, w, <span class="number">0</span>); <span class="comment">//画右边贝塞尔曲线</span></span><br><span class="line"></span><br><span class="line">        updateContentLayout(cPointX, cPaintY, cRadius);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测量并设置中心Drawable</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> radius</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateContentLayout</span><span class="params">(<span class="keyword">float</span> cx, <span class="keyword">float</span> cy, <span class="keyword">float</span> radius)</span> </span>&#123;</span><br><span class="line">        Drawable drawable = content;</span><br><span class="line">        <span class="keyword">if</span> (drawable != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> margin = mContentDrawableMargin;</span><br><span class="line">            <span class="keyword">int</span> l = (<span class="keyword">int</span>) (cx - radius + margin);</span><br><span class="line">            <span class="keyword">int</span> r = (<span class="keyword">int</span>) (cx + radius - margin);</span><br><span class="line">            <span class="keyword">int</span> t = (<span class="keyword">int</span>) (cy - radius + margin);</span><br><span class="line">            <span class="keyword">int</span> b = (<span class="keyword">int</span>) (cy + radius - margin);</span><br><span class="line">            drawable.setBounds(l, t, r, b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>其中每一行我都备注了注释，要理解其中的计算，就得先上个图：</p>
<p><img src="http://p07lh1fh6.bkt.clouddn.com/touchpullview.jpg-sy" alt=""></p>
<p>我们脑海中要有一个清晰的定义，整个坐标系是基于起始点为原点，向右下延伸X，Y轴，左右的贝塞尔曲线是由一支画笔完成,通过lineTo相连接，因此整个曲线呈V字形。<br>接下来看代码：<br>首先求得了progress，这个无需解释，使用加速器只是为了更好的效果。<br>接下来是w和h,这是控件的某一进度下的宽和高，为什么通过getValueByLine方法就能得到呢？请看输入的参数，起始点是getWidth，也就是整个屏幕的宽度，终点是mTargetWidth也就是我们规定的最小宽度，而getValueByLine正好是求得某一时刻的贝塞尔值，因此将progress输入正好求得从整个屏幕运动到最小宽度之间的某一个宽度，高度同理。<br>宽高求出来了那个圆心的坐标也就相应出来了，注意整个圆的大小包含margin值，也就是圆与左右两边的边距也是包含的。因为mTargetGravityHeight是我们设定的控制点下移的高度，因此也就是控制点Y的坐标。<br>因为quadTo方法需要控制点的坐标和结束点的坐标，因此求出这两个点的坐标就大功告成了，接下来就是数学知识了。<br>首先，通过插值器的方法获得了某一时刻的角度，最后通过Math方法得到了弧度,也就是图中b的角度，半径我们是知道的，所以通过sin可以得出图中x的长度，然后通过半径的x坐标减去x的长度就得到了结束点的x坐标。<br>通过cos我们可以得到y的长度,圆心Y的坐标加上y的坐标就得到了结束点y的坐标，lEndPointX，lEndPointY的值也就得到了。<br>因为我们已知控制点上下运行的起始值和最大值，因此我们可以使用getValueByLine获取到当前的y坐标，接下来只需要求出控制点的x坐标就行了,tHeight表示左边这条直角的长直角边，结束点的y坐标已知，控制点的y坐标已知，因此可以求出tHeight。<br>因为平行线间的角度相等，因此a = c，又因为c+d = e+d = 90; 所以c = e；所以a = e;tHeight已知，e已知，所以tWidth的值就能求出来了。所以控制点的x坐标就等于结束点的x坐标减去tWidth。至此所有的坐标都已经求出来了，所以贝塞尔曲线也就能绘制出来了。</p>
<p>接下来还有个测量的过程，逻辑比较简单：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> MIN_W = (<span class="keyword">int</span>) (mCircleRadius * <span class="number">2</span> + getPaddingLeft() + getPaddingRight()); <span class="comment">//需要的最小宽度</span></span><br><span class="line">       <span class="keyword">int</span> MIN_H = (<span class="keyword">int</span>) ((mDargHeight * mProgress + <span class="number">0.5f</span>)  <span class="comment">//mDargHeight * mProgress = moveSize(即actionMove.getY - actionDown.getY),+0.5f为四舍五入</span></span><br><span class="line">               + getPaddingBottom() + getPaddingTop());</span><br><span class="line">       <span class="keyword">int</span> widthMeasure = getMeasureSize(widthMeasureSpec, MIN_W);</span><br><span class="line">       <span class="keyword">int</span> heightMeasure = getMeasureSize(heightMeasureSpec, MIN_H);</span><br><span class="line">       setMeasuredDimension(widthMeasure, heightMeasure);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取所需要的宽/高的测量结果</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> Spec     测量模式</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> minValue 规定的最小值</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 测量结果</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMeasureSize</span><span class="params">(<span class="keyword">int</span> Spec, <span class="keyword">int</span> minValue)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> result;</span><br><span class="line">       <span class="keyword">int</span> mode = MeasureSpec.getMode(Spec);</span><br><span class="line">       <span class="keyword">int</span> size = MeasureSpec.getSize(Spec);</span><br><span class="line">       <span class="keyword">switch</span> (mode) &#123;</span><br><span class="line">           <span class="keyword">case</span> MeasureSpec.AT_MOST: <span class="comment">//wrap_content</span></span><br><span class="line">               result = Math.min(size, minValue); <span class="comment">//取测量值和规定的最小宽度中的最小值</span></span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> MeasureSpec.EXACTLY: <span class="comment">//match_parent or exactly num</span></span><br><span class="line">               result = size;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">default</span>: <span class="comment">//其余情况取最小值</span></span><br><span class="line">               result = minValue;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>我将视频中的代码做了一下简单的封装，代码中有详细的注释，我这里就不做分析了。</p>
<p>整个分析流程就到这，如果有错误的地方，欢迎指正，Thanks~</p>
]]></content>
      
        <categories>
            
            <category> Android基础进阶 </category>
            
            <category> 安卓特效合集解析 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[安卓View体系-View的工作流程]]></title>
      <url>/%E5%AE%89%E5%8D%93View%E4%BD%93%E7%B3%BB-View%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.html</url>
      <content type="html"><![CDATA[<blockquote>
<p>自定义View三部曲：onMeasure –&gt; onLayout –&gt;onDraw,本文着重解析前两个方法</p>
</blockquote>
<h4 id="onMeasure"><a href="#onMeasure" class="headerlink" title="onMeasure"></a>onMeasure</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>提到这个方法，就必须先了解MeasureSpec这个类，它有一个getMode和getSize方法，用于获取SpecMode和SpecSize,那么这两个参数又是何物呢？<br>请看以下一般自定义View的完整实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">          setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(),widthMeasureSpec),getDefaultSize(getSuggestedMinimumHeight(),heightMeasureSpec));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size,<span class="keyword">int</span> measureSpec)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> result = size;</span><br><span class="line">       <span class="keyword">int</span> SpecMode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">       <span class="keyword">int</span> SpecSize = MeasureSpec.getSize(measureSpec);</span><br><span class="line">       <span class="keyword">switch</span> (SpecMode)&#123;</span><br><span class="line">           <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">               result = size;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">                   <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">                       result = SpecSize;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，SpecMode是指测量的模式，它有三种模式：</p>
<p><strong>UNSPECIFIED</strong><br>代表父容器不对View有任何的大小限制，一般用于系统的内部，很少用到</p>
<p><strong>AT_MOST</strong><br>代表父容器指定了一个大小即SpecSize,View的大小不能大于这个值，它对应于LayoutParams中的wrap_content，结合它你就很好理解了</p>
<p><strong>EXACTLY</strong><br>父容器已经检测到了view所需的精确大小，这时的view的最终大小就是SpecSize中的值，它对应于LayoutParam中的match_parent或者具体的数值</p>
<p>而SpecSize是指某种模式下的规格大小。</p>
<p>因此，结合此方法，当view的大小是wrap_content或者是match_parent或者是具体的数值时，都是使用的父容器给子view测量的specsize的值，当父容器对子view没有任何约束时，给view一个所规定的最小值（getSuggestedMinimum…方法获取）,setMeasuredDimension就是用来设置view的测量大小的。MeasureSpec类的值的获取是由父容器的MeasureSpec和自身的LayoutParams来共同确定的，MeasureSpec一旦确定，onMeasure中就可以确定view的测量宽高了。</p>
<p>这里再来讲解一下getSuggestedMinimumWidth这类方法，它的逻辑是这样的：<br>如果View没有设置背景，那么它会返回minWidth设置的值，可以为0，如果view设置了背景，那么它会返回minWidth和背景最小宽度的两者之间的最大值。</p>
<p>一般的自定义View我们主要是着重处理AT_MOST模式的值，需要根据实际的情况来，没有固定的依据，有兴趣的可以看下TextView等控件的源码是怎么处理的。</p>
<p><strong>Activity中View的宽/高获取</strong><br>通过以上分析读者已经知道View的宽高是需要父容器去测量的，因此我们如果在onCreate或者onStar方法中去获取View的宽高发现并不能保证百分百获取到，那么有什么方法能解决这个问题呢，以下有4个方法能解决这个问题：</p>
<p><strong>1.onWindowFocusChanged</strong><br>当Activity的窗口得到焦点或失去焦点都会被调用一次,并且此时View已经初始化完毕，因此此时去获取View的宽高是没问题的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onWindowFocusChanged</span><span class="params">(<span class="keyword">boolean</span> hasFocus)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>.onWindowFocusChanged(hasFocus);</span><br><span class="line">       <span class="keyword">if</span> (hasFocus)&#123;</span><br><span class="line">           <span class="keyword">int</span> width = view.getMeasuredWidth();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>2.view.post(runnable)</strong><br>通过post可以将一个runnable投递到消息队列的尾部，然后等待Looper调用此runnable的时候，view此时也已经初始化好了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">view.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">int</span> width = view.getMeasuredWidth();    </span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure></p>
<p><strong>3.ViewTreeObserver</strong><br>使用ViewTreeObserver这个类的回调可以完成，比如OnGlobalLayoutListener，当View树的状态改变或者内部view的可见性发生改变时，该接口会被回调，注意，此接口会回调多次。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ViewTreeObserver viewTreeObserver = view.getViewTreeObserver();</span><br><span class="line">       viewTreeObserver.addOnGlobalLayoutListener(<span class="keyword">new</span> ViewTreeObserver.OnGlobalLayoutListener() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onGlobalLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               view.getViewTreeObserver().removeOnGlobalLayoutListener(<span class="keyword">this</span>);</span><br><span class="line">               <span class="keyword">int</span> width = view.getMeasuredWidth();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure></p>
<p><strong>4.view.measure(int widthMeasureSpec, int heightMeasureSpec)</strong><br>手动对view进行测量来得出view的宽高，这种实现比较的复杂，需要看view的LayoutParam：</p>
<p><em>match_parent</em><br>无法得出View的宽/高，因为此种情况需要获取到父容器的剩余空间，而此时我们是获取不到的</p>
<p><em>具体的数值</em><br>比如宽/高都是50px,那么我们可以这样写来获取：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> widthMeasureSpec = View.MeasureSpec.makeMeasureSpec(<span class="number">100</span>, View.MeasureSpec.EXACTLY);</span><br><span class="line"><span class="keyword">int</span> heightMeasureSpec = View.MeasureSpec.makeMeasureSpec(<span class="number">100</span>,View.MeasureSpec.EXACTLY);</span><br><span class="line">view.measure(widthMeasureSpec,heightMeasureSpec);</span><br></pre></td></tr></table></figure></p>
<p><em>wrap_content</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">int</span> widthMeasureSpec = View.MeasureSpec.makeMeasureSpec((<span class="number">1</span>&lt;&lt;<span class="number">30</span>)-<span class="number">1</span>, View.MeasureSpec.AT_MOST);</span><br><span class="line"><span class="keyword">int</span> heightMeasureSpec = View.MeasureSpec.makeMeasureSpec((<span class="number">1</span>&lt;&lt;<span class="number">30</span>)-<span class="number">1</span>,View.MeasureSpec.AT_MOST);        </span><br><span class="line">view.measure(widthMeasureSpec,heightMeasureSpec);</span><br></pre></td></tr></table></figure></p>
<p>注意(1&lt;&lt;30)-1这个值，通过查看源码可以知道View的尺寸是使用的30位二进制表示，所以最大值是30个1（2^30-1），也就等于（1&lt;&lt;30）-1，所以给出这个数值是合理的。</p>
<h4 id="onLayout"><a href="#onLayout" class="headerlink" title="onLayout"></a>onLayout</h4><p>onLayout方法是ViewGroup用来给子元素确定位置的，相比如onMeasure方法，onLayout则简单多了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>.onLayout(changed, left, top, right, bottom);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>后四个参数分别代表左，上，右，下，只需返回不同的坐标即可确定View的位置。</p>
]]></content>
      
        <categories>
            
            <category> Android基础进阶 </category>
            
            <category> 安卓View体系 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[安卓View体系:View的一些基本知识点]]></title>
      <url>/%E5%AE%89%E5%8D%93View%E4%BD%93%E7%B3%BB-View%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E7%82%B9.html</url>
      <content type="html"><![CDATA[<blockquote>
<p>安卓开发中熟练使用自定义View是开发者必备的技能，因为安卓原生控件很多时候是不能满足需求的，而自定义控件能做出各种绚丽的效果,用于满足产品各种奇怪的需求(我为什么要用奇怪呢，哈哈哈哈)。</p>
</blockquote>
<h4 id="自定义View要掌握的内容"><a href="#自定义View要掌握的内容" class="headerlink" title="自定义View要掌握的内容"></a>自定义View要掌握的内容</h4><p>自定义View主要是掌握以下五个内容：</p>
<ul>
<li>绘制原理: 掌握onMeasure,onLayout,onDraw及相关类的使用。</li>
<li>事件传递：掌握dispathTouchEvent(),onInterceptEvent(),onTouchEvent()三者的传递逻辑.</li>
<li>动画：属性动画，用于对View进行动画操作</li>
<li>相关手势：GestureDetector，VelocityTracker等类的应用</li>
<li>滑动：滑动的三种实现方法，Scroller的运用</li>
</ul>
<h4 id="自定义View的基本知识"><a href="#自定义View的基本知识" class="headerlink" title="自定义View的基本知识"></a>自定义View的基本知识</h4><h5 id="自定义View的分类"><a href="#自定义View的分类" class="headerlink" title="自定义View的分类"></a>自定义View的分类</h5><p><strong>1. 直接继承View</strong><br>主要用于实现一些不规则的效果，不能通过现有控件扩展的一些效果</p>
<p><strong>2. 继承自viewGroup</strong><br>主要是为了实现自定义的布局，这个布局里包含了一些特定的控件，很像几个view组合在一起</p>
<p><strong>3.继承特定的view</strong><br>主要是为了扩展已有view的功能，比如TextView等</p>
<p><strong>4.继承特定的ViewGroup</strong><br>为了扩展特定的布局，比如LinearLayout</p>
<h5 id="自定义控件的构造函数"><a href="#自定义控件的构造函数" class="headerlink" title="自定义控件的构造函数"></a>自定义控件的构造函数</h5><p>建立一个class类继承自View,实现它的所有的构造方法，那么这个类就是一个可以在xml中使用的自定义View，以下是关于它的构造方法的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jie.demo_01.View;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.support.annotation.Nullable;</span><br><span class="line"><span class="keyword">import</span> android.util.AttributeSet;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">mView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">mView</span><span class="params">(Context context)</span> </span>&#123;  <span class="comment">//在代码中直接new出这个实例会调用这个方法</span></span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">mView</span><span class="params">(Context context, @Nullable AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//在xml中实现会调用这个方法（未指定style）</span></span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">mView</span><span class="params">(Context context, @Nullable AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//为view指定了一个style</span></span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">mView</span><span class="params">(Context context, @Nullable AttributeSet attrs, <span class="keyword">int</span> defStyleAttr, <span class="keyword">int</span> defStyleRes)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//api&gt;21时调用，一般不用实现</span></span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr, defStyleRes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关于构造函数中参数的含义：</p>
<ul>
<li><p>AttributeSet set:  属性值的集合.</p>
</li>
<li><p>int[] attrs:  我们自定义属性集合在R类中生成的int型数组.这个数组中包含了自定义属性的资源ID.</p>
</li>
<li><p>int defStyleAttr:  这是当前Theme中的包含的一个指向style的引用.当我们没有给自定义View设置declare-styleable资源集合时,默认从这个集合里面查找布局文件中配置属性值.传入0表示不向该defStyleAttr中查找默认值.</p>
</li>
<li><p>int defStyleRes:  这个也是一个指向Style的资源ID,但是仅在defStyleAttr为0或者defStyleAttr不为0但Theme中没有为defStyleAttr属性赋值时起作用.</p>
</li>
</ul>
<blockquote>
<p>属性赋值优先级次序表:<br>在布局xml中直接定义 &gt; 在布局xml中通过style定义 &gt; 自定义View所在的Activity的Theme中指定style引用 &gt; 构造函数中defStyleRes指定的默认值</p>
</blockquote>
<h5 id="自定义view的xml赋值"><a href="#自定义view的xml赋值" class="headerlink" title="自定义view的xml赋值"></a>自定义view的xml赋值</h5><p>我们经常可以看到使用xml的属性可以为view进行各种赋值,那么是怎么做到的呢，如图，在values目录下新建一个attrs.xml的文件，文件内容如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;resources&gt;</span><br><span class="line">    &lt;declare-styleable name=<span class="string">"mView"</span>&gt;</span><br><span class="line">        &lt;attr name=<span class="string">"mview_color"</span> format=<span class="string">"color"</span>/&gt;</span><br><span class="line">    &lt;/declare-styleable&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure></p>
<p>我在这里声明了一个mview_color属性，用于定义颜色值，format代表属性的格式，有许多，读者查阅文档即可了解。</p>
<p>接下来,我在View中做如下处理：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">mView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> defultColor = <span class="number">0xFFFFFF6</span>;</span><br><span class="line">    <span class="keyword">int</span> mColor;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">mView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">mView</span><span class="params">(Context context, @Nullable AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, attrs,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">mView</span><span class="params">(Context context, @Nullable AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">        TypedArray t = context.obtainStyledAttributes(attrs, R.styleable.mView);</span><br><span class="line">        mColor = t.getColor(R.styleable.mView_mview_color,defultColor);</span><br><span class="line">        t.recycle(); <span class="comment">//记得回收</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用TypedArray来解析我们定义的属性,接着就赋值给我们的变量，最后回收，这样解析工作就完成了</p>
<p>接下来我们在xml中使用我们的View:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">   <span class="comment">//为了使用自定义属性，必须作此声明，app可以换成其他的名字</span></span><br><span class="line">    xmlns:app=<span class="string">"http://schemas.android.com/apk/res-auto"</span>  </span><br><span class="line">    xmlns:tools=<span class="string">"http://schemas.android.com/tools"</span></span><br><span class="line">    android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">    android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">    tools:context=<span class="string">"com.jie.demo_01.MainActivity"</span>&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;com.jie.demo_01.View.mView</span><br><span class="line">        android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">        android:layout_height=<span class="string">"100dp"</span> </span><br><span class="line">        app:mview_color=<span class="string">"@color/colorAccent"</span>  <span class="comment">//声明我们的自定义属性</span></span><br><span class="line">        /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure></p>
<h5 id="自定义view的绘制"><a href="#自定义view的绘制" class="headerlink" title="自定义view的绘制"></a>自定义view的绘制</h5><p>属性已经定义好了，接下来就是如何使用了，在这里我们重写它的onDraw方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">mView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> defultColor = <span class="number">0xFFFFFF6</span>;</span><br><span class="line">    <span class="keyword">int</span> mColor;</span><br><span class="line">    <span class="keyword">private</span> Paint mPaint = <span class="keyword">new</span> Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">mView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">mView</span><span class="params">(Context context, @Nullable AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, attrs,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">mView</span><span class="params">(Context context, @Nullable AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">        TypedArray t = context.obtainStyledAttributes(attrs, R.styleable.mView);</span><br><span class="line">        mColor = t.getColor(R.styleable.mView_mview_color,defultColor);</span><br><span class="line">        t.recycle(); <span class="comment">//记得回收</span></span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mPaint.setColor(mColor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line">        canvas.drawCircle(<span class="number">200</span>,<span class="number">200</span>,<span class="number">100</span>,mPaint);  <span class="comment">//绘制一个位于200，200处的半径为100的圆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>onDraw方法是view绘制图形图像的地方，通过画布（canvas）和画笔（paint）来灵活的绘制各种图形，这两个类所包含的方法多而全，读者可以多阅读文档来练习绘制各种图形,代码运行如图所示：</p>
<p><img src="http://p07lh1fh6.bkt.clouddn.com/%E5%BA%94%E7%94%A8%E5%AE%9D%E6%88%AA%E5%B1%8F2017121601.png-suofang" alt=""></p>
<h4 id="自定义View的注意事项"><a href="#自定义View的注意事项" class="headerlink" title="自定义View的注意事项"></a>自定义View的注意事项</h4><p>上面的自定义view并不是一个标准的自定义view,标准的自定义view还应该包含onMeasure和onLayout的处理，让其支持wrap_content。</p>
<p>这里要注意了：</p>
<ul>
<li><p>直接继承view或者viewgroup的控件不支持wrap_content,需要在onMeasure中进行特殊的处理才能达到预期的效果</p>
</li>
<li><p>如果有必要的话，需要在draw方法中处理padding，使view控件的padding生效，否则padding是无效的</p>
</li>
<li><p>尽量不在view中使用handler,因为view本身自带了post方法</p>
</li>
<li><p>如果在view中有线程或者动画，要及时关闭，关闭的时机是onDetachedFromWindow方法，当包含此view的Activity退出或者view被remove掉时，此方法会被调用</p>
</li>
<li><p>不要再onDraw方法中作初始化操作，因为这个方法会绘制多次，会产生很多不必要的开销</p>
</li>
<li><p>当View有滑动嵌套的情况，要处理好滑动冲突</p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Android基础进阶 </category>
            
            <category> 安卓View体系 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[安卓IPC机制:AIDL通信的使用和理解]]></title>
      <url>/%E5%AE%89%E5%8D%93IPC%E6%9C%BA%E5%88%B6-AIDL%E9%80%9A%E4%BF%A1%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E7%90%86%E8%A7%A3.html</url>
      <content type="html"><![CDATA[<h4 id="使用情景"><a href="#使用情景" class="headerlink" title="使用情景"></a>使用情景</h4><p>虽然Messenger对AIDL做了封装使其变得更易用，但Messenger只能一个一个的处理接收的数据,当有大量并发的数据涌入时，Messenger就显得不那么合适了,并且Messenger只能用来传递消息，如果需要调用跨进程的方法怎么办呢，这是，AIDL就派上用场了。<br><a id="more"></a></p>
<h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>首先创建一个AIDL文件,在里面声明一些需要用到的方法接口，注意，并不是所有的数据类型在AIDL中都能使用，AIDL能够使用的数据类型如下:</p>
<ul>
<li>基本数据类型</li>
<li>String,CharSequence</li>
<li>ArrayList,里面包含的元素必须支持AIDL</li>
<li>HashMap,里面包含的key和value必须被AIDL支持</li>
<li>Parcelable,所有实现了Parcelable接口的对象</li>
<li>AIDL接口本身也支持</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IBookManager.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.jie.demo_01;</span><br><span class="line"><span class="keyword">import</span> com.jie.demo_01.Book;</span><br><span class="line"><span class="comment">// Declare any non-default types here with import statements</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IBookManager</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;Book&gt; <span class="title">getBookList</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addBook</span><span class="params">(in Book book)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，我在里面引入了Book实体类，按照AIDL的规则，是需要再创建一个Book.aidl文件的，并且需要手动将引入路径导入<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Book.aidl.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.jie.demo_01;</span><br><span class="line">parcelable Book;</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，AIDL中每个实现了Parcelable接口的类都需要按照这种方式创建相应的文件并且申明该类为Parcelable，并且，AIDL中除了基本数据类型，其他的参数都必须标上方向：</p>
<ul>
<li>in 表示输入型的参数</li>
<li>out 表示输出型的参数</li>
<li>inout 表示输入输出型参数<br>并且AIDL不支持声明静态变量。</li>
</ul>
<p>下面是远程服务端的实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jie.demo_01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Service;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.os.Binder;</span><br><span class="line"><span class="keyword">import</span> android.os.IBinder;</span><br><span class="line"><span class="keyword">import</span> android.os.RemoteException;</span><br><span class="line"><span class="keyword">import</span> android.support.annotation.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">mService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CopyOnWriteArrayList&lt;Book&gt; mBookList = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;(); <span class="comment">//支持并发读写的一个类，非Arraylist</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Binder mbinder = <span class="keyword">new</span> IBookManager.Stub() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">getBookList</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mBookList;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(Book book)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">             mBookList.add(book);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mbinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        mBookList.add(<span class="keyword">new</span> Book(<span class="number">1</span>,<span class="string">"Kotlin实战"</span>));</span><br><span class="line">        mBookList.add(<span class="keyword">new</span> Book(<span class="number">2</span>,<span class="string">"编程珠玑"</span>));</span><br><span class="line">        mBookList.add(<span class="keyword">new</span> Book(<span class="number">3</span>,<span class="string">"Java数据与结构算法解析"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>服务端的实现比较简单，主要是通过<code>IBookManager.Stub</code>来获取<code>Binder</code>对象并实现定义的方法,最后在<code>onBind</code>中绑定<code>`Binder</code>对象,其中，<code>IBookManager</code>这个类是自动生成的，位于gen目录的aidl文件夹中,关于该类稍后再做分析。</p>
<p>以下是客户端的实现,也比较简单:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jie.demo_01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.ComponentName;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.content.ServiceConnection;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.os.IBinder;</span><br><span class="line"><span class="keyword">import</span> android.os.RemoteException;</span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ServiceConnection mConnection = <span class="keyword">new</span> ServiceConnection() &#123;  <span class="comment">//Ibind监听，注意绑定是异步的</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName componentName, IBinder iBinder)</span> </span>&#123; <span class="comment">//当与Service建立连接时调用</span></span><br><span class="line">             IBookManager manager = IBookManager.Stub.asInterface(iBinder); <span class="comment">//获取AIDL管理类</span></span><br><span class="line">             <span class="comment">//得到数据</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                List&lt;Book&gt; bookList = manager.getBookList();  <span class="comment">//这里实际上就是调用了Binder中的方法</span></span><br><span class="line">                Log.i(<span class="string">"hj"</span>,<span class="string">"从服务端获取的集合大小:"</span>+bookList.size());</span><br><span class="line">                <span class="keyword">if</span> (bookList.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    Log.i(<span class="string">"hj"</span>,<span class="string">"第一个书名是:"</span>+bookList.get(<span class="number">0</span>).bookName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName componentName)</span> </span>&#123;  <span class="comment">//与Service意外中断时调用</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>,mService.class);</span><br><span class="line">        bindService(intent,mConnection,BIND_AUTO_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        unbindService(mConnection);</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行后打印如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span>-<span class="number">09</span> <span class="number">17</span>:<span class="number">05</span>:<span class="number">46.447</span> <span class="number">19690</span>-<span class="number">19690</span>/? I/hj: 从服务端获取的集合大小:<span class="number">3</span></span><br><span class="line"><span class="number">12</span>-<span class="number">09</span> <span class="number">17</span>:<span class="number">05</span>:<span class="number">46.448</span> <span class="number">19690</span>-<span class="number">19690</span>/? I/hj: 第一个书名是:Kotlin实战</span><br></pre></td></tr></table></figure></p>
<p>运行原理是通过<code>IBookManager.Stub.asInterface</code>方法获取到<code>IBookManager</code>,从而调用里面的方法来实现数据的传递与方法之间的调用，注意，这些方法都是运行在UI线程中的，所以不能有耗时的操作，如果有耗时的操作，应该新开启一个线程来解决。</p>
<p>还有一点需要注意的是，如果有类似于订阅者的实现，在进程通信中，不能简单的用List来管理接口，因为进程中的对象传输后其实变成了两个不同的对象，那么订阅和取消订阅将会失效，因此，系统提供了一个叫<code>RemoteCallbackList</code>的接口专门用来管理跨进程的接口，它的使用也很简单：</p>
<ul>
<li>beginBroadcast()方法会返回该类里所有集合的大小</li>
<li>getBroadcastItem(int position) 返回指定的item</li>
<li>finishBroadcast()  结束遍历</li>
</ul>
<p>通过以上三个方法可以循环遍历订阅者接口来达到取消订阅的目的。注意beginBroadcast和finishBroadcast必须配对使用</p>
<h4 id="IBookManager-类分析"><a href="#IBookManager-类分析" class="headerlink" title="IBookManager 类分析"></a>IBookManager 类分析</h4><p>通过以上的AIDL实现，我们发现了IBookManager类起到了制关重要的作用,所以我们来深入观察一下该类，理解了该类有助于我们更好的使用AIDL.以下是该类的源码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This file is auto-generated.  DO NOT MODIFY.</span></span><br><span class="line"><span class="comment"> * Original file: D:\\MyWork\\Studio_Work\\demo_01\\app\\src\\main\\aidl\\com\\jie\\demo_01\\IBookManager.aidl</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.jie.demo_01;</span><br><span class="line"><span class="comment">// Declare any non-default types here with import statements</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBookManager</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">IInterface</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Local-side IPC implementation stub class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Stub</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">Binder</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">jie</span>.<span class="title">demo_01</span>.<span class="title">IBookManager</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.String DESCRIPTOR = <span class="string">"com.jie.demo_01.IBookManager"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Construct the stub at attach it to the interface.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Stub</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.attachInterface(<span class="keyword">this</span>, DESCRIPTOR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Cast an IBinder object into an com.jie.demo_01.IBookManager interface,</span></span><br><span class="line"><span class="comment">         * generating a proxy if needed.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> com.jie.demo_01.<span class="function">IBookManager <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> ((obj == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">            <span class="keyword">if</span> (((iin != <span class="keyword">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> com.jie.demo_01.IBookManager))) &#123;</span><br><span class="line">                <span class="keyword">return</span> ((com.jie.demo_01.IBookManager) iin);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> com.jie.demo_01.IBookManager.Stub.Proxy(obj);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">                <span class="keyword">case</span> INTERFACE_TRANSACTION: &#123;</span><br><span class="line">                    reply.writeString(DESCRIPTOR);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> TRANSACTION_getBookList: &#123;</span><br><span class="line">                    data.enforceInterface(DESCRIPTOR);</span><br><span class="line">                    java.util.List&lt;com.jie.demo_01.Book&gt; _result = <span class="keyword">this</span>.getBookList();</span><br><span class="line">                    reply.writeNoException();</span><br><span class="line">                    reply.writeTypedList(_result);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> TRANSACTION_addBook: &#123;</span><br><span class="line">                    data.enforceInterface(DESCRIPTOR);</span><br><span class="line">                    com.jie.demo_01.Book _arg0;</span><br><span class="line">                    <span class="keyword">if</span> ((<span class="number">0</span> != data.readInt())) &#123;</span><br><span class="line">                        _arg0 = com.jie.demo_01.Book.CREATOR.createFromParcel(data);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        _arg0 = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">this</span>.addBook(_arg0);</span><br><span class="line">                    reply.writeNoException();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">jie</span>.<span class="title">demo_01</span>.<span class="title">IBookManager</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> android.os.IBinder mRemote;</span><br><span class="line"></span><br><span class="line">            Proxy(android.os.IBinder remote) &#123;</span><br><span class="line">                mRemote = remote;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mRemote;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getInterfaceDescriptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> DESCRIPTOR;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> java.util.List&lt;com.jie.demo_01.Book&gt; getBookList() <span class="keyword">throws</span> android.os.RemoteException &#123;</span><br><span class="line">                android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">                android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">                java.util.List&lt;com.jie.demo_01.Book&gt; _result;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">                    mRemote.transact(Stub.TRANSACTION_getBookList, _data, _reply, <span class="number">0</span>);</span><br><span class="line">                    _reply.readException();</span><br><span class="line">                    _result = _reply.createTypedArrayList(com.jie.demo_01.Book.CREATOR);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    _reply.recycle();</span><br><span class="line">                    _data.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> _result;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(com.jie.demo_01.Book book)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">                android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">                android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">                    <span class="keyword">if</span> ((book != <span class="keyword">null</span>)) &#123;</span><br><span class="line">                        _data.writeInt(<span class="number">1</span>);</span><br><span class="line">                        book.writeToParcel(_data, <span class="number">0</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        _data.writeInt(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    mRemote.transact(Stub.TRANSACTION_addBook, _data, _reply, <span class="number">0</span>);</span><br><span class="line">                    _reply.readException();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    _reply.recycle();</span><br><span class="line">                    _data.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_getBookList = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_addBook = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> java.util.List&lt;com.jie.demo_01.Book&gt; getBookList() <span class="keyword">throws</span> android.os.RemoteException;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(com.jie.demo_01.Book book)</span> <span class="keyword">throws</span> android.os.RemoteException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到该类的结构还是比较清晰的,首先，它申明了getBookList和addBook两个方法，显然这是我在aidl接口中申明的方法，接着，还申明了两个int型的id,TRANSACTION_getBookList 和TRANSACTION_addBook，这两个id是为了在transact过程中区分客户端请求的是哪个方法，接着，它申明了一个内部类Stub,它是一个Binder类，接着还申明了一个Stub的内部代理类，以上就是该类的结构。下面详细介绍一下各个方法的作用</p>
<p>首先是<code>Stub</code> 类的方法：</p>
<p><strong>asInterface(android.os.IBinder obj)</strong><br>传入一个Binder对象，转换成客户端所需要的AIDL接口类型的对象，这种转换是区分进程的，如果服务端和客户端是在一个进程中，那么该方法会返回Stub对象本身，如果是两个进程，那么会返回Stub.proxy对象。</p>
<p><strong>adBinder</strong><br>返回Binder对象.</p>
<p><strong>onTransact（(int code, android.os.Parcel data, android.os.Parcel reply, int flags）</strong><br>该方法是返回一个boolean对象，运行在Binder线程池中，当客户端发起请求，远程会通过系统底层封装后由此方法处理。code参数可以确定客户端请求的方法是什么，data中能取出目标的参数，然后执行目标的方法，当执行完毕后，就向reply中写入返回值（如果有返回值的话），而返回的boolean对象，如果为false,那么客户端会请求失败，因此可以通过这个返回值做权限验证。</p>
<p><code>Proxy</code>中的方法：</p>
<p><strong>getBookList</strong><br>此方法运行在客户端，当客户端远程调用此方法时，它会创建该方法所需要的输入型Parcel对象data,输出型Parcel对象,_reply和返回值对象List,然后将该方法的参数信息写入_data中（如果有参数的话）；接着调用transact方法来发起请求，同时当前线程挂起，然后服务端的onTransatct方法会被调用，直到远程调用返回，当前线程继续执行，并从_reply中取出远程调用过程的返回结果，最后返回_reply数据。</p>
<p><strong>addBook</strong><br>同<code>getBookList</code>一样，因为没有返回值，所以不需要从_reply中取值</p>
<p>整体来说整个类还是易于理解的，大多其实都是偏底层的实现,需要注意的是,客户端通过接口方法发起请求时，当前线程会被挂起直到服务端返回数据，因此，如果一个远程的方法非常耗时，那么就不能在主线程中发起请求，需要另开一个线程。</p>
]]></content>
      
        <categories>
            
            <category> Android基础进阶 </category>
            
            <category> 安卓IPC机制 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[安卓IPC机制:使用Messenger通信]]></title>
      <url>/%E5%AE%89%E5%8D%93IPC%E6%9C%BA%E5%88%B6-%E4%BD%BF%E7%94%A8Messenger%E9%80%9A%E4%BF%A1.html</url>
      <content type="html"><![CDATA[<h4 id="Messenger原理"><a href="#Messenger原理" class="headerlink" title="Messenger原理"></a>Messenger原理</h4><p>Messenger的底层实现是AILD，它是一个Message的载体，通过它可以在不同进程间传递message对象,从而实现数据传递<br><a id="more"></a></p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>代码示例：<br>首先创建一个Service，让它运行在一个单独的进程中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;service android:name=<span class="string">".mService"</span></span><br><span class="line">           android:process=<span class="string">":remote"</span></span><br><span class="line">           /&gt;</span><br></pre></td></tr></table></figure></p>
<p>然后再来看服务端<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">mService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Messenger messenger = <span class="keyword">new</span> Messenger(<span class="keyword">new</span> messengerHandler());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">messengerHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> Constants.MSG_FROM_CLIENT:</span><br><span class="line">                    String clientMsg = msg.getData().getString(<span class="string">"msg"</span>);  <span class="comment">//接收客户端的消息</span></span><br><span class="line">                    Log.i(<span class="string">"hj"</span>,<span class="string">"从客户端接收到的消息:"</span>+clientMsg);</span><br><span class="line">                    Messenger messenger = msg.replyTo;  <span class="comment">//获取客户端发来的Messenger</span></span><br><span class="line">                    Message replyMessage = Message.obtain(<span class="keyword">null</span>,Constants.MSG_FROM_SERVICE);  <span class="comment">//创建一个新的Message对象</span></span><br><span class="line">                    Bundle bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">                    bundle.putString(<span class="string">"reply"</span>, <span class="string">"已收到客户端的消息，稍后回复~"</span>);</span><br><span class="line">                    replyMessage.setData(bundle);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        messenger.send(replyMessage);  <span class="comment">//发送消息给客户端</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> messenger.getBinder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建一个Handler并且传入到Messenger对象中,通过Handler来接收Message对象发来的消息,并且在Service的onBind中返回这个Messager对象底层的Binder。随后我又通过msg.replyTo方法获取到从客户端发来的Messenger对象，用于回复消息给客户端,最后调用send方法发出消息，这样就完成了消息的接收与回复，接下来再看客户端的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jie.demo_01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.ComponentName;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.content.ServiceConnection;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.os.Handler;</span><br><span class="line"><span class="keyword">import</span> android.os.IBinder;</span><br><span class="line"><span class="keyword">import</span> android.os.Message;</span><br><span class="line"><span class="keyword">import</span> android.os.Messenger;</span><br><span class="line"><span class="keyword">import</span> android.os.RemoteException;</span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Messenger messenger;  <span class="comment">//客户端发送消息的messenger</span></span><br><span class="line">    <span class="keyword">private</span> ServiceConnection mConnection = <span class="keyword">new</span> ServiceConnection() &#123;  <span class="comment">//Ibind监听，注意绑定是异步的</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName componentName, IBinder iBinder)</span> </span>&#123; <span class="comment">//当与Service建立连接时调用</span></span><br><span class="line">              messenger = <span class="keyword">new</span> Messenger(iBinder);</span><br><span class="line">            Message message = Message.obtain(<span class="keyword">null</span>,Constants.MSG_FROM_CLIENT);</span><br><span class="line">            Bundle bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">            bundle.putString(<span class="string">"msg"</span>,<span class="string">"Service兄弟在吗，是否已收到回复"</span>);</span><br><span class="line">            message.setData(bundle);</span><br><span class="line">            message.replyTo = replyMessager;  <span class="comment">//注意这一句，将客户端用于接受消息的Messager对象传递给Service</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                messenger.send(message);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName componentName)</span> </span>&#123;  <span class="comment">//与Service意外中断时调用</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Messenger replyMessager = <span class="keyword">new</span> Messenger(<span class="keyword">new</span> GetReplyMessenger());  <span class="comment">//客户端接收消息的messenger</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">GetReplyMessenger</span> <span class="keyword">extends</span> <span class="title">Handler</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what)&#123;</span><br><span class="line">                <span class="keyword">case</span> Constants.MSG_FROM_SERVICE:</span><br><span class="line">                    String reply = msg.getData().getString(<span class="string">"reply"</span>);</span><br><span class="line">                    Log.i(<span class="string">"hj"</span>,<span class="string">"从Service接收到的消息:"</span>+reply);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>,mService.class);</span><br><span class="line">        bindService(intent,mConnection,BIND_AUTO_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        unbindService(mConnection);</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先是绑定一个Service，接下来在绑定监听中创建一个Messager对象,通过Messager就可以发消息给服务端了,注意，我在这里通过replyTo发送了一个新的Messager对象给服务端，这样服务端就可以回复消息给客户端了，客户端也是通过Handler来接收消息的。</p>
<p>运行结果如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span>-<span class="number">09</span> <span class="number">11</span>:<span class="number">16</span>:<span class="number">07.733</span> <span class="number">7900</span>-<span class="number">7900</span>/com.jie.demo_01:remote I/hj: 从客户端接收到的消息:Service兄弟在吗，是否已收到回复</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span>-<span class="number">09</span> <span class="number">11</span>:<span class="number">16</span>:<span class="number">07.753</span> <span class="number">7871</span>-<span class="number">7871</span>/com.jie.demo_01 I/hj: 从Service接收到的消息:已收到客户端的消息，稍后回复~</span><br></pre></td></tr></table></figure>
<p>可以看到两个不同进程之间通信成功了</p>
]]></content>
      
        <categories>
            
            <category> Android基础进阶 </category>
            
            <category> 安卓IPC机制 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[安卓IPC机制：使用文件共享]]></title>
      <url>/%E5%AE%89%E5%8D%93IPC%E6%9C%BA%E5%88%B6%EF%BC%9A%E4%BD%BF%E7%94%A8%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB.html</url>
      <content type="html"><![CDATA[<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>通过两个进程间读/写同一个文件来交换数据<br><a id="more"></a><br>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">package com.jie.demo_01;</span><br><span class="line"></span><br><span class="line">import android.content.Intent;</span><br><span class="line">import android.os.Bundle;</span><br><span class="line">import android.os.Environment;</span><br><span class="line">import android.support.v7.app.AppCompatActivity;</span><br><span class="line">import android.view.View;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line"></span><br><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onResume() &#123;</span><br><span class="line">        super.onResume();</span><br><span class="line">        initWriteToFile();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  //点击跳转到SecondActivity</span><br><span class="line">    public void start(View v)&#123;</span><br><span class="line">        startActivity(new Intent(MainActivity.this,SecondActivity.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void initWriteToFile()&#123;</span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                User user = new User();</span><br><span class="line">                user.userName = &quot;Hello World&quot;;</span><br><span class="line">                File file = new File(getDiskCacheDir());</span><br><span class="line">                ObjectOutputStream oos = null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    oos = new ObjectOutputStream(new FileOutputStream(file));</span><br><span class="line">                    oos.writeObject(user);</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;finally &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        if (oos!=null)</span><br><span class="line">                        oos.close();</span><br><span class="line">                    &#125; catch (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getDiskCacheDir() &#123;</span><br><span class="line">        String cachePath = null;</span><br><span class="line">        if (Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())</span><br><span class="line">                || !Environment.isExternalStorageRemovable()) &#123;</span><br><span class="line">            cachePath = getExternalCacheDir().getPath()+&quot;/cache.txt&quot;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            cachePath = getCacheDir().getPath()+&quot;/cache.txt&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        return cachePath;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>SecondActivity代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">package com.jie.demo_01;</span><br><span class="line"></span><br><span class="line">import android.os.Bundle;</span><br><span class="line">import android.os.Environment;</span><br><span class="line">import android.support.v7.app.AppCompatActivity;</span><br><span class="line">import android.util.Log;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line"></span><br><span class="line">public class SecondActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onResume() &#123;</span><br><span class="line">        super.onResume();</span><br><span class="line">        getCacheFromFile();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void getCacheFromFile ()&#123;</span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                User user = null;</span><br><span class="line">                File file = new File(getDiskCacheDir());</span><br><span class="line">                if (file.exists())&#123;</span><br><span class="line">                    ObjectInputStream ois = null;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        ois = new ObjectInputStream(new FileInputStream(file));</span><br><span class="line">                        user = (User) ois.readObject();</span><br><span class="line">                        Log.i(&quot;TAG&quot;,user.userName);</span><br><span class="line">                    &#125; catch (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getDiskCacheDir() &#123;</span><br><span class="line">        String cachePath = null;</span><br><span class="line">        if (Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())</span><br><span class="line">                || !Environment.isExternalStorageRemovable()) &#123;</span><br><span class="line">            cachePath = getExternalCacheDir().getPath()+&quot;/cache.txt&quot;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            cachePath = getCacheDir().getPath()+&quot;/cache.txt&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        return cachePath;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行后，打印出日志：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12-08 13:13:30.372 17706-17723/com.jie.demo_01.remote I/TAG: Hello World</span><br></pre></td></tr></table></figure></p>
<p>文件传值成功</p>
<p>文件传值并没有具体的要求，不管是通过txt,xml,等等都可以，需要注意的是文件的并发问题，要避免获取文件值得时候同时去修改文件，这样会造成数据的混乱。</p>
]]></content>
      
        <categories>
            
            <category> Android基础进阶 </category>
            
            <category> 安卓IPC机制 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[安卓IPC机制：Bundle数据传递]]></title>
      <url>/%E5%AE%89%E5%8D%93IPC%E6%9C%BA%E5%88%B6%EF%BC%9ABundle%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92.html</url>
      <content type="html"><![CDATA[<h4 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h4><p>要实现进程之间的通信，序列化是通信的基础，所以先要了解下什么是序列化<br><a id="more"></a><br>安卓实现序列化有两种方式：<br><strong>1. 实现Serializable接口</strong>，使用相当简单，这个是JAVA提供的方法，需要注意的是,该接口有一个serialVersionUID参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final long serialVersionUID = 1L ;</span><br></pre></td></tr></table></figure></p>
<p>可以选择不实现，依旧可以序列化，但是会对反序列化产生影响，如果在反序列化的过程中类发生了变化，那么将会报错。<br>AndroidStudio默认不检查serialVersionUID的实现，因此，可以手动开启它，这样系统就会自动帮你实现serialVersionUID。开启方法：<br>Settings-&gt;Editor-&gt;Inspections-&gt;serialization issues-&gt;Serializable class without ‘serialVersionUID’ 勾上确认就可以</p>
<p>序列化对象也非常简单，通过ObjectOutputStream和ObjectInputStream即可轻松实现</p>
<p><strong>2.实现Parcelable接口</strong>,这是Android提供的方法，实现该接口，系统会自动帮你实现需要的代码，Android中推荐使用该方法，因为效率比Serializable高，Serializable需要进行大量的I/O操作。以下是完整实现实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class User implements Parcelable &#123;</span><br><span class="line">    public int userId;</span><br><span class="line">    public String userName;</span><br><span class="line">    public boolean isMale;</span><br><span class="line">    public Book book;</span><br><span class="line"></span><br><span class="line">    protected User(Parcel in) &#123;</span><br><span class="line">        userId = in.readInt();</span><br><span class="line">        userName = in.readString();</span><br><span class="line">        isMale = in.readByte() != 0;</span><br><span class="line">        book = in.readParcelable(Book.class.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static final Creator&lt;User&gt; CREATOR = new Creator&lt;User&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public User createFromParcel(Parcel in) &#123;</span><br><span class="line">            return new User(in);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public User[] newArray(int size) &#123;</span><br><span class="line">            return new User[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int describeContents() &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void writeToParcel(Parcel parcel, int i) &#123;</span><br><span class="line">        parcel.writeInt(userId);</span><br><span class="line">        parcel.writeString(userName);</span><br><span class="line">        parcel.writeByte((byte) (isMale ? 1 : 0));</span><br><span class="line">        parcel.writeParcelable(book, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>方法详解见下表：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>功能</th>
<th>标记位</th>
</tr>
</thead>
<tbody>
<tr>
<td>createFromParce(Parcel in)l</td>
<td>从序列化的对象中创建原始对象</td>
<td></td>
</tr>
<tr>
<td>newArray</td>
<td>创建指定长度的原始对象数组</td>
<td></td>
</tr>
<tr>
<td>User(Parcel in)</td>
<td>从序列化的对象中创建原始对象</td>
<td></td>
</tr>
<tr>
<td>writeToParcel(Parcel parcel, int i)</td>
<td>将当前对象写入序列化结构中,其中 i有两种值，1代表当前对象需要作为返回值返回，不能立即释放资源，</td>
<td>PARCELABLE_WRITE_VALUE</td>
</tr>
<tr>
<td>describeContents</td>
<td>返回当前对象的内容描述，如果含有文件扫描符，返回1（参见右侧标记位），否则返回0</td>
<td>CONTENTS_FILE_DESCRIPTOR</td>
</tr>
</tbody>
</table>
<p>实现了序列化，我们就可以很方便的通过Intent发送Bundle,这是一种简单的进程间通信的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Bundle bundle = new Bundle();</span><br><span class="line">       bundle.putParcelable(&quot;User&quot;,new User());</span><br><span class="line">       Intent intent = new Intent(MainActivity.this, SecondActivity.class);</span><br><span class="line">       intent.putExtra(&quot;data&quot;,bundle);</span><br><span class="line">       startActivity(intent);</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Android基础进阶 </category>
            
            <category> 安卓IPC机制 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[安卓IPC机制:多进程]]></title>
      <url>/%E5%AE%89%E5%8D%93IPC%E6%9C%BA%E5%88%B6-%E5%A4%9A%E8%BF%9B%E7%A8%8B.html</url>
      <content type="html"><![CDATA[<h4 id="什么是IPC"><a href="#什么是IPC" class="headerlink" title="什么是IPC"></a>什么是IPC</h4><p> IPC是指进程间通信或者跨进程通信，指两个进程之间交换数据的过程。而IPC使用的场景往往是在多进程之间进行通信。</p>
<h4 id="Android开启多进程"><a href="#Android开启多进程" class="headerlink" title="Android开启多进程"></a>Android开启多进程</h4><p> 通过给Activity指定android:process属性来开启多进程模式,如下示例，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;application</span><br><span class="line">       android:allowBackup=&quot;true&quot;</span><br><span class="line">       android:icon=&quot;@mipmap/ic_launcher&quot;</span><br><span class="line">       android:label=&quot;@string/app_name&quot;</span><br><span class="line">       android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;</span><br><span class="line">       android:supportsRtl=&quot;true&quot;</span><br><span class="line">       android:theme=&quot;@style/AppTheme&quot;&gt;</span><br><span class="line">       &lt;activity android:name=&quot;.MainActivity&quot;&gt;</span><br><span class="line">           &lt;intent-filter&gt;</span><br><span class="line">               &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;</span><br><span class="line"></span><br><span class="line">               &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;</span><br><span class="line">           &lt;/intent-filter&gt;</span><br><span class="line">       &lt;/activity&gt;</span><br><span class="line">       &lt;activity android:name=&quot;.ThirdActivity&quot; </span><br><span class="line">           android:process=&quot;:remote&quot;</span><br><span class="line">           /&gt;</span><br><span class="line">       &lt;activity android:name=&quot;.SecondActivity&quot; </span><br><span class="line">           android:process=&quot;com.jie.demo_01.remote&quot;</span><br><span class="line">           /&gt;</span><br><span class="line">   &lt;/application&gt;</span><br></pre></td></tr></table></figure></p>
<p>示例中实现了两种不同的写法，这两种写法是有区别的,当ThirdActivity启动，系统会单独开启一个叫com.jie.demo_01:remote的进程(com.jie.demo_01为包名),当启动SecondActivity,系统会单独开启一个叫com.jie.demo_01.remote的进程，其中，“：”代表要在当前进程名前面加上当前的包名，并且代表此进程为私有进程，其他应用不能和它跑在一个进程中，而没有”：”的为全局进程。SecondActivity的这种写法，是一种完整的命名方式，不会附加包名信息。</p>
<h4 id="开启多进程的一些坑"><a href="#开启多进程的一些坑" class="headerlink" title="开启多进程的一些坑"></a>开启多进程的一些坑</h4><p>当一个Activity单独开启了一个进程，那么这个Activity就不能和别的进程的Activity共享数据了，只能通过IPC机制来传递数据。</p>
<p>例如我申明了一个静态变量 Userid = 1;我在MainActivity中把它改为了2，我在SecondActivity中开启了一个进程，我获取这个Userid，你会发现Userid还是1，这是因为Android会为每一个进程分配一个虚拟机，不同的虚拟机在内存分配上会有不同的地址空间，所以Userid会在不同的虚拟机上产生不同的副本，并且副本之间是互不干扰的,我在MainActivity中把它改为2，在SecondActivity中的副本是不会变得,可以理解为又新开启了一个应用，所以，一般来说，多进程之间会存在下列一些问题：</p>
<ul>
<li>静态成员和单例模式无效</li>
<li>线程同步机制失效</li>
<li>SharedPreferences的存储结果变得不再可靠</li>
<li>Application会多次创建</li>
</ul>
<p>为了解决这些问题，系统引入了IPC机制，用于在进程间共享和传递数据，IPC的方式主要有以下几种：</p>
<ul>
<li>使用Bundle</li>
<li>使用文件共享</li>
<li>使用Messenger</li>
<li>使用AIDL</li>
</ul>
<p>其中Messenger底层其实使用的AILD，AIDL其实是依靠Binder,下一章将详细介绍这几种方法。</p>
]]></content>
      
        <categories>
            
            <category> Android基础进阶 </category>
            
            <category> 安卓IPC机制 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Activity的生命周期和启动模式]]></title>
      <url>/Activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F.html</url>
      <content type="html"><![CDATA[<blockquote>
<p>此系列文章为进阶类文章,快餐类记录文,用于自己安卓知识点的复习</p>
</blockquote>
<h4 id="典型情况生命周期"><a href="#典型情况生命周期" class="headerlink" title="典型情况生命周期"></a>典型情况生命周期</h4><ul>
<li>onCreate() :Activity被创建<a id="more"></a></li>
<li>onRestart() : 正在重新启动。调用场景：当前Activity从不可见到变为可见状态</li>
<li>onStart():  Activity正在启动,此时Activity已经可见，但还不能和用户交互</li>
<li>onResume() :此时Activity已经可见并开始活动</li>
<li>onPause() :Activity正在停止，如果是从此Activity退到上一个Activity,那么会先执行此Activity的onPause,再执行上一个Activity的onResume,所以此方法不能执行耗时的操作，不然会影响新Activity的显示</li>
<li>onStop() : Activity即将停止,紧接着onPause后面执行</li>
<li>onDestroy() : Activity即将销毁,在这里主要做一些资源的释放<br>完整的启动流程是从上到下,有几个具体情况说明:<br>1)第一次启动一个新的Activity: onCreate-&gt;onStart-&gt;onResume<br>2)再次打开一个Activity或者切换到桌面：onPause -&gt;onStop (注：如果新的Activity是用的透明主题,那么不会回调onStop)<br>3) 再次回到此Activity：onRestar -&gt;onStart -&gt;onResume<br>4)退出此Activity (finish掉)：onPause -&gt;onStop -&gt;onDestroty</li>
</ul>
<h4 id="异常情况生命周期"><a href="#异常情况生命周期" class="headerlink" title="异常情况生命周期"></a>异常情况生命周期</h4><h5 id="资源相关的系统配置发生了改变导致Activity被杀死并重新创建"><a href="#资源相关的系统配置发生了改变导致Activity被杀死并重新创建" class="headerlink" title="资源相关的系统配置发生了改变导致Activity被杀死并重新创建"></a>资源相关的系统配置发生了改变导致Activity被杀死并重新创建</h5><p>发生此种情况最典型的就是横竖屏的切换,因为系统会去拿两张不同的图片，这时，Activity就会重新创建,它的onPause,onStop,onDestroy都会被调用,同时因为Activity是在异常情况下终止的,所以系统会调用onSaveInstanceState来保存当前Activity的状态，这个方法会在onStop方法之前调用。当Activity创建完成,系统会调用onRestoreInstanceState，可以从这个方法里拿到bundle对象并恢复Activity的状态</p>
<h5 id="资源不足导致Activity被杀死"><a href="#资源不足导致Activity被杀死" class="headerlink" title="资源不足导致Activity被杀死"></a>资源不足导致Activity被杀死</h5><p>此种情况和第一类差不多，都可以通过以上两种方法来恢复数据</p>
<p>此外，我们还可以不让Activity重新创建,通过在清单文件中指定Activity的configChanges属性,通过这些属性,可以让我们在特定场景下Activity不会被重新创建,此时，如果我们进行了特殊的操作,Activity会调用onConfigurationChanged方法</p>
<h4 id="Activity的启动模式"><a href="#Activity的启动模式" class="headerlink" title="Activity的启动模式"></a>Activity的启动模式</h4><p>1)standard： 默认模式，每次都打开一个新的Activity,例如ABCD四个Activity,A是最底的Activity,D是当前的栈顶Activity,通过D启动D，此时栈中的Activity就会变成ABCDD<br>2）singleTop： 栈顶复用模式，例如ABCD四个Activity,用D启动D,栈中的Activity还是ABCD，D被复用了,并且D不会再次调用onCreate，而是会调用onNewIntent<br>3)singleTask:  栈内复用模式,例如ABCD,通过D启动B，栈中的Activity为：ACDB,B不会被重新创建,并且B会放入到栈顶,如果是通过D启动E，那个栈中Activcity为ABCDE,因为E在栈中没有，系统会创建一个新的实例。复用的Activity依旧会调用onNewInternt<br>4) 单实例模式，可以理解为加强版的singTask.此种模式不但拥有singTask的全部特性，而且是单独的位于一个任务栈中，例如A是此种模式，那个系统会创建一个新的任务栈，那么由于栈的复用特性，后续的请求都不会重新创建新的Activity，除非被系统销毁了</p>
<h4 id="启动模式的设置"><a href="#启动模式的设置" class="headerlink" title="启动模式的设置"></a>启动模式的设置</h4><p>1）通过清单文件的launchMode属性设置<br>2）通过Intent设置标志位来指定<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = new Intent();</span><br><span class="line">intent.setClass(A.this,B.class);</span><br><span class="line">intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure></p>
<p>两者的区别:第二种的优先级会高于第一种，第一种无法设置FLAG_ACTIVITY_CLEAR_TOP标识,第二种无法为Activity指定singleInstance模式。</p>
<h4 id="Activity的Flags"><a href="#Activity的Flags" class="headerlink" title="Activity的Flags"></a>Activity的Flags</h4><p><strong>FLAG_ACTIVITY_NEW_TASK</strong><br>singleTask模式<br><strong>FLAG_ACTIVITY_SINGLE_TOP</strong><br>singleTop模式<br><strong>FLAG_ACTIVITY_CLEAR_TOP</strong><br>设置了此模式，如果是singleTask模式启动,那么就会调用onNewIntent，如果是standard模式启动,那么位于此Activity栈上的所有Activity都要出栈<br><strong>FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS</strong><br>具有这个标记的Activity不会出现在列表中,等同于xml中的excludeFromRecents=true;</p>
]]></content>
      
        <categories>
            
            <category> Android基础进阶 </category>
            
            <category> 安卓Activity </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[有哪些送给年轻人的建议或道理？]]></title>
      <url>/%E6%9C%89%E5%93%AA%E4%BA%9B%E9%80%81%E7%BB%99%E5%B9%B4%E8%BD%BB%E4%BA%BA%E7%9A%84%E5%BB%BA%E8%AE%AE%E6%88%96%E9%81%93%E7%90%86%EF%BC%9F.html</url>
      <content type="html"><![CDATA[<blockquote>
<p>序言：这篇文章，写给你们，也写给我自己，我自己会经常阅读这篇文章来激励自己，每当自己茫然，无措，不知道该干嘛时，我都会读一遍，这样我的脑海就会自动给自己罗列出一些事情来做，哈哈哈。希望对阅读这篇文章的你会有启发,我相信未来的你一定会感谢现在这么努力的自己！</p>
</blockquote>
<h4 id="学习很重要！学习很重要！学习很重要！"><a href="#学习很重要！学习很重要！学习很重要！" class="headerlink" title="学习很重要！学习很重要！学习很重要！"></a>学习很重要！学习很重要！学习很重要！</h4><p> 知识或者技能这种东西，学到了就跟你一辈子，不管工作或时空跨度多大，新知和技能都能排上用场，请不要感叹时光已逝，学习不易，人家老来考研的，甚是80岁学编程的都有，请不要为你的懒惰找借口。</p>
<h4 id="习惯很重要！"><a href="#习惯很重要！" class="headerlink" title="习惯很重要！"></a>习惯很重要！</h4><p> 有人总是和我们说，要养成好的习惯。可没人跟我说重要到深度影响自己生活、人生选择和生命质量的程度。因为几乎大多数人，每时每刻都生活在形形色色的思维习惯、生活习惯中，比如健身、跑步、阅读、表达、写作、沟通、学习等等，所有影响我们生活工作结果的全是这些习惯。我们养成习惯，然后习惯养成我们。</p>
<h4 id="学会学习他人优秀的品质"><a href="#学会学习他人优秀的品质" class="headerlink" title="学会学习他人优秀的品质"></a>学会学习他人优秀的品质</h4><p>围剿式学习，也就是吸星大法，通过观察对方的沟通、演讲、写作方式，从而学习他们的思维方式、学习他们身上最优秀的思维习惯,当你们把优秀的人身上优秀的品质学习下来，这就是成功！</p>
<h4 id="真诚和诚信"><a href="#真诚和诚信" class="headerlink" title="真诚和诚信"></a>真诚和诚信</h4><p>真诚是领导力的真谛，诚信是商业的真谛，每个人的年薪、领导能力、商业成就全部都可以从这两个词汇里诠释,当你自己做老板你就会觉得这两个品质是多么的重要了。</p>
<h4 id="要多陪陪家人"><a href="#要多陪陪家人" class="headerlink" title="要多陪陪家人"></a>要多陪陪家人</h4><p>年轻人可能心里想得更多的是幸福生活，但父母的年纪，他们年龄越大，越要去面临离开这一主题，他们担心被世界抛弃，担心自己在儿女生活中扮演不了什么重要价值，特别渴望回馈、关注和尊重，不管多忙，能多打一个电话就多打一个电话，能多在一起吃顿饭，就多在一起吃顿饭，能满足他们想要的，不管大小，尽量去满足。可能你没察觉的是，随着你的逐渐成长，你的父母正逼近死亡！</p>
<h4 id="不要熬夜"><a href="#不要熬夜" class="headerlink" title="不要熬夜"></a>不要熬夜</h4><p>睡眠其实真正决定了生命的效率。因为睡眠决定着第二天的心情、状态、专注度等，而心情、状态、专注度直接影响结果，我们的现在就是由大大小小的这些结果构成的。所以睡个好觉可能是让生活变得更好的最大的捷径。不要相信什么狗血成功剧经常熬夜就能成功，成功是讲究效率的。</p>
<h4 id="保持自我，不断完善"><a href="#保持自我，不断完善" class="headerlink" title="保持自我，不断完善"></a>保持自我，不断完善</h4><p>保持自我，并不断变得更好，其实在一段感情里，远比委曲求全，一味地宠溺对方，更重要。保持自我可以测试出和对方是否合拍，不断变得更好，可以让感情更深刻而持久。千万不要因为孤独、无助、父母逼迫、个人面子、焦虑等原因仓促地选择一个人。这个人是自己生命的一部分，对自己施加着无以复加地影响，所以谨慎点，即便单身都比错误好很多。</p>
<h4 id="用感官去发现更美好的世界"><a href="#用感官去发现更美好的世界" class="headerlink" title="用感官去发现更美好的世界"></a>用感官去发现更美好的世界</h4><p>利用所有的感官去体验周遭的世界是那么重要，刻意发现生活的美，发现细微处的不同，会给自己带来很多小惊喜</p>
<blockquote>
<p>接下来聊聊职场发展的,人要舍得投资自己，这样你才会越来越值钱</p>
</blockquote>
<h4 id="不要让专业限制你的选择"><a href="#不要让专业限制你的选择" class="headerlink" title="不要让专业限制你的选择"></a>不要让专业限制你的选择</h4><p>许多人或许都是一些刚刚步入社会的学生，学生思维的一大局限就是觉得找工作应该专业要对口，实际上从我个人的观察来看，大学毕业后，同学中反倒是从事本专业的属于小众，我觉得造成这个现象的原因有：<br>（1）一般来说，填高考志愿的时候，你报的专业未来到底能做什么工作，你的父母如果不太了解的话，你必定也不太了解，况且很多学生报的专业都是那种所谓的热门专业，或者父母给选的，或者父母从事的专业；<br>（2）上大学后，真正的学了专业课后，你很有可能并不感兴趣，或者并不擅长；<br>（3）除了少数对专业知识要求较高的理工科专业，大部分专业毕业后去公司实习完全可以搞明白工作流程。所以除了队技术要求较高的理工科职位，其他大多数职位，毕业去公司，通过实际工作中学习，是完全可以的，只要你做了感兴趣，并且擅长的工作，工作技能都是学的很快的，而且在公司里你不懂的问题可以直接问资历老的员工，比你自己在学校里上课效率高多了，我本科学计算机的，班里同学有从事媒体的，金融的，出版社的，房地产的，考公务员的，还有经商的，反正干啥的都有，只要是你感兴趣的，并且觉得自己能做好的职位，大可以一试。</p>
<h4 id="不要怕犯错，年轻没有失败"><a href="#不要怕犯错，年轻没有失败" class="headerlink" title="不要怕犯错，年轻没有失败"></a>不要怕犯错，年轻没有失败</h4><p>网上很多人说过要找自己擅长的工作，但是问题是，一份工作你没干之前，很难知道自己到底是否擅长，那这份擅长的工作或行业要怎么找呢？答案是：多去尝试不同的职业。大学刚毕业一两年，很有可能你目前从事的工作并不是你喜欢的，也不是你一辈子只能干这个，如果干的不开心，并且在公司里干的也不算出色，那么，很可能就是你不擅长这个行业，这个时候，仗着你年轻，你大可以辞职转行，30岁之前你的转行成本是很低的，因为你年轻，大部分公司都会给你一个面试的机会，等你过了30岁再想转行，也不是不可能，但是难度比20几岁的时候会高几个量级：<br>（1）从公司的角度来看，公司更爱培养年轻人；<br>（2）30岁很可能结婚了，上有老，下有小，转行的风险特别的高，就是找1个月工作，很多家庭的房贷就要断供了，导致这个年纪即使想转行，需要考虑的因素也会多很多。所以，最好的选择就是在你的25-30岁之间这5年里，找到你擅长的行业或领域，这5年内你干的不爽尽可以换，但是最好在30岁之前找到自己能做一生的职业，并且稳定下来。</p>
<h4 id="好好利用下班的时间，5年后会给你带来巨大的改变"><a href="#好好利用下班的时间，5年后会给你带来巨大的改变" class="headerlink" title="好好利用下班的时间，5年后会给你带来巨大的改变"></a>好好利用下班的时间，5年后会给你带来巨大的改变</h4><p>20-25岁的年轻人，如果指望不上父母，只能靠自己奋斗的话，说难听点，你随后的几年是不应该有过多的娱乐生活的。道理很简单，在你没有过多的好的选择的时候，好好工作，升职加薪是你能做到的风险最小的选择（创业风险太高，不适合普通人），而决定你升职加薪的关键就是你的工作技能，所以如果你想30岁混个一官半职当个小主管，不想再当普通打工仔，那么，有效的利用下班时间好好的给自己充电是你必须要做的。而现代社会每个人白天得上至少八小时的班（不加班的企业真是良心），即使你有幸在一家不加班的企业工作，晚上下班挤地铁/公交到家吃完饭，洗完澡之后，怎么着也得8点了，如果你12点睡的话（基本已是极限，再晚睡会影响白天的工作），你一天中有效的连续学习时间就是4小时（这是比较乐观的估计，还有很多人通勤时间就得1个多小时，所以能有4个小时的学习时间的人真是很幸运），4小时，乍一看不少了，但是实际用起来，减掉中间休息一下的时间，你就会发现，是很紧凑的，而且一旦开始决定晚上学习，基本就不能隔三差五的和朋友出去浪了，因为就怕一出去，打破了学习惯性，心就散了，无心再耐心学习下去了，所以如果你决定给自己充电，几乎也就可以告别娱乐生活了，虽然这样的生活很苦，但是人生是需要规划的，若干年后，你应该感谢曾经那么的努力的自己。一辈子很长，25岁是你播种的时候，为的是未来的收获。</p>
<h4 id="对工作的爱好最重要"><a href="#对工作的爱好最重要" class="headerlink" title="对工作的爱好最重要"></a>对工作的爱好最重要</h4><p>爱好是最重要的，你不爱的工作再赚钱你也会忧郁症的，到时候每天起床都没动力，毕竟工作是半辈子的事情。</p>
<h4 id="定制自己的职业发展计划-明确自己要的是什么"><a href="#定制自己的职业发展计划-明确自己要的是什么" class="headerlink" title="定制自己的职业发展计划,明确自己要的是什么"></a>定制自己的职业发展计划,明确自己要的是什么</h4><p>提前给自己定好计划，避免让自己像一个无头苍蝇般到处乱飞，明确自己想要的是什么，该如何去努力，对自己的财产也要有规划，多阅读一些关于金融理财类的书籍。</p>
<blockquote>
<p>最后，再来一个毒鸡汤总结</p>
</blockquote>
<h4 id="这是一个带毒的总结"><a href="#这是一个带毒的总结" class="headerlink" title="这是一个带毒的总结"></a>这是一个带毒的总结</h4><p>在年轻的时候，即使你知道再多“人生的道理”，即使你下了再大的决心，即使你做了再周密的计划。你还是可能一事无成。因为你并没有坚持下来,道理你都懂，要干什么事儿也都知道，为什么你做不到？有谁认真想过? </p>
<p>我们之所以做不到，是因为大部分人，都无法把自己眼前的事或即将要做的事，和今后的收益联系起来,因为你坚持了一个月后,你可能就会想，我这样做真的有用吗？这时你就会彷徨，甚至惊恐，毕竟，隔山的金子不如铜:<br>我又不靠写作吃饭,看那么多书有什么用呢?<br>一个月就那么点钱,理财有什么用呢?<br>已经长那样了,健身有什么用呢?<br>我又不想出国、不考外交部、不去外企,你让我努力打卡学英语不是搞笑吗?<br>………<br>人往往就是这样,事到临头才会想到要抱佛脚。<br>那么如何才能去坚持，其实我也没什么方法可言，道理你都懂了，做与不做都是你的一念之间,我只能告诉你一个道理需要你们自己去悟：</p>
<p><code>你要让你所有做的事情，随着时间发展产生变化</code></p>
<p>你需要的只是在年轻的时候多用时间做资本，去为未来做投资.<br>就能在未来取得收益后，买下更重要的时间。<br>人的一生很宝贵，酒足饭饱之余，不妨多想想，做点什么更有用的事，才能在阶层固化之前尽量往上多蹦一两个台阶</p>
<h5 id="因为，相对于你今后的每一天，现在的你都是最年轻的你。"><a href="#因为，相对于你今后的每一天，现在的你都是最年轻的你。" class="headerlink" title="因为，相对于你今后的每一天，现在的你都是最年轻的你。"></a>因为，相对于你今后的每一天，现在的你都是最年轻的你。</h5><p>好文链接：</p>
<ul>
<li><p><a href="https://www.jianshu.com/p/a5448821f9ad" target="_blank" rel="noopener">【习惯】你培养习惯的方法可能是个假方法</a></p>
</li>
<li><p><a href="https://www.jianshu.com/p/93e59aed232a?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=pc_all_hots&amp;utm_source=recommendation" target="_blank" rel="noopener">你的所谓成熟，不过是精神早衰</a></p>
</li>
</ul>
<p>—————————–希望生活善待如此努力的你❤—————————-</p>
]]></content>
      
        <categories>
            
            <category> 感悟 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[如何将个人域名与github绑定]]></title>
      <url>/%E5%A6%82%E4%BD%95%E5%B0%86%E4%B8%AA%E4%BA%BA%E5%9F%9F%E5%90%8D%E4%B8%8Egithub%E7%BB%91%E5%AE%9A.html</url>
      <content type="html"><![CDATA[<h1 id="购买个人域名"><a href="#购买个人域名" class="headerlink" title="购买个人域名"></a>购买个人域名</h1><p>例如我的是在阿里云万网购买的,点击进入域名列表,点击解析,会出现一个添加解析按钮，点开有记录类型，主机记录，解析线路，记录值，TTL值五个选项<br>依次填写：</p>
<ul>
<li>记录类型：A</li>
<li>主机记录：www</li>
<li>解析线路：不用选，就用默认</li>
<li>记录值：填写你的github网址的ip,可以用ip查询或ping查到，一般都是151开头。</li>
<li>TTL值：不用管，默认10分钟。</li>
</ul>
<p>填写完毕后就可以关闭页面了</p>
<h1 id="Github配置"><a href="#Github配置" class="headerlink" title="Github配置"></a>Github配置</h1><p>在你的io网站本地仓库中新建一个CHAME(注意都要大写)文件，没有后缀，打开编辑，将你的域名添加进入，例如我的就是www.huangjie.name,保存，关闭,将文件提交到远程仓库,这时github应该会发一封邮件给你代表配置成功，更改不会立即生效，一般10分钟左右</p>
<p>如果你是用的hexo，可以将CHAME文件建立在source文件夹中，这样通过Hexo提交到github不会被覆盖</p>
]]></content>
      
        <categories>
            
            <category> Hexo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo博客使用心得]]></title>
      <url>/hello-world.html</url>
      <content type="html"><![CDATA[<p>欢迎来到黄杰的个人博客，这是我写入的第一篇博文,此博客平台采用  <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> + <a href="https://github.com/" target="_blank" rel="noopener">githubPages</a>搭建而成,搭建日期：2017/11/29。这篇博客将持续记录hexo使用过程中的一些问题<br><a id="more"></a></p>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>记录一些自己搭建的参考资料</p>
<ul>
<li><a href="http://blog.haoji.me/build-blog-website-by-hexo-github.html?from=xa" target="_blank" rel="noopener">http://blog.haoji.me/build-blog-website-by-hexo-github.html?from=xa</a></li>
<li><a href="https://hexo.io/zh-cn/docs/generating.html" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/generating.html</a></li>
<li><a href="http://blog.csdn.net/poem_of_sunshine/article/details/2936978" target="_blank" rel="noopener">http://blog.csdn.net/poem_of_sunshine/article/details/2936978</a></li>
<li><a href="http://blog.sunnyxx.com/2014/02/27/hexo_startup/" target="_blank" rel="noopener">http://blog.sunnyxx.com/2014/02/27/hexo_startup/</a></li>
</ul>
<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><p>进入项目主结构，使用git bash执行命令</p>
<ul>
<li>监听文件变动  <code>$ hexo g</code></li>
<li>开启本地服务 <code>$ hexo s</code> ，开启后在浏览器输入<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 即可访问</li>
<li>提交代码 <code>$ hexo d</code>  ，需要配置deploy</li>
</ul>
<p>在主项目目录下有个_config.yml,为全局配置文件,在themes文件夹里，存放着网站使用的主题文件，打开主题文件夹，里面也有个_config.yml，为主题配置文件，与主题相关的在这里配置，我现在采用的是<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">Next</a>主题</p>
<h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><h4 id="一-首页的文章内容全部显示出来了，没有“阅读全文”"><a href="#一-首页的文章内容全部显示出来了，没有“阅读全文”" class="headerlink" title="一.首页的文章内容全部显示出来了，没有“阅读全文”?"></a>一.首页的文章内容全部显示出来了，没有“阅读全文”?</h4><h5 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h5><p>有两种方法</p>
<p>第一种：<br>在主题配置文件里(themes/next/_config.yml)用编辑器打开，找到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Automatically Excerpt. Not recommend.</span><br><span class="line"># Please use &lt;!-- more --&gt; in the post to control excerpt accurately.</span><br><span class="line">auto_excerpt:</span><br><span class="line">  enable: false</span><br><span class="line">  length: 150</span><br></pre></td></tr></table></figure></p>
<p>将 <code>enable：false</code> 改为<code>true</code>就行了，后面的<code>length:150</code>代表显示的文本字数。</p>
<p>第二种：<br>直接在编辑的.md文件里将要预览的文字后面加上<code>&lt;!--more--&gt;</code>,这样之前的就是预览的文字,后面的就不会显示了</p>
<h4 id="二-如何将README-md文件传到github而不被编译成html"><a href="#二-如何将README-md文件传到github而不被编译成html" class="headerlink" title="二.如何将README.md文件传到github而不被编译成html"></a>二.如何将README.md文件传到github而不被编译成html</h4><p>在Hexo目录的source目录在建立一个README.md文件,修改Hexo目录的_config.yml配置,找到 skip_render参数设置,后面加上 README.md,关闭保存,之后编译就不会渲染README.md这个文件了</p>
<h4 id="三-百度搜索引擎不能收录自己的网站地址"><a href="#三-百度搜索引擎不能收录自己的网站地址" class="headerlink" title="三.百度搜索引擎不能收录自己的网站地址"></a>三.百度搜索引擎不能收录自己的网站地址</h4><p>原因是github屏蔽了百度的spider爬虫,导致百度不能收录,解决办法是使用coding来托管国内的流量访问,具体的方法可以参考这篇博文:<a href="http://blog.csdn.net/sunshine940326/article/details/70936988" target="_blank" rel="noopener">hexo高阶教程：想让你的博客被更多的人在搜索引擎中搜到吗？</a></p>
<h1 id="写作技巧记录"><a href="#写作技巧记录" class="headerlink" title="写作技巧记录"></a>写作技巧记录</h1><h4 id="一-如何将md文件以时间命名"><a href="#一-如何将md文件以时间命名" class="headerlink" title="一.如何将md文件以时间命名"></a>一.如何将md文件以时间命名</h4><p>  在_config.yml中找到new_post_name,修改名称为<code>:year-:month-:day-:title.md</code>,这样创建的文件就会以电脑时间命名，使用时间命名可以更方便的管理文章</p>
]]></content>
      
        <categories>
            
            <category> Hexo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
        
    </entry>
    
  
  
    
    <entry>
      <title><![CDATA[tags]]></title>
      <url>/tags/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title></title>
      <url>/about/index.html</url>
      <content type="html"><![CDATA[<h1 id="About-Me"><a href="#About-Me" class="headerlink" title="About Me"></a>About Me</h1><blockquote>
<p>Android 小生一枚，轻微强迫症患者，非处女座，忠实谷粉兼果粉，喜欢看书听歌旅游,喜欢研究各种新技术~~</p>
</blockquote>
<p>联系我:</p>
<ul>
<li>Email(QQ): jay@huangjie.name</li>
<li>Github : <a href="https://github.com/Jay-huangjie" target="_blank" rel="noopener">Jay-huangjie</a></li>
<li>QQ: 289223562</li>
<li>CSDN: <a href="http://blog.csdn.net/qq289223562" target="_blank" rel="noopener">_杰哥</a></li>
<li>简书:<a href="https://www.jianshu.com/u/2334b8b9f764" target="_blank" rel="noopener">我是黄教主啊</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[分类]]></title>
      <url>/categories/index.html</url>
      <content type="html"></content>
    </entry>
    
  
</search>
