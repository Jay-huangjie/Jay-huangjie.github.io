<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[安卓高级布局-flexboxLayout：最聪明的布局]]></title>
    <url>%2F%E5%AE%89%E5%8D%93%E9%AB%98%E7%BA%A7%E5%B8%83%E5%B1%80-flexboxLayout-%E6%9C%80%E8%81%AA%E6%98%8E%E7%9A%84%E5%B8%83%E5%B1%80.html</url>
    <content type="text"><![CDATA[版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起. ps:最近由于连接外接硬盘的数据线落朋友家了，而我hexo文档都存在外接硬盘上了，导致许久都没写文章啦，还别说，手还有点痒，以后还是尽量保持每周一更 前言今天给大家介绍的是谷歌开源的新的一种布局，如果用css写过flexbox布局的朋友一定不会陌生,没错，FlexboxLayout可以说是Android版的flexbox布局，它的作用是可以让子布局轻松填充父布局，并且可以对子布局进行排序，设置可以让子布局自动‘换行’,它还能够指定子布局的排列方向,相当于一个加强版的LinearLayout，怎么样，你是不是迫不及待想试试了？ 使用FlexboxLayout开源地址：https://github.com/google/flexbox-layout 在build.gradle中添加：123dependencies &#123; implementation 'com.google.android:flexbox:0.3.2'&#125; 在xml中使用：12345678910111213141516171819202122232425262728293031323334&lt;com.google.android.flexbox.FlexboxLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;TextView android:layout_width="100dp" android:layout_height="20dp" android:background="#43eeff" android:gravity="center" android:text="1" /&gt; &lt;TextView android:layout_width="100dp" android:layout_height="20dp" android:background="#ef3344" android:gravity="center" android:text="2" /&gt; &lt;TextView android:layout_width="100dp" android:layout_height="20dp" android:background="#ee998f" android:gravity="center" android:text="3" /&gt; &lt;TextView android:layout_width="100dp" android:layout_height="50dp" android:background="#eeff22" android:gravity="center" android:text="4" /&gt;&lt;/com.google.android.flexbox.FlexboxLayout&gt; 我们什么属性都不加,可以看到效果是这样的： 咦，好像并没有换行，别急，这其实是flexboxLayout默认属性的一个效果，下面我们就来学习它的一些常用属性吧： flexDirectionflexDirection属性决定子布局的排列方向。类似LinearLayout 的 orientation属性，不过,flexboxLayout的属性更加强大,它除了决定子布局的排列方向,还可以决定子布局的起点位置： row（默认值）：子布局为水平方向，起点在左端 row_reverse：子布局为水平方向，起点在右端。 column：子布局为垂直方向，起点在上沿 column_reverse：子布局为垂直方向，起点在下沿 使用column_reverse效果如下所示： flexWrapflexWrap是一个非常有用的属性，它可以让控件自动换行, nowrap （默认）：不换行 wrap：按正方向换行 wrap_reverse：按反方向换行 使用wrap属性效果如下所示： justifyContentjustifyContent定义了子控件的对齐方式，把它看成gravity属性，子控件为一个整体就好理解了，属性如下： flex_start(默认):左对齐 flex_end：右对齐 center：居中 space_between：两端对齐，每个子控件之间的距离相等 space_around：每个子控件的两侧相等,项目之间的间隔比项目与边框的间隔大一倍。 如下是设置了space_around的效果： alignItemsalignltems用于设置子布局的对齐方式,属性如下： flex-start：顶端对齐。：第一行内容的的基线对齐。 flex_end：底部对齐。 stretch （默认）：如果item没有设置高度，则充满容器高度。 center：居中对齐 baseline：第一行内容的基线对齐。 这也是为什么我们一开始什么也不设置子布局会填充父布局的原因。这里还说下baseline属性，用过TextView一定对基线不会陌生,如果子控件有文字，基线对齐可以保证文字对齐而不必理会包裹它的控件是怎样的。观看下图可以有助于理解： alignContentalignContent可以控制多行的对齐方式，如果子布局只有一行则不起作用，属性如下： stretch （默认值）：充满交叉轴的高度（测试发现，需要alignItems 的值也为stretch 才有效）。 flex_start：与交叉轴的起点对齐。 flex_end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space_between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space_around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 子布局属性子布局也有非常给力的属性,父与子布局的结合使得排版非常灵活 layout_flexBasisPercentayout_flexBasisPercent的值为一个百分比，表示设置子元素的长度为它父容器长度的百分比,默认值是auto,即元素本来的大小。如图，我设置每个子布局的宽度一样，第一个子布局我设置50%的百分比，效果如图： layout_orderlayout_order属性用于给子布局排序，默认是按照从上到下依次排列的，如果加入该值，值越小位置就会越靠前 layout_flexGrowlayout_flexGrow用于定义子布局的放大比例，其实就是LinearLayout的weight属性，相信这个不用过多介绍吧 layout_flexShrinklayout_flexShrink定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。如果所有项目的 layout_flexShrink 属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。 layout_alignSelflayout_alignSelf属性允许单个子元素有与其他子元素不一样的对齐方式，可覆盖 alignItems 属性。默认值为auto，表示继承父元素的alignItems 属性，如果没有父元素，则等同于stretch。属性作用同alignItems一样。 flexboxLayout大部分常用的属性就介绍到这里，此布局可以轻松完成类似添加tag便签的布局样式，也可以把它当成百分比布局来用，甚至可以与RecyclerView搭配完成图片流效果，因此熟练掌握这个布局还是有必要的，跟着文章的讲解多敲敲代码，相信你很快就会上手的。]]></content>
      <categories>
        <category>Android基础进阶</category>
        <category>安卓控件</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[记一次重构项目心得]]></title>
    <url>%2Frefactoring-project-learned.html</url>
    <content type="text"><![CDATA[版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起. 这次花时间重构了下一年前的自定义键盘项目,收获了许多，忍不住想写出来分享一下,项目地址EasyKeyBoardView,该库旨在帮助开发者更快的实现自定义键盘，无需关注键盘自身的实现逻辑，详细用法见README.md 如何重构项目对于一个开源项目来说，首先要弄清楚它的意义在哪里，它的目的在哪里，俗话说，程序员都是懒惰的，为了偷懒，程序员创造了越来越方便的工具来帮自己偷懒，这就是一种进步。 基于此，我分析了下自定义键盘的使用场景，发现键盘的使用逻辑是差不多的，无非是UI及一些功能点上的不同，但终究是一个键盘，输入功能是刚需，所以简化输入功能就是这个库的意义所在了。 而这次我发现，一款优质的开源项目必须要有高度的扩展性，应此将功能模块化是我此次学习到的重要技能，每一个类都有着它自己的功能，然后再将这些类组装起来就变成了一台灵活运作的机器。而其中那些点可对外修改，那些不能，这都需要自己判断的。 学习到的技能更快的配置：上传项目到JitPack相比于jcenter,我发现JitPack可谓是神器，1分钟就可实现代码上传，强烈推荐，使用方法如下：首先进入它的github地址:jitpack.io,找到它的最新版插件版本，在要上传的项目的root build.gradle中添加插件，大概长这样：123456dependencies &#123; classpath 'com.android.tools.build:gradle:3.0.0' classpath 'com.github.dcendents:android-maven-gradle-plugin:2.0' // 这是截至目前最新版的插件 // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files &#125; 然后在你要上传的library包中的build.gradle文件中添加：12apply plugin: 'com.github.dcendents.android-maven'group='com.github.Jay-huangjie' //这里写你自己的github名字，别写我的啊 重新编译一下，然后将代码上传到github,上传成功后进入项目主页，点击releases创建一个版本，releases或tag都行，如图： 创建好后进入jitPack官网：https://jitpack.io/;在输入框中输入你的项目地址，例如我的项目地址就是https://github.com/Jay-huangjie/EasyKeyBoardView,得到如图所示的信息：点击Get it按钮即可获取你的地址啦，并且，通过此地址下载的是你的library包而不是整个项目，所以你可以将库的demo也一起上传到github上，是不是非常的方便简单呢]]></content>
      <categories>
        <category>安卓杂记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[okhttp3Wiki文档译文]]></title>
    <url>%2Fokhttp3-wiki-chinese.html</url>
    <content type="text"><![CDATA[版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起. 本文提供一些okhttp3的文档翻译,英文文档地址:https://github.com/square/okhttp/wiki Calls(调用)HTTP客户端的工作是接受你的请求并产生响应。这在理论上很简单，但在实践中会变得棘手。 Requests每个HTTP请求都包含一个URL，一个方法（如GET或POST）和一个头部列表(headers)。请求也可能包含一个请求体(body)：特定内容类型的数据流。 Responses每一个HTTP响应中都包含一个状态码（如200代表成功，404代表未找​​到），一个响应头列表（headers）和一个可选的响应体（body）。 重写请求当你的OkHttp发送一个HTTP请求，你在描述一个高层次的要求：“给我获取这个网址中的这些请求头。”对于正确性和效率，OkHttp发送前会重写你的请求。 OkHttp可以在原先的请求中添加请求头（headers），包括Content-Length, Transfer-Encoding, User-Agent, Host, Connection, 和 Content-Type。除非请求头已经存在压缩响应，否则它还将添加一个Accept-Encoding请求头。如果你有cookies，OkHttp还将添加一个Cookie请求头。 一些请求会有一个缓存的响应。当这个缓存的响应不是最新的时候，OkHttp会发送一个有条件的GET来下载更新的响应，如果它比缓存还新。它将会添加需要的请求头，如IF-Modified-Since和If-None-Match。 重写响应如果使用透明压缩，OkHttp将删除相应的响应头Content-Encoding，Content-Length因为它们不适用于解压缩的响应主体。 如果条件GET成功，则来自网络和缓存的响应将按照规范的指示进行合并。 后续请求当您请求的URL已经移动时，Web服务器将返回一个响应代码，302以指示文档的新URL。OkHttp将按照重定向来检索最终响应。如果响应发出授权质询，则OkHttp会询问Authenticator（如果已配置）以满足质询。如果认证者提供证书，则请求将会带着证书进行重试。 重试请求有时连接失败：要么是连接池已经过时和断开，或是Web服务器本身无法达成。如果有一个是可用的，OkHttp将会使用不同的路由进行请求重试。 呼叫随着重写，重定向，后续和重试，你简单的要求可能会产生很多请求和响应。OkHttp使用呼叫（Call）并通过许多必要的中间请求和响应来满足你请求的任务模型。通常情况，这是不是很多！如果您的网址被重定向，或者如果您故障转移到另一个IP地址，但它会欣慰的知道你的代码会继续工作。 通过以下两种方式进行呼叫： 同步：直到响应,你的线程块是可读的。 异步：你在任何线程进行排队请求，并且当响应是可读的时候，你会在另一个线程得到回调。 呼叫（Calls）可以在任何线程中取消。如果它尚未完成，它将作为失败的呼叫（Calls）！当呼叫（Call）被取消的时候，如果代码试图进行写请求体（request body）或读取响应体（response body）会遭受IOException异常。 调度对于同步呼叫，您需要自带线程，并负责管理多少个同时发出的请求。同时连接的垃圾资源过多; 太少的危害等待时间。 对于异步调用，Dispatcher实现最大同时请求的策略。您可以设置每个网络服务器的最大数量（默认值是5），总体（默认值是64）。 Connections(连接)虽然您只提供了URL，但是OkHttp计划使用三种类型连接到你的web服务器：URL, Address, 和 Route URLURL（如https://github.com/square/okhttp）是HTTP和Internet的基础。除了作为网络上所有内容的通用分散命名方案之外，他们还指定如何访问网络资源。 网址是抽象的： 他们指定的调用可能是明文（http）或加密（https），但不应该使用哪些加密算法。他们也没有指定如何验证对等方的证书（HostnameVerifier）或哪些证书可以信任（SSLSocketFactory）。他们也是具体的：每个URL标识一个特定的路径（如/square/okhttp）和查询（如?q=sharks&amp;lang=en）。每个网络服务器都有许多网址。 它们不指定是否应该使用特定的代理服务器，或者如何使用该代理服务器进行身份验证。 他们也是具体的：每个URL标识一个特定的路径（如/square/okhttp）和查询（如?q=sharks&amp;lang=en）。每个网络服务器都有许多网址。 Addresses地址指定一个网络服务器（如github.com）以及连接到该服务器所需的所有静态配置：端口号，HTTPS设置和首选网络协议（如HTTP / 2或SPDY）。 共享相同地址的URL也可能共享相同的底层TCP套接字连接。共享连接具有显着的性能优势：更低的延迟，更高的吞吐量（由于TCP启动缓慢）和保存的电池。OkHttp使用ConnectionPool自动重用HTTP / 1.x连接并复用HTTP / 2和SPDY连接。 在OkHttp地址的一些字段来自URL（方案，主机名，端口），其余来自OkHttpClient。 Routes路由提供实际连接到Web服务器所需的动态信息。这是要尝试的特定IP地址（通过DNS查询发现），要使用的确切代理服务器（如果正在使用ProxySelector）以及要协商哪个版本的TLS（用于HTTPS连接）。 单个地址可能有很多路线。例如，托管在多个数据中心中的Web服务器可能会在其DNS响应中产生多个IP地址。 Connections当你用OkHttp请求一个URL的时候，它的功能如下： 它使用URL并配置OkHttpClient来创建一个地址。该地址指定我们将如何连接到Web服务器。它尝试从连接池中检索具有该地址的连接。如果在池中找不到连接，则选择要尝试的路由。这通常意味着发出DNS请求来获取服务器的IP地址。然后根据需要选择TLS版本和代理服务器。如果是新路由，则通过构建直接套接字连接，TLS隧道（用于通过HTTP代理的HTTPS）或直接TLS连接进行连接。它根据需要进行TLS握手。它发送HTTP请求并读取响应。如果连接有问题，OkHttp会选择另外一个路径，然后重试。这允许OkHttp在服务器地址的子集无法访问时恢复。当池连接失效或尝试的TLS版本不受支持时，这也很有用。 一旦接收到响应，连接将被返回到池中，以便将来可以重复使用。经过一段时间的不活动之后，连接被从池中逐出。 Recipes(方法)我们已经写了一些方法，演示了如何解决OkHttp常见问题。通过阅读他们了解一切是如何正常工作的。可以自由剪切和粘贴这些例子。 同步获取(Synchronous Get)下载文件，打印其头部，并以字符串形式打印其响应体。 该string()方法在响应体中是方便快捷的小型文件。但是，如果响应体较大（大于1 MIB以上），它会将整个较大文件加载到内存中，所以应该避免string() 。在这种情况下，更倾向于将响应体作为流进行处理。 123456789101112131415161718private final OkHttpClient client = new OkHttpClient();public void run() throws Exception &#123; Request request = new Request.Builder() .url("https://publicobject.com/helloworld.txt") .build(); try (Response response = client.newCall(request).execute()) &#123; if (!response.isSuccessful()) throw new IOException("Unexpected code " + response); Headers responseHeaders = response.headers(); for (int i = 0; i &lt; responseHeaders.size(); i++) &#123; System.out.println(responseHeaders.name(i) + ": " + responseHeaders.value(i)); &#125; System.out.println(response.body().string()); &#125;&#125; 异步获取(Asynchronous Get)下载一个工作线程的文件，当响应是可读的时候，获取回调（Callback）。当响应头已经准备好后，将产生回调（Callback）。读取响应体可能一直阻塞。目前OkHttp不提供异步API来接收响应体的部位。1234567891011121314151617181920212223242526private final OkHttpClient client = new OkHttpClient(); public void run() throws Exception &#123; Request request = new Request.Builder() .url("http://publicobject.com/helloworld.txt") .build(); client.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; e.printStackTrace(); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; try (ResponseBody responseBody = response.body()) &#123; if (!response.isSuccessful()) throw new IOException("Unexpected code " + response); Headers responseHeaders = response.headers(); for (int i = 0, size = responseHeaders.size(); i &lt; size; i++) &#123; System.out.println(responseHeaders.name(i) + ": " + responseHeaders.value(i)); &#125; System.out.println(responseBody.string()); &#125; &#125; &#125;); &#125; 访问头典型的HTTP头工作就像一个Map ：每个字段都有一个值或无值。但是，一些头部(headers)允许多个值，比如Guava的Multimap。例如，它共同为一个HTTP响应提供多个Vary头。OkHttp的API，试图使这两种情况下都能舒适使用。 当写请求头，用header(name, value)来为唯一出现的name设置value。如果它本身存在值，在添加新的value之前，他们会被移除。使用addHeader(name, value)来添加头部不需要移除当前存在的headers。 当读取响应头，用header(name)返回最后设置name的value。如果没有value，header(name)将返回null。可以使用headers(name)来读取所有列表字段的值，。 要访问所有的头部，用Headers类，它支持索引访问。123456789101112131415161718private final OkHttpClient client = new OkHttpClient();public void run() throws Exception &#123; Request request = new Request.Builder() .url("https://api.github.com/repos/square/okhttp/issues") .header("User-Agent", "OkHttp Headers.java") .addHeader("Accept", "application/json; q=0.5") .addHeader("Accept", "application/vnd.github.v3+json") .build(); try (Response response = client.newCall(request).execute()) &#123; if (!response.isSuccessful()) throw new IOException("Unexpected code " + response); System.out.println("Server: " + response.header("Server")); System.out.println("Date: " + response.header("Date")); System.out.println("Vary: " + response.headers("Vary")); &#125;&#125; 提交一个文本(Posting a String)使用HTTP POST的请求体发送到服务。下面例子post了一个markdown文档到一个的Web服务（将markdown作为HTML）。由于整个请求体是同时在内存中，应避免使用此API发送较大（大于1 MIB）的文件。12345678910111213141516171819202122232425public static final MediaType MEDIA_TYPE_MARKDOWN = MediaType.parse("text/x-markdown; charset=utf-8");private final OkHttpClient client = new OkHttpClient();public void run() throws Exception &#123; String postBody = "" + "Releases\n" + "--------\n" + "\n" + " * _1.0_ May 6, 2013\n" + " * _1.1_ June 15, 2013\n" + " * _1.2_ August 11, 2013\n"; Request request = new Request.Builder() .url("https://api.github.com/markdown/raw") .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, postBody)) .build(); try (Response response = client.newCall(request).execute()) &#123; if (!response.isSuccessful()) throw new IOException("Unexpected code " + response); System.out.println(response.body().string()); &#125;&#125; 发布一个流(Post Streaming)在这里，我们POST请求体作为stream。将正在生成请求体的内容写入到stream中。下面例子streams直接进入Okio缓冲水槽。你的程序可能更喜欢使用OutputStream，你可以通过BufferedSink.outputStream（）获得 OutputStream。123456789101112131415161718192021222324252627282930313233343536373839public static final MediaType MEDIA_TYPE_MARKDOWN = MediaType.parse("text/x-markdown; charset=utf-8");private final OkHttpClient client = new OkHttpClient();public void run() throws Exception &#123; RequestBody requestBody = new RequestBody() &#123; @Override public MediaType contentType() &#123; return MEDIA_TYPE_MARKDOWN; &#125; @Override public void writeTo(BufferedSink sink) throws IOException &#123; sink.writeUtf8("Numbers\n"); sink.writeUtf8("-------\n"); for (int i = 2; i &lt;= 997; i++) &#123; sink.writeUtf8(String.format(" * %s = %s\n", i, factor(i))); &#125; &#125; private String factor(int n) &#123; for (int i = 2; i &lt; n; i++) &#123; int x = n / i; if (x * i == n) return factor(x) + " × " + i; &#125; return Integer.toString(n); &#125; &#125;; Request request = new Request.Builder() .url("https://api.github.com/markdown/raw") .post(requestBody) .build(); try (Response response = client.newCall(request).execute()) &#123; if (!response.isSuccessful()) throw new IOException("Unexpected code " + response); System.out.println(response.body().string()); &#125;&#125; 发布文件(Posting a File)将文件作为请求体是很容易的。12345678910111213141516171819public static final MediaType MEDIA_TYPE_MARKDOWN = MediaType.parse("text/x-markdown; charset=utf-8");private final OkHttpClient client = new OkHttpClient();public void run() throws Exception &#123; File file = new File("README.md"); Request request = new Request.Builder() .url("https://api.github.com/markdown/raw") .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, file)) .build(); try (Response response = client.newCall(request).execute()) &#123; if (!response.isSuccessful()) throw new IOException("Unexpected code " + response); System.out.println(response.body().string()); &#125;&#125; 发布表单(Posting form parameters)使用FormBody.Builder建立一个请求体，它就像一个HTML的&lt;form&gt;标记。Names和values将使用HTML兼容的表单URL编码进行编码。1234567891011121314151617private final OkHttpClient client = new OkHttpClient();public void run() throws Exception &#123; RequestBody formBody = new FormBody.Builder() .add("search", "Jurassic Park") .build(); Request request = new Request.Builder() .url("https://en.wikipedia.org/w/index.php") .post(formBody) .build(); try (Response response = client.newCall(request).execute()) &#123; if (!response.isSuccessful()) throw new IOException("Unexpected code " + response); System.out.println(response.body().string()); &#125;&#125; 发布multipart请求(Posting a multipart request)MultipartBody.Builder可以构建与HTML文件上传表单兼容的复杂请求主体。multipart请求体的每一部分本身就是请求体，并且可以定义自己的头部。如果存在，这些头应该描述的部分请求体，如它的Content-Disposition。如果Content-Length和 Content-Type头部可以使用，则他们会自动添加。123456789101112131415161718192021222324252627282930/** * The imgur client ID for OkHttp recipes. If you're using imgur for anything other than running * these examples, please request your own client ID! https://api.imgur.com/oauth2 */private static final String IMGUR_CLIENT_ID = "...";private static final MediaType MEDIA_TYPE_PNG = MediaType.parse("image/png");private final OkHttpClient client = new OkHttpClient();public void run() throws Exception &#123; // Use the imgur image upload API as documented at https://api.imgur.com/endpoints/image RequestBody requestBody = new MultipartBody.Builder() .setType(MultipartBody.FORM) .addFormDataPart("title", "Square Logo") .addFormDataPart("image", "logo-square.png", RequestBody.create(MEDIA_TYPE_PNG, new File("website/static/logo-square.png"))) .build(); Request request = new Request.Builder() .header("Authorization", "Client-ID " + IMGUR_CLIENT_ID) .url("https://api.imgur.com/3/image") .post(requestBody) .build(); try (Response response = client.newCall(request).execute()) &#123; if (!response.isSuccessful()) throw new IOException("Unexpected code " + response); System.out.println(response.body().string()); &#125;&#125; 用Moshi解析JSON响应Moshi是一个便捷的API，用于在JSON和Java对象之间进行转换。这里我们使用它来解码来自GitHub API的JSON响应。 请注意，ResponseBody.charStream()使用Content-Type响应头来选择解码响应主体时使用哪个字符集。如果没有指定字符集，它默认为UTF-8。123456789101112131415161718192021222324252627private final OkHttpClient client = new OkHttpClient();private final Moshi moshi = new Moshi.Builder().build();private final JsonAdapter&lt;Gist&gt; gistJsonAdapter = moshi.adapter(Gist.class);public void run() throws Exception &#123; Request request = new Request.Builder() .url("https://api.github.com/gists/c2a7c39532239ff261be") .build(); try (Response response = client.newCall(request).execute()) &#123; if (!response.isSuccessful()) throw new IOException("Unexpected code " + response); Gist gist = gistJsonAdapter.fromJson(response.body().source()); for (Map.Entry&lt;String, GistFile&gt; entry : gist.files.entrySet()) &#123; System.out.println(entry.getKey()); System.out.println(entry.getValue().content); &#125; &#125;&#125;static class Gist &#123; Map&lt;String, GistFile&gt; files;&#125;static class GistFile &#123; String content;&#125; 响应缓存要缓存响应，你需要有一个缓存目录来进行读取和写入，并限制缓存的大小。缓存目录应该是私有的，不被信任的应用程序不能够阅读其内容！ 多个缓存同时访问相同的缓存目录，这是错误的。大多数应用程序应该调用一次new OkHttpClient()，在任何地方都使用相同的实例和自己的缓存配置。否则，这两个缓存实例将踩到对方，破坏响应缓存，这可能使你的程序崩溃。 响应缓存使用HTTP头进行配置。您可以添加请求头Cache-Control: max-stale=3600，这样OkHttp的缓存就会遵循他们。你的网络服务器可以通过自己的响应头配置缓存多长时间的响应，如Cache-Control: max-age=9600。有缓存头强制缓存的响应，强制网络响应，或强制使用条件GET验证的网络响应。 1234567891011121314151617181920212223242526272829303132333435363738private final OkHttpClient client;public CacheResponse(File cacheDirectory) throws Exception &#123; int cacheSize = 10 * 1024 * 1024; // 10 MiB Cache cache = new Cache(cacheDirectory, cacheSize); client = new OkHttpClient.Builder() .cache(cache) .build();&#125;public void run() throws Exception &#123; Request request = new Request.Builder() .url("http://publicobject.com/helloworld.txt") .build(); String response1Body; try (Response response1 = client.newCall(request).execute()) &#123; if (!response1.isSuccessful()) throw new IOException("Unexpected code " + response1); response1Body = response1.body().string(); System.out.println("Response 1 response: " + response1); System.out.println("Response 1 cache response: " + response1.cacheResponse()); System.out.println("Response 1 network response: " + response1.networkResponse()); &#125; String response2Body; try (Response response2 = client.newCall(request).execute()) &#123; if (!response2.isSuccessful()) throw new IOException("Unexpected code " + response2); response2Body = response2.body().string(); System.out.println("Response 2 response: " + response2); System.out.println("Response 2 cache response: " + response2.cacheResponse()); System.out.println("Response 2 network response: " + response2.networkResponse()); &#125; System.out.println("Response 2 equals Response 1? " + response1Body.equals(response2Body));&#125; 使用CacheControl.FORCE_NETWORK可以禁止使用缓存的响应。使用CacheControl.FORCE_CACHE可以禁止使用网络。警告：如果您使用FORCE_CACHE和响应来自网络，OkHttp将会返回一个504不可满足请求的响应。 取消Call通过Call.cancel()来立即停止正在进行的Call。如果一个线程目前正在写请求或读响应，它还将收到一个IOException异常。当一个Call不需要时，使用取消Call来保护网络; 例如，当用户从应用程序导航离开。同步和异步调用可以被取消。1234567891011121314151617181920212223242526272829private final ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);private final OkHttpClient client = new OkHttpClient();public void run() throws Exception &#123; Request request = new Request.Builder() .url("http://httpbin.org/delay/2") // This URL is served with a 2 second delay. .build(); final long startNanos = System.nanoTime(); final Call call = client.newCall(request); // Schedule a job to cancel the call in 1 second. executor.schedule(new Runnable() &#123; @Override public void run() &#123; System.out.printf("%.2f Canceling call.%n", (System.nanoTime() - startNanos) / 1e9f); call.cancel(); System.out.printf("%.2f Canceled call.%n", (System.nanoTime() - startNanos) / 1e9f); &#125; &#125;, 1, TimeUnit.SECONDS); System.out.printf("%.2f Executing call.%n", (System.nanoTime() - startNanos) / 1e9f); try (Response response = call.execute()) &#123; System.out.printf("%.2f Call was expected to fail, but completed: %s%n", (System.nanoTime() - startNanos) / 1e9f, response); &#125; catch (IOException e) &#123; System.out.printf("%.2f Call failed as expected: %s%n", (System.nanoTime() - startNanos) / 1e9f, e); &#125;&#125; 超时当无法访问查询时，将调用超时失败。超时在网络划分中可以是由于客户端连接问题，服务器可用性的问题，或两者之间的任何东西。OkHttp支持连接，读取和写入超时。12345678910111213141516171819private final OkHttpClient client;public ConfigureTimeouts() throws Exception &#123; client = new OkHttpClient.Builder() .connectTimeout(10, TimeUnit.SECONDS) .writeTimeout(10, TimeUnit.SECONDS) .readTimeout(30, TimeUnit.SECONDS) .build();&#125;public void run() throws Exception &#123; Request request = new Request.Builder() .url("http://httpbin.org/delay/2") // This URL is served with a 2 second delay. .build(); try (Response response = client.newCall(request).execute()) &#123; System.out.println("Response completed: " + response); &#125;&#125; 每个呼叫配置所有的HTTP客户端都在OkHttpClient中配置，这包括代理设置，超时和缓存。当你需要改变单一Call的配置时，调用OkHttpClient.newBuilder()。这将返回共享相同的连接池，调度和配置的原客户端的建造器。在下面的例子中，我们做了500毫秒超时，另外一个3000毫秒超时请求。 123456789101112131415161718192021222324252627private final OkHttpClient client = new OkHttpClient();public void run() throws Exception &#123; Request request = new Request.Builder() .url("http://httpbin.org/delay/1") // This URL is served with a 1 second delay. .build(); // Copy to customize OkHttp for this request. OkHttpClient client1 = client.newBuilder() .readTimeout(500, TimeUnit.MILLISECONDS) .build(); try (Response response = client1.newCall(request).execute()) &#123; System.out.println("Response 1 succeeded: " + response); &#125; catch (IOException e) &#123; System.out.println("Response 1 failed: " + e); &#125; // Copy to customize OkHttp for this request. OkHttpClient client2 = client.newBuilder() .readTimeout(3000, TimeUnit.MILLISECONDS) .build(); try (Response response = client2.newCall(request).execute()) &#123; System.out.println("Response 2 succeeded: " + response); &#125; catch (IOException e) &#123; System.out.println("Response 2 failed: " + e); &#125;&#125; 认证处理OkHttp能够自动重试未经授权的请求。当响应是401 Not Authorized，一个Authenticator被要求提供凭据。应该建立一个包含缺少凭据的新要求。如果没有凭证可用，则返回null跳过重试。 使用Response.challenges（）获得任何认证挑战方案和领域。当完成一个基本的挑战，用Credentials.basic(username, password)编码请求头。1234567891011121314151617181920212223242526272829303132private final OkHttpClient client;public Authenticate() &#123; client = new OkHttpClient.Builder() .authenticator(new Authenticator() &#123; @Override public Request authenticate(Route route, Response response) throws IOException &#123; if (response.request().header("Authorization") != null) &#123; return null; // Give up, we've already attempted to authenticate. &#125; System.out.println("Authenticating for response: " + response); System.out.println("Challenges: " + response.challenges()); String credential = Credentials.basic("jesse", "password1"); return response.request().newBuilder() .header("Authorization", credential) .build(); &#125; &#125;) .build();&#125;public void run() throws Exception &#123; Request request = new Request.Builder() .url("http://publicobject.com/secrets/hellosecret.txt") .build(); try (Response response = client.newCall(request).execute()) &#123; if (!response.isSuccessful()) throw new IOException("Unexpected code " + response); System.out.println(response.body().string()); &#125;&#125; 为了避免验证时不工作的重试，你可以返回null放弃。例如，当这些确切的凭据已经尝试,您可以跳过重试：123if (credential.equals(response.request().header("Authorization"))) &#123; return null; // 如果我们已经使用这些凭据失败，不重试 &#125; 当你的应用尝试的次数超过了限制的次数时，你可以跳过重试：123if (responseCount(response) &gt;= 3) &#123; return null; //如果我们已经失败了3次，放弃。 . &#125; 这上面的代码依赖于下面的responseCount()方法：1234567private int responseCount(Response response) &#123; int result = 1; while ((response = response.priorResponse()) != null) &#123; result++; &#125; return result; &#125; Interceptors(拦截器)拦截器是一个强大的机制，它可以监控，重写和重试Calls。下面是一个简单记录传出请求和响应传入的拦截器。1234567891011121314151617class LoggingInterceptor implements Interceptor &#123; @Override public Response intercept(Interceptor.Chain chain) throws IOException &#123; Request request = chain.request(); long t1 = System.nanoTime(); logger.info(String.format("Sending request %s on %s%n%s", request.url(), chain.connection(), request.headers())); Response response = chain.proceed(request); long t2 = System.nanoTime(); logger.info(String.format("Received response for %s in %.1fms%n%s", response.request().url(), (t2 - t1) / 1e6d, response.headers())); return response; &#125;&#125; 调用chain.proceed(request)是每个拦截器实现的关键部分。这个看起来很简单的方法就是所有HTTP工作发生的地方，产生满足请求的响应。 拦截器可以被链接。假设你有一个压缩拦截器和一个校验和拦截器：你需要决定数据是压缩的，然后进行校验和，或者校验和压缩。OkHttp使用列表来跟踪拦截器，拦截器是按顺序调用的。 应用程序拦截器拦截器可以注册为应用拦截器或网络拦截器。我们将使用LoggingInterceptor来区别。 通过在OkHttpClient.Builder上调用addInterceptor（）来注册应用程序拦截器：1234567891011OkHttpClient client = new OkHttpClient.Builder() .addInterceptor(new LoggingInterceptor()) .build();Request request = new Request.Builder() .url("http://www.publicobject.com/helloworld.txt") .header("User-Agent", "OkHttp Example") .build();Response response = client.newCall(request).execute();response.body().close(); 该URL：http://www.publicobject.com/helloworld.txt 重定向到https://publicobject.com/helloworld.txt, OkHttp自动重定向。我们的应用程序拦截器被调用一次，返回的响应chain.proceed()具有重定向的响应：12345678INFO: Sending request http://www.publicobject.com/helloworld.txt on nullUser-Agent: OkHttp ExampleINFO: Received response for https://publicobject.com/helloworld.txt in 1179.7msServer: nginx/1.4.6 (Ubuntu)Content-Type: text/plainContent-Length: 1759Connection: keep-alive 我们可以看到，我们被重定向了，因为response.request().url()不同于request.url()。这两个日志语句记录两个不同的URL。 网络拦截器注册网络拦截器很类似。调用addNetworkInterceptor()代替addInterceptor()：1234567891011OkHttpClient client = new OkHttpClient.Builder() .addNetworkInterceptor(new LoggingInterceptor()) .build();Request request = new Request.Builder() .url("http://www.publicobject.com/helloworld.txt") .header("User-Agent", "OkHttp Example") .build();Response response = client.newCall(request).execute();response.body().close(); 当我们运行这个代码时，拦截器运行两次。一次为最初的请求http://www.publicobject.com/helloworld.txt，另一个为重定向https://publicobject.com/helloworld.txt。123456789101112131415161718192021222324INFO: Sending request http://www.publicobject.com/helloworld.txt on Connection&#123;www.publicobject.com:80, proxy=DIRECT hostAddress=54.187.32.157 cipherSuite=none protocol=http/1.1&#125;User-Agent: OkHttp ExampleHost: www.publicobject.comConnection: Keep-AliveAccept-Encoding: gzipINFO: Received response for http://www.publicobject.com/helloworld.txt in 115.6msServer: nginx/1.4.6 (Ubuntu)Content-Type: text/htmlContent-Length: 193Connection: keep-aliveLocation: https://publicobject.com/helloworld.txtINFO: Sending request https://publicobject.com/helloworld.txt on Connection&#123;publicobject.com:443, proxy=DIRECT hostAddress=54.187.32.157 cipherSuite=TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA protocol=http/1.1&#125;User-Agent: OkHttp ExampleHost: publicobject.comConnection: Keep-AliveAccept-Encoding: gzipINFO: Received response for https://publicobject.com/helloworld.txt in 80.9msServer: nginx/1.4.6 (Ubuntu)Content-Type: text/plainContent-Length: 1759Connection: keep-alive 网络请求还包含很多数据，如OkHttp加入Accept-Encoding: gzip头部通知支持压缩响应。网络拦截器的链具有非空的连接，它可用于询问IP地址和连接到网络服务器的TLS配置。 应用程序和网络拦截之间进行选择每个拦截器链(interceptor chain)都具有相对优势。 应用拦截器 不必担心像重定向和重试的中间响应。 总是被调用一次，即使HTTP响应来自缓存服务。 观察应用程序的原意。不关心OkHttp注入的头文件，如 If-None-Match。 允许短路和不调用Chain.proceed（） 。 允许重试，并多次调用Chain.proceed（） 。 网络拦截器 能够操作像重定向和重试的中间响应。 在短路网络上不调用缓存的响应。 观察在网络上传输的数据。 访问Connection承载请求。 重写请求拦截器可以添加，删除或替换请求头。他们还可以转换请求体。例如，如果你连接到已知支持它的网络服务器，你可以使用应用程序拦截器添加请求体的压缩。123456789101112131415161718192021222324252627282930313233/** This interceptor compresses the HTTP request body. Many webservers can't handle this! */final class GzipRequestInterceptor implements Interceptor &#123; @Override public Response intercept(Interceptor.Chain chain) throws IOException &#123; Request originalRequest = chain.request(); if (originalRequest.body() == null || originalRequest.header("Content-Encoding") != null) &#123; return chain.proceed(originalRequest); &#125; Request compressedRequest = originalRequest.newBuilder() .header("Content-Encoding", "gzip") .method(originalRequest.method(), gzip(originalRequest.body())) .build(); return chain.proceed(compressedRequest); &#125; private RequestBody gzip(final RequestBody body) &#123; return new RequestBody() &#123; @Override public MediaType contentType() &#123; return body.contentType(); &#125; @Override public long contentLength() &#123; return -1; // We don't know the compressed length in advance! &#125; @Override public void writeTo(BufferedSink sink) throws IOException &#123; BufferedSink gzipSink = Okio.buffer(new GzipSink(sink)); body.writeTo(gzipSink); gzipSink.close(); &#125; &#125;; &#125;&#125; 重写响应相对应的，拦截器也可以重写响应头和转换响应体。通常不要重写请求头，因为它可能违反了Web服务器的期望导致更危险！ 在一个棘手的情况下，如果已经做好应对的后果，重写响应头是解决问题的有效方式。例如，您可以修复服务器的配置错误的Cache-Control响应头以便更好地响应缓存：123456789/** Dangerous interceptor that rewrites the server's cache-control header. */private static final Interceptor REWRITE_CACHE_CONTROL_INTERCEPTOR = new Interceptor() &#123; @Override public Response intercept(Interceptor.Chain chain) throws IOException &#123; Response originalResponse = chain.proceed(chain.request()); return originalResponse.newBuilder() .header("Cache-Control", "max-age=60") .build(); &#125;&#125;; 通常此方法效果最好，它补充了在Web服务器上相应的修复！ 可用性OkHttp的拦截器需要OkHttp 2.2或更高版本。不幸的是，拦截器不适OkUrlFactory用于构建它的库，包括Retrofit≤1.8和Picasso≤2.4。 HTTPSOkHttp试图平衡两个相互竞争的担忧： 连接到尽可能多的主机。这包括运行最新版本的boringssl的高级主机，以及运行旧版本OpenSSL的过时主机。 连接的安全性。这包括验证具有证书的远程网络服务器以及与强密码交换的数据的私密性。协商连接到HTTPS服务器时，OkHttp需要知道提供哪些TLS版本和密码套件。希望最大化连接的客户端将包括过时的TLS版本和弱设计密码套件。一个想要最大限度地提高安全性的严格的客户端将仅限于最新的TLS版本和最强的密码套件。 ConnectionSpec实现特定的安全性和连接性决定。OkHttp包含三个内置的连接规范： MODERN_TLS是连接到现代HTTPS服务器的安全配置。 COMPATIBLE_TLS是一种连接到安全但不是当前HTTPS服务器的安全配置。 CLEARTEXT是用于http://URL 的不安全配置。 默认情况下，OkHttp将尝试MODERN_TLS连接，COMPATIBLE_TLS如果现代配置失败，则回退连接。 每个规范中的TLS版本和密码套件可随每个版本而改变。例如，在OkHttp 2.2中，我们放弃了对SSL 3.0的支持来响应POODLE攻击。而在OkHttp 2.3我们放弃了对RC4的支持。与您的桌面网络浏览器一样，保持OkHttp的最新状态是保持安全的最佳方式。 您可以使用自定义的TLS版本和密码套件来构建自己的连接规范。例如，这种配置仅限于三个备受好评的密码套件。它的缺点是它需要Android 5.0+和一个类似的当前网络服务器。 1234567891011ConnectionSpec spec = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS) .tlsVersions(TlsVersion.TLS_1_2) .cipherSuites( CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256, CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256, CipherSuite.TLS_DHE_RSA_WITH_AES_128_GCM_SHA256) .build();OkHttpClient client = new OkHttpClient.Builder() .connectionSpecs(Collections.singletonList(spec)) .build(); 证书锁定默认情况下，OkHttp信任主机平台的证书权限。这一战略最大限度地提高了连接性，但是它受到证书颁发机构的攻击，例如[2011年DigiNotar攻击。它还假定您的HTTPS服务器的证书由证书颁发机构签名。 使用CertificatePinner来限制哪些证书和证书颁发机构是可信的。证书固定增加了安全性，但是限制了您的服务器团队更新其TLS证书的能力。如果没有服务器的TLS管理员的同意，请勿使用证书锁定！ 1234567891011121314151617181920public CertificatePinning() &#123; client = new OkHttpClient.Builder() .certificatePinner(new CertificatePinner.Builder() .add("publicobject.com", "sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=") .build()) .build();&#125;public void run() throws Exception &#123; Request request = new Request.Builder() .url("https://publicobject.com/robots.txt") .build(); Response response = client.newCall(request).execute(); if (!response.isSuccessful()) throw new IOException("Unexpected code " + response); for (Certificate certificate : response.handshake().peerCertificates()) &#123; System.out.println(CertificatePinner.pin(certificate)); &#125;&#125; 自定义可信证书完整的代码示例显示了如何用自己的集合替换主机平台的证书颁发机构。如上所述，请勿在没有服务器的TLS管理员同意的情况下使用自定义证书！12345678910111213141516171819202122232425private final OkHttpClient client;public CustomTrust() &#123; SSLContext sslContext = sslContextForTrustedCertificates(trustedCertificatesInputStream()); client = new OkHttpClient.Builder() .sslSocketFactory(sslContext.getSocketFactory()) .build();&#125;public void run() throws Exception &#123; Request request = new Request.Builder() .url("https://publicobject.com/helloworld.txt") .build(); Response response = client.newCall(request).execute(); System.out.println(response.body().string());&#125;private InputStream trustedCertificatesInputStream() &#123; ... // Full source omitted. See sample.&#125;public SSLContext sslContextForTrustedCertificates(InputStream in) &#123; ... // Full source omitted. See sample.&#125; Events(事件监听)事件允许您在应用程序的HTTP调用中捕获度量值。使用事件进行监视： HTTP调用您的应用程序的大小和频率。如果你声明了太多的calls，或者你的calls太大，你应该知道它的一切 这些调用在底层网络上的性能。如果网络性能不足，则需要改善网络或少用网络。 警告：这是一个非最终的API。从OkHttp 3.9开始，此功能是一个不稳定的预览：API可能会更改，并且实现不完整。我们预计OkHttp 3.10或3.11将完成这个API。在此之前，当您更新您的OkHttp依赖关系时，请准备API和行为更改。 事件监听子类 EventListener,覆盖您感兴趣的事件的方法。在没有重定向或重试的成功HTTP调用中，事件序列由此流程描述。以下是一个示例事件侦听器，它使用时间戳打印每个事件。123456789101112131415161718192021222324252627282930class PrintingEventListener extends EventListener &#123; private long callStartNanos; private void printEvent(String name) &#123; long nowNanos = System.nanoTime(); if (name.equals("callStart")) &#123; callStartNanos = nowNanos; &#125; long elapsedNanos = nowNanos - callStartNanos; System.out.printf("%.3f %s%n", elapsedNanos / 1000000000d, name); &#125; @Override public void callStart(Call call) &#123; printEvent("callStart"); &#125; @Override public void callEnd(Call call) &#123; printEvent("callEnd"); &#125; @Override public void dnsStart(Call call, String domainName) &#123; printEvent("dnsStart"); &#125; @Override public void dnsEnd(Call call, String domainName, List&lt;InetAddress&gt; inetAddressList) &#123; printEvent("dnsEnd"); &#125; ...&#125; 我们做几个calls：123456789101112131415Request request = new Request.Builder() .url("https://publicobject.com/helloworld.txt") .build();System.out.println("REQUEST 1 (new connection)");try (Response response = client.newCall(request).execute()) &#123; // Consume and discard the response body. response.body().source().readByteString();&#125;System.out.println("REQUEST 2 (pooled connection)");try (Response response = client.newCall(request).execute()) &#123; // Consume and discard the response body. response.body().source().readByteString();&#125; 监听器打印相应的事件：12345678910111213141516171819202122232425262728REQUEST 1 (new connection)0.000 callStart0.010 dnsStart0.017 dnsEnd0.025 connectStart0.117 secureConnectStart0.586 secureConnectEnd0.586 connectEnd0.587 connectionAcquired0.588 requestHeadersStart0.590 requestHeadersEnd0.591 responseHeadersStart0.675 responseHeadersEnd0.676 responseBodyStart0.679 responseBodyEnd0.679 connectionReleased0.680 callEndREQUEST 2 (pooled connection)0.000 callStart0.001 connectionAcquired0.001 requestHeadersStart0.001 requestHeadersEnd0.002 responseHeadersStart0.082 responseHeadersEnd0.082 responseBodyStart0.082 responseBodyEnd0.083 connectionReleased0.083 callEnd 注意第二次调用没有连接事件。它重用了第一个请求的连接，以显着提高性能。 EventListener.Factory在前面的例子中，我们使用了一个字段callStartNanos来跟踪每个事件的经过时间。这很方便，但是如果多个调用同时执行，它将不起作用。为了适应这个，使用一个Factory创建一个新的EventListener为每个Call。这允许每个监听者保持特定于呼叫的状态。 此示例工厂为每个呼叫创建一个唯一的ID，并使用该ID区分日志消息中的呼叫。12345678910111213141516171819202122232425262728293031323334class PrintingEventListener extends EventListener &#123; public static final Factory FACTORY = new Factory() &#123; final AtomicLong nextCallId = new AtomicLong(1L); @Override public EventListener create(Call call) &#123; long callId = nextCallId.getAndIncrement(); System.out.printf("%04d %s%n", callId, call.request().url()); return new PrintingEventListener(callId, System.nanoTime()); &#125; &#125;; final long callId; final long callStartNanos; public PrintingEventListener(long callId, long callStartNanos) &#123; this.callId = callId; this.callStartNanos = callStartNanos; &#125; private void printEvent(String name) &#123; long elapsedNanos = System.nanoTime() - callStartNanos; System.out.printf("%04d %.3f %s%n", callId, elapsedNanos / 1000000000d, name); &#125; @Override public void callStart(Call call) &#123; printEvent("callStart"); &#125; @Override public void callEnd(Call call) &#123; printEvent("callEnd"); &#125; ...&#125; 我们可以使用这个侦听器来竞争一对并发的HTTP请求：12345678910111213Request washingtonPostRequest = new Request.Builder() .url("https://www.washingtonpost.com/") .build();client.newCall(washingtonPostRequest).enqueue(new Callback() &#123; ...&#125;);Request newYorkTimesRequest = new Request.Builder() .url("https://www.nytimes.com/") .build();client.newCall(newYorkTimesRequest).enqueue(new Callback() &#123; ...&#125;); 运行这场比赛的家庭无线网络显示，Times（0002）比Post（0001）略快一点：123456789101112131415161718192021222324252627282930313233340001 https://www.washingtonpost.com/0001 0.000 callStart0002 https://www.nytimes.com/0002 0.000 callStart0002 0.010 dnsStart0001 0.013 dnsStart0001 0.022 dnsEnd0002 0.019 dnsEnd0001 0.028 connectStart0002 0.025 connectStart0002 0.072 secureConnectStart0001 0.075 secureConnectStart0001 0.386 secureConnectEnd0002 0.390 secureConnectEnd0002 0.400 connectEnd0001 0.403 connectEnd0002 0.401 connectionAcquired0001 0.404 connectionAcquired0001 0.406 requestHeadersStart0002 0.403 requestHeadersStart0001 0.414 requestHeadersEnd0002 0.411 requestHeadersEnd0002 0.412 responseHeadersStart0001 0.415 responseHeadersStart0002 0.474 responseHeadersEnd0002 0.475 responseBodyStart0001 0.554 responseHeadersEnd0001 0.555 responseBodyStart0002 0.554 responseBodyEnd0002 0.554 connectionReleased0002 0.554 callEnd0001 0.624 responseBodyEnd0001 0.624 connectionReleased0001 0.624 callEnd 该EventListener.Factory还能够指标限制呼叫的子集。这一个随机捕获指标为10％：12345678910111213class MetricsEventListener extends EventListener &#123; private static final Factory FACTORY = new Factory() &#123; @Override public EventListener create(Call call) &#123; if (Math.random() &lt; 0.10) &#123; return new MetricsEventListener(call); &#125; else &#123; return EventListener.NONE; &#125; &#125; &#125;; ...&#125; 事件与失败当操作失败时，调用失败方法。这是connectFailed()在建立到服务器的连接callFailed()时，以及HTTP调用永久失败时的失败。发生故障时，start事件可能没有相应的end事件。 事件与重试和跟进OkHttp具有弹性，可以自动从一些连接失败中恢复。在这种情况下，connectFailed()事件不是终端，也不是随之而来的callFailed()。当尝试重试时，事件监听器将收到多个相同类型的事件。 单个HTTP调用可能需要后续请求来处理认证挑战，重定向和HTTP层超时。在这种情况下，可能会尝试多个连接，请求和响应。跟进是单个电话可能触发多个相同类型事件的另一个原因。 可用性OkHttp 3.9中的预览版本提供了事件。我们预计OkHttp 3.10或3.11将完成这个API。未来版本可能会引入新的事件类型; 您将需要覆盖相应的方法来处理它们。 FAQs(常见问题解答))如何修复dalvikvm中的验证警告？OkHttp支持一些需要Java 7+或Android API 20+的API。如果你在早期的Android版本上运行OkHttp，dalvikvm的验证器会警告你缺少的方法。这不是一个问题，你可以忽略警告。12345678910111213141516I/dalvikvm﹕ Could not find method okhttp3.internal.huc.HttpURLConnectionImpl.getContentLengthLong, referenced from method okhttp3.internal.huc.HttpsURLConnectionImpl.getContentLengthLongW/dalvikvm﹕ VFY: unable to resolve virtual method 21498: Lokhttp3/internal/huc/HttpURLConnectionImpl;.getContentLengthLong ()JD/dalvikvm﹕ VFY: replacing opcode 0x6e at 0x0002I/dalvikvm﹕ Could not find method okhttp3.internal.huc.HttpURLConnectionImpl.getHeaderFieldLong, referenced from method okhttp3.internal.huc.HttpsURLConnectionImpl.getHeaderFieldLongW/dalvikvm﹕ VFY: unable to resolve virtual method 21503: Lokhttp3/internal/huc/HttpURLConnectionImpl;.getHeaderFieldLong (Ljava/lang/String;J)JD/dalvikvm﹕ VFY: replacing opcode 0x6e at 0x0002W/dalvikvm﹕ VFY: unable to find class referenced in signature (Ljava/nio/file/Path;)W/dalvikvm﹕ VFY: unable to find class referenced in signature ([Ljava/nio/file/OpenOption;)I/dalvikvm﹕ Could not find method java.nio.file.Files.newOutputStream, referenced from method okio.Okio.sinkW/dalvikvm﹕ VFY: unable to resolve static method 24080: Ljava/nio/file/Files;.newOutputStream (Ljava/nio/file/Path;[Ljava/nio/file/OpenOption;)Ljava/io/OutputStream;D/dalvikvm﹕ VFY: replacing opcode 0x71 at 0x000aW/dalvikvm﹕ VFY: unable to find class referenced in signature (Ljava/nio/file/Path;)W/dalvikvm﹕ VFY: unable to find class referenced in signature ([Ljava/nio/file/OpenOption;)I/dalvikvm﹕ Could not find method java.nio.file.Files.newInputStream, referenced from method okio.Okio.sourceW/dalvikvm﹕ VFY: unable to resolve static method 24079: Ljava/nio/file/Files;.newInputStream (Ljava/nio/file/Path;[Ljava/nio/file/OpenOption;)Ljava/io/InputStream;D/dalvikvm﹕ VFY: replacing opcode 0x71 at 0x000a]]></content>
      <categories>
        <category>安卓开源库使用教程</category>
      </categories>
      <tags>
        <tag>okhttp3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio使用技巧和资源]]></title>
    <url>%2FAndroidStudio_uses_skills_and_resources.html</url>
    <content type="text"><![CDATA[版权声明：本文转载自:http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/1116/6776.html.版权归原作者所有 对于AndroidStudio的使用，日常使用没问题，但依旧有些快捷技巧没有习惯使用,因此转载本篇文章常读，希望对文章的技巧有些记忆，做到以后的熟练使用 本文列举出一些可以提高整体效率的Android Studio技巧和资源。 显然有太多太多这方面的东西，但是为了文章的简洁性，我把它限制在50个以内，希望你能喜欢！ 视觉效果1.Android Logcat的Material颜色主题。要改变Android Studio的Logcat你需要这样做：进入Preferences (Windows上是Settings / Linux machines) → Editor → Colors &amp; Fonts → Android Logcat，然后为每种类型的log设置前景颜色（foreground）。 我使用的material颜色： Assert #BA68C8Debug #2196F3Error #F44336Info #4CAF50Verbose #BBBBBBWarning #FF9800注意里面有几个现有的主题，可以直接修改现有主题（不建议），或者点击save as按钮拷贝一个主题并改名为Material theme Color然后再改变每种类型log的颜色。 2.防止当前应用崩溃时Logcat清除log。 在Android Monitor面板的右上方点击下拉菜单中的Edit filter configuration：注意是在工程界面的底部Android Monitor面板，而不是单独的Android Monitor工具中。 3.使用一个适合自己的代码主题 (IntelliJ / Android Studio). 找到Preferences → Code Style → Java，在Scheme下拉菜单中你可以选择一个代码风格（或者设置一个新的）。 有两个风格值得专门提一下： Square Java Code Styles with Android Google Java Code Style 你可以按照下面gif图中的做法导入主题： .使用分屏提高效率 要打开这个功能，右键主屏幕的选项卡（tab）选择 Split Vertically / Horizontally。但是为了尽量提高效率我们需要设置一个自定义的快捷方式。为此找到到Preferences → Keymap，搜索Split Vertically。然后打开一个上下文菜单，点击Add Keyboard Shortcut。 我的分屏（vertical）快捷键设置的是control + alt + v。做法如下面的gif图所示。同样的你还可以为 horizontal split设置快捷键。 5.无干扰模式你可以到View → Enter Distraction Free Mode里启用它 在无干扰模式下，编辑器占据了整个IntelliJIDEA窗口，没有任何tab或者工具按钮。代码居中显示 6.使用Live Templates 你可以使用快捷键：cmd + j (Windows / Linux: ctrl + j)。 可以使用已经定义好了的Live Templates，比如Toasts 或者if语句。 可以使用自定义的templates。这里是Reto Meier的一篇不错的参考文章。你也可以参考IntelliJ IDEA的文档. 快捷键以及有用的命令1.最有用的命令是搜索命令的命令：cmd + shift + a (Windows / Linux: ctrl + shift + a)。 假设你想关闭当前tab却不知道怎么做，你只需输入close你就可以得到一个正确的快捷键/命令。 2.选择最近的复制粘贴（管理剪切版）：cmd + shift + v (Windows / Linux: ctrl + shift + v)。默认有5个最近的复制/粘贴元素。 3.启用多光标功能：control + g (alt + j for Windows / Linux)。 4.打开一个类： cmd + o (Windows / Linux: ctrl + n)。 5.打开任意文件： cmd + shift + o (Windows / Linux: ctrl + shift + n)。 6.打开symbol：cmd + option + o (Windows / Linux: alt + shift + n)。 7.跳到实现：cmd + option + b (Windows / Linux:ctrl + alt + b)。 假如你有一个interface。通过点击接口的名字，然后按下快捷键就可以跳转到这个接口的实现。如果有多个实现会出现下拉选择。 8.跳转到定义：cmd + b (Windows / Linux: ctrl + b)。 可以让你快速跳转到一个类，方法或者变量被定义的地方。 9.跳转到类型定义处：control + shift + b (Windows / Linux:ctrl + shift + b)。 假设你定义了： Employee employee = new Employee(“Michal”); 当你的插入符号在employee上，这时你按下快捷键，你将跳转到Employee类中。 10.跳转到super： cmd + u (Windows / Linux: ctrl + u)。 比如，你重写了一些方法,当你的插入符号在方法名上，按下这个快捷键你将跳转到parent的这个方法。 11.Move between tabs: cmd + shift + (move left) or cmd + shift + (Windows / Linux: alt + ← / →). 12 Move between Design / Text tabs in layout’s view:control + shift + ← / → (Windows / Linux: alt + shift + ← / →). 13.关闭当前的tab：cmd + w (Windows / Linux: ctrl + shift + a)。 14.隐藏所有窗口：cmd + shift + F12 (Windows / Linux:ctrl + shift + F12)。 15.最小化 Android Studio instance: cmd + m (Windows / Linux:ctrl + m)。 16.格式化代码: cmd + option + l (Windows / Linux:ctrl + alt + l)。 17.Auto-indent lines: control + option + i (Windows / Linux:ctrl + alt + i). 18.实现接口的方法: control + i (Windows / Linux: ctrl + i)。 假设你要实现一个接口。这个快捷键可以让你快速导入这个接口的所有方法。 19.Smart code completion (filters the list of methods and variables by expected type): control + shift + space (Windows / Linux: ctrl + shift + space). 20.查找: cmd + f (Windows / Linux: ctrl + f)。 21.查找并替换: cmd + r (Windows / Linux: ctrl + r)。 22.把一个硬编码的字符串放到资源文件中：option + return (Windows / Linux: alt + enter)。光标必须在这个文字之上时才能使用这个快捷键。看下面的gif图： 插件1.Key promoter - 快捷键提示插件 当你点击鼠标一个功能的时候,可以提示 你这个功能快捷键是什么 ,和这个按钮你的使用频率 2.String Manipulation - a plugin which provides actions for text manipulation (e.g. toggling styles like camelCase, hyphen-lowercase etc., capitalize text and many more). 3.Android Material Design Icon Generator -这个插件帮助你为工程添加Material Design图标。安装之后使用快捷键cmd + shift + m生成一个图标。 4.ButterKnifeZelezny - 一键从 布局文件中 生成对于的 View 声明和 ButterKnife 注解： 5.IntelliJ/Android Studio Plugin for Android Parcelable boilerplate code generation - 一个根据类的成员生成Parcelable的插件。 6.ADB Idea - 一个帮助你使用adb命令的插件：卸载，杀死，启动，重启，清除数据等命令。 7.Genymotion plugin - 一个让你可以在Android Studio中创建和开启Genymotion虚拟设备的插件。 8.Android Methods Count - a plugin that parses your Android library dependencies and shows the methods count as an handy hint. 9.Git Flow Integration - a plugin for introducing a Git Flow branching model. 10.Builder plugin - a plugin (from Square) that generates a static nested Builder for a class. 资源1.Android Studio Tips of the Day by Philippe Breault2.快捷键参考3.(About) 10 Things You (Probably) Didn’t Know You Could do in Android Studio by Reto Meier。中文版：10个你可能不知道的 Android Studio技巧。 4.无鼠标开发 by Hadi Hariri6.Android Studio for Experts (Android Dev Summit 2015)7.Android Studio Tips and Tricks by Michael Evans8.认识 Android Studio9.Android Studio - Tips and Tricks by Donn Felker10.Debug Your App with Android Studio11.What are some of your must-have plugins for - Reddit discussion]]></content>
      <categories>
        <category>AndroidStudio</category>
      </categories>
      <tags>
        <tag>AndroidStudio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android5.0新控件学习]]></title>
    <url>%2FAndroid5-0-control-study-AppBarLayout-Toolbar-CoordinateLayout-cardView.html</url>
    <content type="text"><![CDATA[版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起. 本文记录一些Androd5.0的新控件的一些学习总结，由于网上的博文总结的比较全面，我就不写博文总结了，这里主要是列举一些控件的学习资料 CoordinateLayout简介：协调布局,配合Behavior使用，特点是能根据一个View的动作协调另一个View的动作。参考文章:CoordinatorLayout的使用如此简单 ToolBar简介：代替ActionBar，比它更加的灵活，实质是一个ViewGroup 参考资料:Android 5.x Theme 与 ToolBar 实战xamarin android toolbar(踩坑完全入门详解) AppBarLayout简介：继承自LinearLayout,它可以让你定制当某个可滚动View手势发生变化时，其内部子View会实现何种动作. CollapsingToolbarLayout简介：用来对ToolBar进行再次包装的ViewGroup，可以实现一些折叠的效果（更像是缩放），比如向上滑动标题文字逐渐缩小至左上角，它需要作为AppBarLayout布局里面并作为它的直接子View. NestedScrollView简介：为了配合AppBarLayout的滚动效果而编写的滚动控件，继承自FrameLayout,随后使用appbar_scrolling_view_behavior即可实现相应的效果 参考文章:玩转AppBarLayout，更酷炫的顶部栏 CardView简介：卡片布局，继承自FrameLayout，可实现阴影效果,通常与RecycleView或ListView配合使用作为item的容器参考资料:CardView的基本用法 RecyclerView简介：比ListView更加灵活，更低耦合的列表展示控件，可轻易实现ListView,GridView,和瀑布流的效果 参考资料: Android RecyclerView 使用完全解析 体验艺术般的控件 FloatingActionButton简介：用来在界面上显示一个悬浮的按钮参考资料：FloatingActionButton 完全解析[Design Support Library(2)] TextInputLayout简介：通常与EditText配合使用，能在EditText输入时将hint放入到上方，还具有空校验的功能 参考资料：TextInputlayout入门讲解Android Design TextInputLayout 解析,带你深入TextInputLayout TabLayout简介：提供一个水平的布局来展示TAB 参考资料：Design库-TabLayout属性详解TabLayout的高端用法 NavigationView简介:在Material Design中，Navigation drawer导航抽屉，被设计用于应用导航，提供了一种通用的导航方式，体现了设计的一致性。而NavigationView的典型用途就是配合之前v4包的DrawerLayout，作为其中的Drawer部分，即导航菜单的本体部分。NavigationView是一个导航菜单框架，使用menu资源填充数据，使我们可以更简单高效的实现导航菜单。它提供了不错的默认样式、选中项高亮、分组单选、分组子标题、以及可选的Header。 参考资料： Android5.0之NavigationView的使用 Snackbar简介：与Toast相似,弹出一个提示框 参考资料：没时间解释了，快使用Snackbar!——Android Snackbar花式使用指南 Palette简介：取色器，从图片中提取关键的颜色，并将该颜色设置到别的控件上,可以和ToolBar配合使用动态改变颜色参考资料:安卓5.x的Palette之你不知道的事 Android Material Design之Toolbar与Palette实践 RippleDrawable简介：5.0以上的涟漪效果,需要兼容5.0以下需要使用开源库RippleEffect.参考资料：Material Design之RippleDrawable详解]]></content>
      <categories>
        <category>Android基础进阶</category>
        <category>安卓控件</category>
      </categories>
      <tags>
        <tag>Android5.0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些关于安卓非编码问题的解决方案记录]]></title>
    <url>%2F%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8E%E5%AE%89%E5%8D%93%E9%9D%9E%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E8%AE%B0%E5%BD%95.html</url>
    <content type="text"><![CDATA[版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起. 安卓的一些非编码问题的一些解决方案记录，如打包，加密等.. 安卓自动化打包发布工作流,签名加密解决方案：可使用Travis CI项目框架 未自动化前安卓开发的工作流程： 开发一些新功能，提交代码 完成一部分功能后，打包一个测试版APK 将测试版APK上传到QQ群 / 网盘 / Fir.im / 蒲公英等 在QQ群或发布平台解释当前版本所完成的功能 通知测试人员测试 实现了这套自动化发布后，工作流程被简化成： 开发新功能，提交代码 通过git tag对代码打一个内测版的tag，在tag的描述中对写当前完成的功能 此外还支持签名加密：加密前:1234567891011121314151617android &#123; signingConfigs &#123; releaseConfig &#123; storeFile file(&quot;../keys/evandroid.jks&quot;) storePassword &quot;123456&quot; keyAlias &quot;evandroid_alias&quot; keyPassword &quot;654321&quot; &#125; &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; signingConfig signingConfigs.releaseConfig &#125; &#125;&#125; 加密后：123456releaseConfig &#123; storeFile file(&quot;../keys/evandroid.jks&quot;) storePassword project.hasProperty(&quot;KEYSTORE_PASS&quot;) ? KEYSTORE_PASS : System.getenv(&quot;KEYSTORE_PASS&quot;) keyAlias project.hasProperty(&quot;ALIAS_NAME&quot;) ? ALIAS_NAME : System.getenv(&quot;ALIAS_NAME&quot;) keyPassword project.hasProperty(&quot;ALIAS_PASS&quot;) ? ALIAS_PASS : System.getenv(&quot;ALIAS_PASS&quot;)&#125; 密钥完全从后台获取 关于Travis CI的资料: 基于Travis CI搭建Android自动打包发布工作流（支持Github Release及fir.im) 安卓多渠道打包(同时打900个渠道包怎么办？？？)解决方案：V1签名下的快速打包工具：AndroidMultiChannelBuildTool 不管多少渠道包，分分钟打完。 V2签名打包:如果公司需要升级到V2签名,那么上面那个就不在适用，请移步到这个:walle,美团针对V2签名设计的打包工具，不过使用方式与上面的那个不同，需要在项目中添加插件并用Gradle构建打包.]]></content>
      <categories>
        <category>安卓杂记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[objectBox数据库使用教程]]></title>
    <url>%2FobjectBox%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B-objectbox-java.html</url>
    <content type="text"><![CDATA[版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起. 数据库简介objectbox数据库是greenrobot团队开发的全新非关系型数据库框架，该团队还开发过greenDao,EventBus等热门框架，可谓实力雄厚。按照官方介绍，该库有如下特点: 超快速:号称胜过测试过的所有嵌入式数据库 面向对象的 API: 没有 rows、columns 和 SQL，完全从0开始的对象（没有ORM，没有SQLite） 反应性:对数据变化的反应简单而强大,使用ObjectBox中的反应数据观察器或与RxJava集成。 多平台:已经支持安卓和java,ios和MacOs正在集成 简单的线程:ObjectBox返回的对象可以在所以线程中运行 没有手动模式迁移:ObjectBox负责添加，删除和重命名属性的新对象版本，意味着数据库的升级不再需要我们自己管理版本号，ObjectBox内部会自动帮我们管理 安装注意，本教程是基于截至于目前最新版1.4.0编写 根目录build.gradle中添加：12345678910111213141516buildscript &#123; ext.objectboxVersion = &apos;1.4.0&apos; repositories &#123; maven &#123; url &quot;http://objectbox.net/beta-repo/&quot; &#125; &#125; dependencies &#123; classpath &quot;io.objectbox:objectbox-gradle-plugin:$objectboxVersion&quot; &#125; &#125; allprojects &#123; repositories &#123; maven &#123; url &quot;http://objectbox.net/beta-repo/&quot; &#125; &#125;&#125; app build.gradle中添加1apply plugin: &apos;io.objectbox&apos; // after applying Android plugin 使用初始化在Application中的onCreate()中初始化1boxStore = MyObjectBox.builder().androidContext(this).build(); 初始化后得到一个BoxStore对象,该对象可以简单理解为获取查询对象的入口,因此，我们可以申明一个get()方法，像这样：12345678910111213141516171819202122public class BaseApp extends Application &#123; private static BaseApp baseApp; private BoxStore boxStore; //数据库表的管理者 @Override public void onCreate() &#123; super.onCreate(); baseApp = this; boxStore = MyObjectBox.builder().androidContext(this).build(); if (BuildConfig.DEBUG) &#123; new AndroidObjectBrowser(boxStore).start(this); &#125; &#125; public BoxStore getBoxStore()&#123; return boxStore; &#125; public static BaseApp getInstence()&#123; return baseApp; &#125;&#125; 实体类的建立objectbox是通过注解来标明哪个类是实体，常用的注解如下：123456789101112131415161718@Entity //表示这是一个需要持久化的实体public class Student &#123; @Id public long id; @Index public String name; @Transient public int tempUsageCount; @NameInDb(&quot;USERNAME&quot;) public String name; public ToOne&lt;Class&gt; classToOne; public int age;&#125; @Entity：这个对象需要持久化。 @Id：这个对象的主键,默认情况下，id是会被objectbox管理的，也就是自增id，如果你想手动管理id需要在注解的时候加上@Id(assignable = true)即可。当你在自己管理id的时候如果超过long的最大值，objectbox 会报错.id的值不能为负数。当id等于0时objectbox会认为这是一个新的实体对象,因此会新增到数据库表中 @Index：这个对象中的索引。对经常大量进行查询的字段创建索引，会提高你的查询性能。 @Transient:如果你有某个字段不想被持久化，可以使用此注解,那么该字段将不会保存到数据库 @NameInDb：有的时候数据库中的字段跟你的对象字段不匹配的时候，可以使用此注解。 @ToOne:做一对一的关联注解，例如示例中表示一张学生表（Student）关联一张班级表（Class）,此外还有一对多，多对多的关联，例如Class的示例：12345678@Entitypublic class Class&#123; @Id long id; @Backlink(to = &quot;classToOne&quot;) public ToMany&lt;Student&gt; studentEntitys;&#125; @ToMany:做一对多的关联注解，如示例中表示一张班级表(Class)关联多张学生表(Student) @Backlink:表示反向关联 增删改查实体类建立完后，在Android Studio中使用Build&gt; Make project编译一次，objectbox会自动帮你生成相应的操作实体,例如·Student则会生成一个Student_的类，该类通常作为Params传递。 增加一条数据首先我们获取该实体的Box对象，随后调用该对象的put()方法即可完成新增操作1234Box&lt;Student&gt; StudentBox = BaseApp.getInstence().getBoxStore().boxFor(Student.class);Student student = new Student();student.name = &quot;Jay&quot;;StudentBox.put(student); 删除数据1StudentBox.remove(student); //该参数可以传要删除的实体，也可以传入要删除的实体的id,可以批量传入 查询通过Box的query()方法可以得到一个QueryBuilder对象，该对象可以实现各种查询操作，里面包含contains(),equal()等各种便捷的查询方法，示例如下：12//查询一个名叫Jay的学生信息的表Student jayStudent = StudentBox.query().equal(Student_.name, &quot;Jay&quot;).build().find(); 里面的Property对象其实就是传入我们自动生成的Student_对象的参数。 修改objectBox修改数据非常简单，首先得到要修改的实体类，直接修改数据，随后调用put()方法即可，示例如下：1234//查询一个名叫Jay的学生信息的表Student jayStudent = StudentBox.query().equal(Student_.name, &quot;Jay&quot;).build().find();jayStudent.name = &quot;www.huangjie.name&quot;;StudentBox.put(jayStudent); 这样就把Jay改成了我的博客地址,haha~ 数据库的其他操作数据库的数据升级当我们需要新增和删除字段时，直接操作实体类即可，不需要做特殊的更改，如果需要重命名字段名或实体类名，可以按照如下步骤操作：第一步：给需要修改的类名加上@UID注解123@Entity@Uidpublic class MyName &#123; ... &#125; 第二步：编译项目，编译将失败，并且会给你一个UIDerror: [ObjectBox] UID operations for entity &quot;MyName&quot;: [Rename] apply the current UID using @Uid(6645479796472661392L) - [Change/reset] apply a new UID using @Uid(4385203238808477712L)第三步：将Rename后面的UID放入到要修改的类中：123@Entity@Uid(6645479796472661392L)public class MyName &#123; ... &#125; 第四步：进行数据的修改123@Entity@Uid(6645479796472661392L)public class MyNewName &#123; ... &#125; 更改数据属性或重命名字段名同理操作。 表关系@ToOne和@ToMany可以看作JAVA中的T和List的关系,拿班级和学生举例，设置相关的学生对象如下：12345Class class = new Class(); //先创建一个班级Student student = new Student();student.name = &quot;Jay&quot;;student.classToOne.setTarget(class); //设置一对一的target对象，字段参见以上示例long studentId = StudentBox.put(student); 获取该学生的班级信息：12Student student = StudentBox.get(studentId);Class class = student.classToOne.getTarget(); 而一对多的关系更为简单，你可以像List集合一样去操作它：1234567891011Class class_ = new Class(); //先创建一个班级Student s1 = new Student(); //添加一个学生student.name = &quot;Jay&quot;;Student s2 = new Student();s2.name = &quot;Android&quot;;class_ .studentEntitys.add(s1);class_ .studentEntitys.add(s2);Box classBox = BaseApp.getInstence().getBoxStore().boxFor(Class.class);classBox.put(class); 这样的话一张Class表中就有两个学生表的数据了，查询的话可以获取该Class的实体，随后像遍历List集合一样去遍历studentEntitys字段,objectBox提供的方法和List集合几乎一样，这里就不做示例了。 求和等操作使用Query对象即可进行求和等操作,通过QueryBuilder的build()方法即可得到。随后调用sumDouble()等方法传入求和条件即可。我们获取实体类或实体类集合也是使用的该对象获取。 另外，objectBox还支持事务，Rxjava查询，Kotlin的支持，更多详情可以通过官方文档了解http://objectbox.io. Endemmmmmm…写了这么多，个人觉得objectBox挺好用的，目前没发现啥坑，唯一的坑是编译的时候提示找不到MyObjectBox这个类，这个不用担心，先确认一下配置是否有误，无误的话将项目Make Project一下或者重新编译一下就OK了，另外，推荐下我写的ObjectBox数据库的练手项目仿支付宝记账本,仿的支付宝中的记账本功能，结合它看你的objectBox上手更快哦。]]></content>
      <categories>
        <category>安卓开源库使用教程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android开发常见问题汇总]]></title>
    <url>%2FAndroid%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB.html</url>
    <content type="text"><![CDATA[版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起. 此为开发中遇到的一些常见问题的整理，方便下次遇到问题能快速找到解决方案 1 编译出现：1All com.android.support libraries must use the exact same version specification (mixing versions can lead to runtime crashes)...... 如果引用的第三方库的支持库版本低于（或者不一致）app build.gradle中的支持库版本，就会出现这种问题,修改第三方的依赖的话工作量太大,因此考虑所有模块强制使用相同的版本号的支持库，代码如下： 在app build.gradle中添加： 12345678910configurations.all &#123; resolutionStrategy.eachDependency &#123; DependencyResolveDetails details -&gt; def requested = details.requested if (requested.group == 'com.android.support') &#123; if (!requested.name.startsWith("multidex")) &#123; details.useVersion '26.1.0' &#125; &#125; &#125;&#125; 此代码声明了除multdex外全部使用26.1.0的版本库 2 SVG图片兼容问题(主要针对5.0以下机型)参考博客：Android Vector曲折的兼容之路 基本适配方法：在app build.gradle 的defaultConfig中添加defaultvectorDrawables.useSupportLibrary = true xml中使用：ImageView原本是使用src加载,改为app:srcCompat. java中使用：ImageView iv = (ImageView) findViewById(R.id.iv); iv.setImageResource(R.drawable.vector_image); 3.自定义View中在4.X版本上通过getContext()方法强转成Activity失效参考博客： 记一次View.getContext()遇到的大坑 原因：兼容v7包将Context包裹成了TintContextWrapper,所以强转成Activity会出错 解决方法：使用构造方法中的Context来强转。]]></content>
      <categories>
        <category>Android基础进阶</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2017年终总结]]></title>
    <url>%2F2017%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起. 前言从自己开始坚持写博客也有1个月了，感觉非常的充实，博客就是注重总结归纳嘛，既然2017都已经过去，那么也有必要总结归纳一下啦。其实我认为我的2017总结起来就是：行动起来，不再等待，重在参与！ 回首一眨眼2017就过去了，想想自己今年，的确是成长最快的一年，也是忙碌而又平淡的一年，收获了许多。 依稀记得年初，就有了技术进阶的想法，因为感觉自己在许多功能点上‘会做’，但‘不懂’，无法深入的解决问题。于是，我就寻求进阶的方法，我在帅张的公众号上读了他写的一遍文章，文章指出，习惯很重要，我结合自身的行为揣摩这句话，总结发现，学习并不需要强迫自己去学，而应该把它当成一种自然习惯，就像渴了会喝水一样的生活习惯，这种习惯的培养需要的是坚持，以及自律！为此我尝试慢慢去培养自己的学习习惯： 因为公司搬家，我从家到公司需要30-40分钟，在地铁上，以前是都是看一下新闻啊，刷一下微博啊，现在我都是看掘金有没有什么新鲜的框架，看看简书有没有好看的技术文章，看看github有没有火热的技术排名，那些微博什么的我再也没打开过，我已经坚持有大半年的，甚至现在但凡座地铁我也会习惯性打开这些app 以前的我工作回到家都是刷电视剧，现在都是有目的性的去学习一个知识点或者一门语言，这样时间过得非常的快，每天感觉时间不够用，果然当投入到某一件事时时间的流逝是非常快速的。 先前都是自己写demo,自己总结知识点，然后写到印象笔记中，但是我发现里面的知识点太散乱，无法成为一个体系。于是我就试着写博客，为此，我发现了一个新大陆，写博客对于知识的梳理简直太有用了，前提是你想写好一篇博客。 学习知识就要善于总结归纳，书本是最好的老师，为此2017我阅读了一些的书籍： 郭神的《第一行代码》第二版，这是一本基础书籍，它让我对安卓的基础有了更加完善的了解和夯实。 任玉刚的《安卓开发艺术探索》，这是一本进阶类的书籍，它让我突破了瓶颈，对安卓的了解更加的深入了。 我对这两位都非常的钦佩，正是他们让我们这些开发者的进阶至少能提前0.5-1年的时间，《开发艺术探索》我来回读了好几遍，每一次都会有新的收获，再次感谢~ 晚上，我也会偶尔看下慕课网上的视频，我觉得里面的老师讲的还是比较好的，为此我也推荐给大家。 回首2017的技术有如下的总结： 学习了自定义View,对自定义的流程有了较为完善的了解 学习了View体系，view的确是一个非常有魅力的控件，它可以带来无穷的创造力 对数据库框架都有所了解：如公司项目正在使用的ActiveAndroid(作者貌似不维护了？),使用greenDAO做过一些简单的demo,后来发现了greenDao的作者正在开发一个全新的数据库，号称最快的数据库，于是就没有继续深入greenDao的研究，转而研究新的数据库，它就是我现在正在研究的object-box,不过现在资料还较少，届时我会出一个教程。 学习了ExoPlayer视频播放框架，Rxjava,okhttp,mvp等等的一些热门框架和架构 学习了一些kotlin的基本语法 学习了html5的一些基本语法，能制作一些静态页面 基于hexo和coding搭建的博客平台.先前本来是上传到github的，由于百度被墙的关系，就移到coding了。 展望对于2018，我坚信我的坚持会带给我更多的收获。我依旧会努力坚持2017正在做的事情： 坚持写博客，至少1周一篇 坚持技术学习 2018要刷的书有《kotlin实战》，《Android神兵利器》，《安卓群英传》。 2018需要进阶的技术有： kotlin的熟练使用 自定义View的总结，动画系列 直播，视频播放技术要点总结 设计模式 内存优化 gradle精通 简单了解下逆向，反编译等技术 2018，让我们一起加油~]]></content>
      <categories>
        <category>感悟</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ExoPlayer视频框架：自定义UI界面及源码解析]]></title>
    <url>%2FExoPlayer%E8%A7%86%E9%A2%91%E6%A1%86%E6%9E%B6%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89UI%E7%95%8C%E9%9D%A2%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.html</url>
    <content type="text"><![CDATA[版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起. 本文主要讲述使用ExoPlayer框架时如何自定义自己的视频播放界面，来达到满意的效果，以及SimpleExoPlayerView的源码解析 SimpleExoPlayerView 类介绍SimpleExoPlayerView是一个自定义FrameLayout,内部封装了视频，字幕，播放封面，播放控制器的View逻辑 简单使用在xml中声明该控件：123456&lt;com.google.android.exoplayer2.ui.SimpleExoPlayerView android:layout_width="match_parent" android:layout_height="wrap_content" android:id="@+id/simpleExoPlayerView" app:resize_mode="fixed_width" /&gt; SimpleExoPlayerView内部的AspectRatioFrameLayout封装了视频宽高比的计算，它根据视频流的宽高比来动态设置控件的宽高来达到适应屏幕的目的，resize_mode可以指定这种视频的宽高比计算模式，共有四种模式，fixed_width代表根据宽度来动态计算高度，宽度不会变化，fixed_height与之相反，fill模式会忽略宽高比，不进行动态计算，fit为默认模式，如果高度变形就动态计算高度来适配，宽度变形就动态计算宽度来适配。activity中：1simpleExoPlayerView.setPlayer(player); 通过setPlayer方法来与ExoPlayer绑定 源码分析要随心所欲的使用该View，来定制自己理想的UI，就得先了解其中的原理，方能全面掌控，下面我们就来撸一遍源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161@TargetApi(16)public final class SimpleExoPlayerView extends FrameLayout &#123; private static final int SURFACE_TYPE_NONE = 0; private static final int SURFACE_TYPE_SURFACE_VIEW = 1; private static final int SURFACE_TYPE_TEXTURE_VIEW = 2; private final AspectRatioFrameLayout contentFrame; private final View shutterView; private final View surfaceView; private final ImageView artworkView; private final SubtitleView subtitleView; private final PlaybackControlView controller; private final ComponentListener componentListener; private final FrameLayout overlayFrameLayout; private SimpleExoPlayer player; private boolean useController; private boolean useArtwork; private Bitmap defaultArtwork; private int controllerShowTimeoutMs; private boolean controllerAutoShow; private boolean controllerHideOnTouch; public SimpleExoPlayerView(Context context) &#123; this(context, null); &#125; public SimpleExoPlayerView(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public SimpleExoPlayerView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); if (isInEditMode()) &#123; contentFrame = null; shutterView = null; surfaceView = null; artworkView = null; subtitleView = null; controller = null; componentListener = null; overlayFrameLayout = null; ImageView logo = new ImageView(context); if (Util.SDK_INT &gt;= 23) &#123; configureEditModeLogoV23(getResources(), logo); &#125; else &#123; configureEditModeLogo(getResources(), logo); &#125; addView(logo); return; &#125; boolean shutterColorSet = false; int shutterColor = 0; int playerLayoutId = R.layout.exo_simple_player_view; boolean useArtwork = true; int defaultArtworkId = 0; boolean useController = true; int surfaceType = SURFACE_TYPE_SURFACE_VIEW; int resizeMode = AspectRatioFrameLayout.RESIZE_MODE_FIT; int controllerShowTimeoutMs = PlaybackControlView.DEFAULT_SHOW_TIMEOUT_MS; boolean controllerHideOnTouch = true; boolean controllerAutoShow = true; if (attrs != null) &#123; TypedArray a = context.getTheme().obtainStyledAttributes(attrs, R.styleable.SimpleExoPlayerView, 0, 0); try &#123; shutterColorSet = a.hasValue(R.styleable.SimpleExoPlayerView_shutter_background_color); shutterColor = a.getColor(R.styleable.SimpleExoPlayerView_shutter_background_color, shutterColor); playerLayoutId = a.getResourceId(R.styleable.SimpleExoPlayerView_player_layout_id, playerLayoutId); useArtwork = a.getBoolean(R.styleable.SimpleExoPlayerView_use_artwork, useArtwork); defaultArtworkId = a.getResourceId(R.styleable.SimpleExoPlayerView_default_artwork, defaultArtworkId); useController = a.getBoolean(R.styleable.SimpleExoPlayerView_use_controller, useController); surfaceType = a.getInt(R.styleable.SimpleExoPlayerView_surface_type, surfaceType); resizeMode = a.getInt(R.styleable.SimpleExoPlayerView_resize_mode, resizeMode); controllerShowTimeoutMs = a.getInt(R.styleable.SimpleExoPlayerView_show_timeout, controllerShowTimeoutMs); controllerHideOnTouch = a.getBoolean(R.styleable.SimpleExoPlayerView_hide_on_touch, controllerHideOnTouch); controllerAutoShow = a.getBoolean(R.styleable.SimpleExoPlayerView_auto_show, controllerAutoShow); &#125; finally &#123; a.recycle(); &#125; &#125; LayoutInflater.from(context).inflate(playerLayoutId, this); componentListener = new ComponentListener(); setDescendantFocusability(FOCUS_AFTER_DESCENDANTS); // Content frame. contentFrame = findViewById(R.id.exo_content_frame); if (contentFrame != null) &#123; setResizeModeRaw(contentFrame, resizeMode); &#125; // Shutter view. shutterView = findViewById(R.id.exo_shutter); if (shutterView != null &amp;&amp; shutterColorSet) &#123; shutterView.setBackgroundColor(shutterColor); &#125; // Create a surface view and insert it into the content frame, if there is one. if (contentFrame != null &amp;&amp; surfaceType != SURFACE_TYPE_NONE) &#123; ViewGroup.LayoutParams params = new ViewGroup.LayoutParams( ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT); surfaceView = surfaceType == SURFACE_TYPE_TEXTURE_VIEW ? new TextureView(context) : new SurfaceView(context); surfaceView.setLayoutParams(params); contentFrame.addView(surfaceView, 0); &#125; else &#123; surfaceView = null; &#125; // Overlay frame layout. overlayFrameLayout = findViewById(R.id.exo_overlay); // Artwork view. artworkView = findViewById(R.id.exo_artwork); this.useArtwork = useArtwork &amp;&amp; artworkView != null; if (defaultArtworkId != 0) &#123; defaultArtwork = BitmapFactory.decodeResource(context.getResources(), defaultArtworkId); &#125; // Subtitle view. subtitleView = findViewById(R.id.exo_subtitles); if (subtitleView != null) &#123; subtitleView.setUserDefaultStyle(); subtitleView.setUserDefaultTextSize(); &#125; // Playback control view. PlaybackControlView customController = findViewById(R.id.exo_controller); View controllerPlaceholder = findViewById(R.id.exo_controller_placeholder); if (customController != null) &#123; this.controller = customController; &#125; else if (controllerPlaceholder != null) &#123; // Propagate attrs as playbackAttrs so that PlaybackControlView's custom attributes are // transferred, but standard FrameLayout attributes (e.g. background) are not. this.controller = new PlaybackControlView(context, null, 0, attrs); controller.setLayoutParams(controllerPlaceholder.getLayoutParams()); ViewGroup parent = ((ViewGroup) controllerPlaceholder.getParent()); int controllerIndex = parent.indexOfChild(controllerPlaceholder); parent.removeView(controllerPlaceholder); parent.addView(controller, controllerIndex); &#125; else &#123; this.controller = null; &#125; this.controllerShowTimeoutMs = controller != null ? controllerShowTimeoutMs : 0; this.controllerHideOnTouch = controllerHideOnTouch; this.controllerAutoShow = controllerAutoShow; this.useController = useController &amp;&amp; controller != null; hideController(); &#125; 以下是一些暴露的方法 ....... &#125; 我们看下它的构造方法，首先通过isInEditMode()方法判断了是否是在可视化编辑器中加载的，是的话就return。 接下来声明了一些默认的变量，并赋予了一些默认的值，我们看到有一个playerLayoutId声明了一个默认的布局文件exo_simple_player_view，跟踪去看下：1234567891011121314151617181920212223242526272829303132333435&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;merge xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;com.google.android.exoplayer2.ui.AspectRatioFrameLayout android:id="@id/exo_content_frame" android:layout_width="match_parent" android:layout_height="match_parent" android:layout_gravity="center"&gt; &lt;!-- Video surface will be inserted as the first child of the content frame. --&gt; &lt;View android:id="@id/exo_shutter" android:layout_width="match_parent" android:layout_height="match_parent" android:background="@android:color/black"/&gt; &lt;ImageView android:id="@id/exo_artwork" android:layout_width="match_parent" android:layout_height="match_parent" android:scaleType="fitXY"/&gt; &lt;com.google.android.exoplayer2.ui.SubtitleView android:id="@id/exo_subtitles" android:layout_width="match_parent" android:layout_height="match_parent"/&gt; &lt;/com.google.android.exoplayer2.ui.AspectRatioFrameLayout&gt; &lt;FrameLayout android:id="@id/exo_overlay" android:layout_width="match_parent" android:layout_height="match_parent"/&gt; &lt;View android:id="@id/exo_controller_placeholder" android:layout_width="match_parent" android:layout_height="match_parent"/&gt;&lt;/merge&gt; 这个布局文件就是我们的ExoPlayer ui包中的默认ui布局。AspectRatioFrameLayout是继承自FragmeLayout,也就是源码中的contentFrame，它的作用是根据视频的宽高比和屏幕的宽高比来动态计算视频View的宽高比例。而SimpleExoPlayerView会将surfaceView动态插入到AspectRatioFrameLayout的第一个子View中来，来作为播放的View. exo_shutter也就是源码中的shutterView，它的背景可以通过代码动态设置，可以作为视频的一个蒙层. exo_artwork为源码中的artworkView，是一个ImageView,可以放一些图片上去. SubtitleView是一个字幕显示器，为源码中的subtitleView，可以定制字幕文件。 exo_overlay为源码中的overlayFrameLayout，在源码中没有定制任何东西，可以根据需求放入一些逻辑。 exo_controller_placeholder为源码中的controllerPlaceholder，定义了PlaybackControlView的布局属性，在代码中SimpleExoPlayer会将controllerPlaceholder的Param属性添加到PlaybackControlView上。PlaybackControlView是一个播放控制器View.内部封装了播放器控制逻辑，也可以定制自定义ui和实现自己的控制逻辑。 介绍了这么多，接下来继续分析源码LayoutInflater.from(context).inflate(playerLayoutId, this);可以看到，SimpleExoPlayerView将playerLayoutId添加进了该视图，因此，我们可以通过xml的属性来指定该View的视图id，接着声明了该焦点模式为只有当子View不需要焦点时才获取焦点。setDescendantFocusability(FOCUS_AFTER_DESCENDANTS);接下来通过findViewById的模式得到视图的控件来进行不同的设置，因此，如果我们自定义的ui中想用到里面的功能，就必须申明一样的id.也可以通过findViewById的方式得到该控件。接下来继续走： 1234567891011// Create a surface view and insert it into the content frame, if there is one. if (contentFrame != null &amp;&amp; surfaceType != SURFACE_TYPE_NONE) &#123; ViewGroup.LayoutParams params = new ViewGroup.LayoutParams( ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT); surfaceView = surfaceType == SURFACE_TYPE_TEXTURE_VIEW ? new TextureView(context) : new SurfaceView(context); surfaceView.setLayoutParams(params); contentFrame.addView(surfaceView, 0); &#125; else &#123; surfaceView = null; &#125; 可以看到，SimpleExoPlayerView根据sufaceType自动创建一个SufaceView或TextureView,并将其添加到AspectRatioFrameLayout的第一个子View上，用来播放视频。因此如果自定义UI，一定要定义一个AspectRatioFrameLayout来包裹该View.接着我们看一下控制器的逻辑：1234567891011121314151617// Playback control view. PlaybackControlView customController = findViewById(R.id.exo_controller); View controllerPlaceholder = findViewById(R.id.exo_controller_placeholder); if (customController != null) &#123; this.controller = customController; &#125; else if (controllerPlaceholder != null) &#123; // Propagate attrs as playbackAttrs so that PlaybackControlView's custom attributes are // transferred, but standard FrameLayout attributes (e.g. background) are not. this.controller = new PlaybackControlView(context, null, 0, attrs); controller.setLayoutParams(controllerPlaceholder.getLayoutParams()); ViewGroup parent = ((ViewGroup) controllerPlaceholder.getParent()); int controllerIndex = parent.indexOfChild(controllerPlaceholder); parent.removeView(controllerPlaceholder); parent.addView(controller, controllerIndex); &#125; else &#123; this.controller = null; &#125; 可以看到PlaybackControlView也是通过找id的方式获取，因此我们需要定制控制器ui的话可以通过继承PlaybackControlView的方式来定制我们自己的控制UI。如果我们没有定义PlaybackControlView，那么会先创建一个PlaybackControlView，然后去取exo_controller_placeholder的param属性赋给PlaybackControlView，如果没有的话，那么不会申明一个控制器。 UI定制以上通过源码分析，相信对该控件也有个大概的了解了，接下来看看如何定制我们的UI：首先，在xml中我们可以通过controller_layout_id属性申明我们自己的Layout id:1234567&lt;com.google.android.exoplayer2.ui.SimpleExoPlayerView android:layout_width="match_parent" android:layout_height="wrap_content" android:id="@+id/simpleExoPlayerView" app:resize_mode="fixed_width" app:controller_layout_id="@layout/simple_player_view" /&gt; simple_player_view为我自定义布局文件，看一下simple_player_view的代码：12345678910111213&lt;com.google.android.exoplayer2.ui.AspectRatioFrameLayout android:id="@id/exo_content_frame" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_gravity="top"&gt; &lt;com.jie.exoplayerdemo.PlayControlView android:layout_width="match_parent" android:layout_height="wrap_content" android:id="@id/exo_controller" android:layout_gravity="bottom" app:controller_layout_id="@layout/exo_playback_control_view" /&gt;&lt;/com.google.android.exoplayer2.ui.AspectRatioFrameLayout&gt; 该布局只要id与源码中对应即可随意定制，我在里面只是申明了一个AspectRatioFrameLayout和一个自定义的控制器，如果我们不想用该框架的默认控制器PlaybackControlView，可以自定义该控制器，控制器的自定义逻辑和SimpleExoPlayerView一样，也是通过申明id的方式来控制View的逻辑，并且该View不是final类，因此可以继承PlaybackControlView来实现自己的逻辑。PlayControlView就是继承PlaybackControlView来实现的自定义逻辑，我们可以直接通过找id的方式来获取PlaybackControlView里的控件，因此，里面的所有控件是可定制的。可是，我们的SimpleExoPlayerView是一个final类，如果需要实现SimpleExoPlayerView没有的功能，我们需要将SimpleExoPlayerView的代码复制一份出来来达到修改的目的。]]></content>
      <categories>
        <category>Android视频播放</category>
      </categories>
      <tags>
        <tag>ExoPlayer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高效资源搜罗合集，不看保证后悔(持续更新)]]></title>
    <url>%2FEfficientresourcessearchtogethernoguaranteeofregret.html</url>
    <content type="text"><![CDATA[版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起. 恭喜你发现了这篇博文，看了这篇博文，jay帮你打开新世界的大门，多年老司机开车，请系好安全带。 搜索篇(什么？说起搜索你只知道baidu?那你就out了) 快搜：http://search.chongbuluo.com/ 看图就知道，各种资源应有尽有，只有你想不到，没有你搜不到，强烈推荐 西林街搜索：http://www.xilinjie.com/ 各种电影资源,考试资料，都有，搜索比较精准，推荐 WolframAlpha :http://www.wolframalpha.com/国外网站，就不放图了，可以在线解答问题，不管是数学，历史，生活，等等，都能帮你回答 StackExchange： https://stackexchange.com/国外的’知乎’,里面的问题和回答的质量很高，英语好的可以经常逛逛 Github：http://www.github.com/全球最大代码托管平台，没有程序员不知道的吧，在这里你可以找到各种开源项目和共享资源，比如谷歌镜像，host地址分享等 种子搜索类(实在太多，随便列几个) BTZO :http://www.btzo.net/电影资源挺丰富的，各种vip电影都有 胖次搜索 ：http://www.panc.cc/ 界面相当可爱有木有，当然资源也是相当多的 网盘搜索 网盘搜 ：http://www.wangpansou.com/你是不是经常遇到想要的资源百度链接又失效了，不要害怕，使用了网盘搜，全网资源一网打尽，再也不需要等待别人分享资源了。 图片类（设计师福利）Everypixel : https://everypixel.com/国外图片搜索类网站 图虫网 https://tuchong.com/ 摄影爱好者必备 Pixabay : https://pixabay.com/ 嗯，免费高清图片！！！！ Pexels : https://www.pexels.com/国外网站，素材很多而且免费。 500PX：https://500px.com/ 号称最出色的摄影专区，嗯，值得一试 还有几个找icon的网站：iconFont http://www.iconfont.cn/阿里矢量图库，里面有许多app的图片资源和icon，并且提供svg和图标颜色转换，我平时仿写app就是用的它来找icon的 easyicon :http://www.easyicon.net/iconsearch/See/一个icon图标搜索网站 此外，还有百度的百度识图也不错，有时候找到了一张非高清的图可以通过它找到高清的图：http://image.baidu.com/?fr=shitu 影视类（高清电影在线观看）推荐几个在线观看电影的网站，没有广告哦,当然，这种网站现在很多，毕竟流量很大yy6080 ：http://www.yy6080.org/,类似还有80s(老牌电影网站),人人影视，天天美剧,1905电影网，BT天堂，童话村，这里就不贴地址了，百度就能找到 音乐类（high到停不下来）强烈安利一款听歌神器：listen1 :http://listen1.github.io/listen1/这是一款谷歌浏览器插件，当你想听某一首有版权的歌，QQ音乐有这首歌的版权，而网易云没有，而你使用的是网易云，而你又想听这首歌，这个时候你就不得不使用QQ音乐播放器，是不是很闹心，这个插件的作用就是集结了三大主流平台的音乐，让你免去切播放器的烦恼，从此一次性可以听3个音乐平台的歌了。 5Sing : http://5sing.kugou.com/index.html它是一个原创音乐基地，有许多的原创和翻唱伴奏歌曲。 软件工具类（谁用谁知道）手机app:藏书库 : http://www.geeboo.com/ 藏书馆，是读书爱好者在移动互联网空间里的专属私人图书馆，它通过共享借阅的模式，实现了书友间海量书籍的线上互借。 网易蜗牛读书：http://du.163.com/全网每天有1小时的免费读书时间，比较有特色 网站：TinyPNG:https://tinypng.com/这是一款可以在线压缩图片的网站，压缩后图片质量还挺好的，本人一直在用 135编辑器：http://www.135editor.com/如果你正在运营一个公众号，那么在公众号里写文章就可以使用这个网站，里面的公众号模板和排版个人一直很喜欢 另外，安利一个淘软件的神器网站：52破解论坛:https://www.52pojie.cn/里面汇聚360，腾讯，阿里等安全大牛，每天都有原创破解软件发布，惊喜多多哦~~ 资源暂时分享到这，后期还会持续更新，码字不易，如果觉得对你有帮助，不如点击下方赞赏按钮请我喝杯咖啡，另外，你可以按下Ctrl+D收藏该网址或者分享给好友，防止下次找不到了哦~~]]></content>
      <categories>
        <category>资源整合</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一看就懂的自定义顶部粘性下拉控件TouchPullView全面剖析]]></title>
    <url>%2F%E4%B8%80%E7%9C%8B%E5%B0%B1%E6%87%82%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E9%A1%B6%E9%83%A8%E7%B2%98%E6%80%A7%E4%B8%8B%E6%8B%89%E6%8E%A7%E4%BB%B6TouchPullView%E5%85%A8%E9%9D%A2%E5%89%96%E6%9E%90.html</url>
    <content type="text"><![CDATA[版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起. 昨天在慕课上看到了一个自定义粘性头部的实现，发现现在有许多的app都有这个效果，于是跟着慕课上得视频敲了一遍。因为慕课上的老师对于后半部分的坐标运算讲的并不是很细致，因此我自己分析了一下源代码，总结了这篇博客，希望对同学们有所帮助。 慕课视频地址：https://www.imooc.com/learn/830源码下载地址：https://github.com/Jay-huangjie/TouchPullView建议大家先下载源码再来观看 用到的知识点我们先来复习一下需要用到的数学知识点 三角函数： sin = a/c; cos = b/c; tan = a/b; 贝塞尔曲线： 阅读本文需要了解自定义View的基本流程和贝塞尔曲线的绘制。 好，进入正题，我们先看一下它的运行效果： emmmmm,效果感觉还不错~ 实现原理既然是拖动，肯定是基于Touch事件来实现的，通过Touch的Y坐标获取到拖动进度progress,然后通过requestLayout方法不断重绘界面，在onSizeChanged方法中通过计算不断移动圆心坐标，圆的左右两边是经典的贝塞尔曲线，只要获取到控制点和结束点的坐标就能绘制出来，通过控制点的不断移动和onDraw方法中的画布的不断移动来达到弹性和顶部两个起始点向中心靠拢的效果，中间的圆心与旁边的间距部分则是使用的drawable的Bounds效果,回弹则是利用的属性动画的addUpdateListener接口将progress数值由大到小执行回去从而达到的回弹效果 具体分析光看原理肯定是四脸蒙蔽，还是结合代码分析才能达到事半功倍的效果。我们先看OnTouch部分的代码：123456789101112131415161718192021222324252627findViewById(R.id.ll_mainLayout).setOnTouchListener(new View.OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; int actionMasked = event.getActionMasked(); switch (actionMasked) &#123; case MotionEvent.ACTION_DOWN: mTouchStartY = event.getY(); return true; case MotionEvent.ACTION_MOVE: float y = event.getY(); if (y &gt;= mTouchStartY) &#123; //表示向下移动 float moveSize = y - mTouchStartY; float progress = moveSize &gt; TOUCH_MOVE_MAX_Y ? 1 : moveSize / TOUCH_MOVE_MAX_Y; //计算进度值 touchView.setProgress(progress); return true; &#125; break; case MotionEvent.ACTION_UP: touchView.release(); return true; default: break; &#125; return false; &#125; &#125;); 这里还是比较简单，通过getY获取滑动的距离，按下去有一个点，滑动后有一个点，两点之间的距离就是我们的moveSize了，由于progress是指当前滑动的进度值，取值肯定是在0~1之间，因此，当moveSize大于我们预设的最大值时，progress就返回1，否则就返回具体的进度值，最后在设置给touchView，touchView就会进行重绘。 再来看下TouchPullView里面的代码：我们先看一下变量：1234567891011121314private Paint mCirclePaint = new Paint(Paint.ANTI_ALIAS_FLAG); private float mCircleRadius = 50; //圆的半径 private float mCirclePointX, mCirclePointY; //圆心坐标 private int mDargHeight = 400; //最大可下拉的高度 private float mProgress; //下拉进度值 private int mTargetWidth = 400; //目标宽度 private Path mPath = new Path(); //贝塞尔路径 private Paint mPathPaint = new Paint(Paint.ANTI_ALIAS_FLAG); //贝塞尔画笔 private int mTargetGravityHeight = 10; //重心点最终高度，决定控制点的Y坐标 private int mTargetAngle = 105; //角度变换 0~135 private Interpolator mProgessInterpolator = new DecelerateInterpolator(); //一个由快到慢的插值器 private Interpolator mTanentAngleInterpolator; private Drawable content = null; //中心圆drawable private int mContentDrawableMargin = 0; //中心圆Drawable边距 大部分变量都简洁明了，mTargetGravityHeight规定了控制点上下浮动的最大距离，该值越大，控制点越往下移，mTargetAngle规定了结束点与圆心连线的那个角度的最大变幻值，因为不规定可以看到结束点会围绕圆心做圆环运动，最终导致变形，这不是我们希望看到的。mTargetWidth则规定了该控件能缩小的最小宽度。 接下来看onDraw()方法的实现：12345678910111213141516171819202122@Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); //基础坐标系改变 int count = canvas.save(); //获取平移画布的X的值,随着下滑起始点的坐标移动 final float transX = (getWidth() - getValueByLine(getWidth(), mTargetWidth, mProgress)) / 2; canvas.translate(transX, 0); //绘制贝塞尔 canvas.drawPath(mPath, mPathPaint); //画圆 canvas.drawCircle(mCirclePointX, mCirclePointY, mCircleRadius, mCirclePaint); //绘制Drawable Drawable drawable = content; if (drawable != null) &#123; canvas.save(); canvas.clipRect(drawable.getBounds()); drawable.draw(canvas); canvas.restore(); &#125; canvas.restoreToCount(count); &#125; getValueByLine方法的作用是获取某一时刻贝塞尔曲线上的点的坐标，看一下它的方法实现：1234567891011/** * 获取某一时刻的值 * * @param star 起始点 * @param end 结束点 * @param mProgress 当前进度值 * @return */ private float getValueByLine(float star, float end, float mProgress) &#123; return star + (end - star) * mProgress; &#125; 它就是一个贝塞尔曲线公式Bt = P0+(P1-P0)*t，传入初始坐标P0和结束坐标P1和时间t，就能获取到Bt了。接着它得到了一个transX,它等于起始点与屏幕左右的距离，通过画布的移动来实现起始点不断靠拢的效果，接下来是绘制贝塞尔曲线，画圆，根据Bounds大小添加Drawable到画布上。 接下来分析我们的重点：onSizeChanged中的实现,关键是这个方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** * 更新路径 */ private void updatePathLayout() &#123; final float progress = mProgessInterpolator.getInterpolation(mProgress); //获取所有的可绘制的宽/高 此值会根据progress不断的变化 final float w = getValueByLine(getWidth(), mTargetWidth, mProgress); final float h = getValueByLine(0, mDargHeight, mProgress); //圆心X坐标 final float cPointX = w / 2; //半径 final float cRadius = mCircleRadius; //圆心Y坐标 final float cPaintY = h - cRadius; //控制点结束Y的值 final float endPointY = mTargetGravityHeight; //更新圆心坐标 mCirclePointX = cPointX; mCirclePointY = cPaintY; final Path path = mPath; path.reset(); //重置 path.moveTo(0, 0); //坐标系是以最左边的起始点为原点 float lEndPointX, lEndPointY; //结束点的X,Y坐标 float lControlPointX, lControlPointY; //控制点的X，Y坐标 //获取当前切线的弧度 double angle = mTanentAngleInterpolator.getInterpolation(progress) * mTargetAngle;//获取当前的角度 double radian = Math.toRadians(angle); //获取当前弧度 float x = (float) (Math.sin(radian) * cRadius); //求出“股”的长度（长的那条直角边） float y = (float) (Math.cos(radian) * cRadius); //求出“勾”的长度（短的那条直角边） lEndPointX = cPointX - x; //以起始点为原点，x坐标就等于圆的X坐标减去股的长度 lEndPointY = cPaintY + y; //以起始点为原点，y坐标就等于圆的y坐标加上勾的长度 lControlPointY = getValueByLine(0, endPointY, progress);//获取控制点的Y坐标 float tHeight = lEndPointY - lControlPointY; //结束点与控制点的Y坐标差值 float tWidth = (float) (tHeight / Math.tan(radian)); //通过计算两个角度是相等的，因此弧度依旧适用 lControlPointX = lEndPointX - tWidth; //结束点的x - ‘勾’ 的长度求出了控制点的X坐标 path.quadTo(lControlPointX, lControlPointY, lEndPointX, lEndPointY); //画左边贝塞尔曲线 path.lineTo(cPointX + (cPointX - lEndPointX), lEndPointY); //左右两个结束点相连 path.quadTo(cPointX + (cPointX - lControlPointX), lControlPointY, w, 0); //画右边贝塞尔曲线 updateContentLayout(cPointX, cPaintY, cRadius); &#125; /** * 测量并设置中心Drawable * * @param cx * @param cy * @param radius */ private void updateContentLayout(float cx, float cy, float radius) &#123; Drawable drawable = content; if (drawable != null) &#123; int margin = mContentDrawableMargin; int l = (int) (cx - radius + margin); int r = (int) (cx + radius - margin); int t = (int) (cy - radius + margin); int b = (int) (cy + radius - margin); drawable.setBounds(l, t, r, b); &#125; &#125; 其中每一行我都备注了注释，要理解其中的计算，就得先上个图： 我们脑海中要有一个清晰的定义，整个坐标系是基于起始点为原点，向右下延伸X，Y轴，左右的贝塞尔曲线是由一支画笔完成,通过lineTo相连接，因此整个曲线呈V字形。接下来看代码：首先求得了progress，这个无需解释，使用加速器只是为了更好的效果。接下来是w和h,这是控件的某一进度下的宽和高，为什么通过getValueByLine方法就能得到呢？请看输入的参数，起始点是getWidth，也就是整个屏幕的宽度，终点是mTargetWidth也就是我们规定的最小宽度，而getValueByLine正好是求得某一时刻的贝塞尔值，因此将progress输入正好求得从整个屏幕运动到最小宽度之间的某一个宽度，高度同理。宽高求出来了那个圆心的坐标也就相应出来了，注意整个圆的大小包含margin值，也就是圆与左右两边的边距也是包含的。因为mTargetGravityHeight是我们设定的控制点下移的高度，因此也就是控制点Y的坐标。因为quadTo方法需要控制点的坐标和结束点的坐标，因此求出这两个点的坐标就大功告成了，接下来就是数学知识了。首先，通过插值器的方法获得了某一时刻的角度，最后通过Math方法得到了弧度,也就是图中b的角度，半径我们是知道的，所以通过sin可以得出图中x的长度，然后通过半径的x坐标减去x的长度就得到了结束点的x坐标。通过cos我们可以得到y的长度,圆心Y的坐标加上y的坐标就得到了结束点y的坐标，lEndPointX，lEndPointY的值也就得到了。因为我们已知控制点上下运行的起始值和最大值，因此我们可以使用getValueByLine获取到当前的y坐标，接下来只需要求出控制点的x坐标就行了,tHeight表示左边这条直角的长直角边，结束点的y坐标已知，控制点的y坐标已知，因此可以求出tHeight。因为平行线间的角度相等，因此a = c，又因为c+d = e+d = 90; 所以c = e；所以a = e;tHeight已知，e已知，所以tWidth的值就能求出来了。所以控制点的x坐标就等于结束点的x坐标减去tWidth。至此所有的坐标都已经求出来了，所以贝塞尔曲线也就能绘制出来了。 接下来还有个测量的过程，逻辑比较简单：12345678910111213141516171819202122232425262728293031323334@Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; int MIN_W = (int) (mCircleRadius * 2 + getPaddingLeft() + getPaddingRight()); //需要的最小宽度 int MIN_H = (int) ((mDargHeight * mProgress + 0.5f) //mDargHeight * mProgress = moveSize(即actionMove.getY - actionDown.getY),+0.5f为四舍五入 + getPaddingBottom() + getPaddingTop()); int widthMeasure = getMeasureSize(widthMeasureSpec, MIN_W); int heightMeasure = getMeasureSize(heightMeasureSpec, MIN_H); setMeasuredDimension(widthMeasure, heightMeasure); &#125; /** * 获取所需要的宽/高的测量结果 * * @param Spec 测量模式 * @param minValue 规定的最小值 * @return 测量结果 */ private int getMeasureSize(int Spec, int minValue) &#123; int result; int mode = MeasureSpec.getMode(Spec); int size = MeasureSpec.getSize(Spec); switch (mode) &#123; case MeasureSpec.AT_MOST: //wrap_content result = Math.min(size, minValue); //取测量值和规定的最小宽度中的最小值 break; case MeasureSpec.EXACTLY: //match_parent or exactly num result = size; break; default: //其余情况取最小值 result = minValue; break; &#125; return result; &#125; 我将视频中的代码做了一下简单的封装，代码中有详细的注释，我这里就不做分析了。 整个分析流程就到这，如果有错误的地方，欢迎指正，Thanks~]]></content>
      <categories>
        <category>Android基础进阶</category>
        <category>安卓特效合集解析</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓View体系-View的工作流程]]></title>
    <url>%2F%E5%AE%89%E5%8D%93View%E4%BD%93%E7%B3%BB-View%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.html</url>
    <content type="text"><![CDATA[自定义View三部曲：onMeasure –&gt; onLayout –&gt;onDraw,本文着重解析前两个方法 onMeasure1234@Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); &#125; 提到这个方法，就必须先了解MeasureSpec这个类，它有一个getMode和getSize方法，用于获取SpecMode和SpecSize,那么这两个参数又是何物呢？请看以下一般自定义View的完整实现：1234567891011121314151617181920@Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(),widthMeasureSpec),getDefaultSize(getSuggestedMinimumHeight(),heightMeasureSpec)); &#125; public static int getDefaultSize(int size,int measureSpec)&#123; int result = size; int SpecMode = MeasureSpec.getMode(measureSpec); int SpecSize = MeasureSpec.getSize(measureSpec); switch (SpecMode)&#123; case MeasureSpec.UNSPECIFIED: result = size; break; case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: result = SpecSize; break; &#125; return result; &#125; 可以看到，SpecMode是指测量的模式，它有三种模式： UNSPECIFIED代表父容器不对View有任何的大小限制，一般用于系统的内部，很少用到 AT_MOST代表父容器指定了一个大小即SpecSize,View的大小不能大于这个值，它对应于LayoutParams中的wrap_content，结合它你就很好理解了 EXACTLY父容器已经检测到了view所需的精确大小，这时的view的最终大小就是SpecSize中的值，它对应于LayoutParam中的match_parent或者具体的数值 而SpecSize是指某种模式下的规格大小。 因此，结合此方法，当view的大小是wrap_content或者是match_parent或者是具体的数值时，都是使用的父容器给子view测量的specsize的值，当父容器对子view没有任何约束时，给view一个所规定的最小值（getSuggestedMinimum…方法获取）,setMeasuredDimension就是用来设置view的测量大小的。MeasureSpec类的值的获取是由父容器的MeasureSpec和自身的LayoutParams来共同确定的，MeasureSpec一旦确定，onMeasure中就可以确定view的测量宽高了。 这里再来讲解一下getSuggestedMinimumWidth这类方法，它的逻辑是这样的：如果View没有设置背景，那么它会返回minWidth设置的值，可以为0，如果view设置了背景，那么它会返回minWidth和背景最小宽度的两者之间的最大值。 一般的自定义View我们主要是着重处理AT_MOST模式的值，需要根据实际的情况来，没有固定的依据，有兴趣的可以看下TextView等控件的源码是怎么处理的。 Activity中View的宽/高获取通过以上分析读者已经知道View的宽高是需要父容器去测量的，因此我们如果在onCreate或者onStar方法中去获取View的宽高发现并不能保证百分百获取到，那么有什么方法能解决这个问题呢，以下有4个方法能解决这个问题： 1.onWindowFocusChanged当Activity的窗口得到焦点或失去焦点都会被调用一次,并且此时View已经初始化完毕，因此此时去获取View的宽高是没问题的1234567@Override public void onWindowFocusChanged(boolean hasFocus) &#123; super.onWindowFocusChanged(hasFocus); if (hasFocus)&#123; int width = view.getMeasuredWidth(); &#125; &#125; 2.view.post(runnable)通过post可以将一个runnable投递到消息队列的尾部，然后等待Looper调用此runnable的时候，view此时也已经初始化好了。123456view.post(new Runnable() &#123; @Override public void run() &#123; int width = view.getMeasuredWidth(); &#125; &#125;); 3.ViewTreeObserver使用ViewTreeObserver这个类的回调可以完成，比如OnGlobalLayoutListener，当View树的状态改变或者内部view的可见性发生改变时，该接口会被回调，注意，此接口会回调多次。12345678final ViewTreeObserver viewTreeObserver = view.getViewTreeObserver(); viewTreeObserver.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() &#123; @Override public void onGlobalLayout() &#123; view.getViewTreeObserver().removeOnGlobalLayoutListener(this); int width = view.getMeasuredWidth(); &#125; &#125;); 4.view.measure(int widthMeasureSpec, int heightMeasureSpec)手动对view进行测量来得出view的宽高，这种实现比较的复杂，需要看view的LayoutParam： match_parent无法得出View的宽/高，因为此种情况需要获取到父容器的剩余空间，而此时我们是获取不到的 具体的数值比如宽/高都是50px,那么我们可以这样写来获取：123int widthMeasureSpec = View.MeasureSpec.makeMeasureSpec(100, View.MeasureSpec.EXACTLY);int heightMeasureSpec = View.MeasureSpec.makeMeasureSpec(100,View.MeasureSpec.EXACTLY);view.measure(widthMeasureSpec,heightMeasureSpec); wrap_content123 int widthMeasureSpec = View.MeasureSpec.makeMeasureSpec((1&lt;&lt;30)-1, View.MeasureSpec.AT_MOST);int heightMeasureSpec = View.MeasureSpec.makeMeasureSpec((1&lt;&lt;30)-1,View.MeasureSpec.AT_MOST); view.measure(widthMeasureSpec,heightMeasureSpec); 注意(1&lt;&lt;30)-1这个值，通过查看源码可以知道View的尺寸是使用的30位二进制表示，所以最大值是30个1（2^30-1），也就等于（1&lt;&lt;30）-1，所以给出这个数值是合理的。 onLayoutonLayout方法是ViewGroup用来给子元素确定位置的，相比如onMeasure方法，onLayout则简单多了：1234@Override protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; super.onLayout(changed, left, top, right, bottom); &#125; 后四个参数分别代表左，上，右，下，只需返回不同的坐标即可确定View的位置。]]></content>
      <categories>
        <category>Android基础进阶</category>
        <category>安卓View体系</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓View体系:View的一些基本知识点]]></title>
    <url>%2F%E5%AE%89%E5%8D%93View%E4%BD%93%E7%B3%BB-View%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E7%82%B9.html</url>
    <content type="text"><![CDATA[安卓开发中熟练使用自定义View是开发者必备的技能，因为安卓原生控件很多时候是不能满足需求的，而自定义控件能做出各种绚丽的效果,用于满足产品各种奇怪的需求(我为什么要用奇怪呢，哈哈哈哈)。 自定义View要掌握的内容自定义View主要是掌握以下五个内容： 绘制原理: 掌握onMeasure,onLayout,onDraw及相关类的使用。 事件传递：掌握dispathTouchEvent(),onInterceptEvent(),onTouchEvent()三者的传递逻辑. 动画：属性动画，用于对View进行动画操作 相关手势：GestureDetector，VelocityTracker等类的应用 滑动：滑动的三种实现方法，Scroller的运用 自定义View的基本知识自定义View的分类1. 直接继承View主要用于实现一些不规则的效果，不能通过现有控件扩展的一些效果 2. 继承自viewGroup主要是为了实现自定义的布局，这个布局里包含了一些特定的控件，很像几个view组合在一起 3.继承特定的view主要是为了扩展已有view的功能，比如TextView等 4.继承特定的ViewGroup为了扩展特定的布局，比如LinearLayout 自定义控件的构造函数建立一个class类继承自View,实现它的所有的构造方法，那么这个类就是一个可以在xml中使用的自定义View，以下是关于它的构造方法的代码：123456789101112131415161718192021222324252627package com.jie.demo_01.View;import android.content.Context;import android.support.annotation.Nullable;import android.util.AttributeSet;import android.view.View;public class mView extends View &#123; public mView(Context context) &#123; //在代码中直接new出这个实例会调用这个方法 super(context); &#125; public mView(Context context, @Nullable AttributeSet attrs) &#123; //在xml中实现会调用这个方法（未指定style） super(context, attrs); &#125; public mView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; //为view指定了一个style super(context, attrs, defStyleAttr); &#125; public mView(Context context, @Nullable AttributeSet attrs, int defStyleAttr, int defStyleRes) &#123; //api&gt;21时调用，一般不用实现 super(context, attrs, defStyleAttr, defStyleRes); &#125;&#125; 关于构造函数中参数的含义： AttributeSet set: 属性值的集合. int[] attrs: 我们自定义属性集合在R类中生成的int型数组.这个数组中包含了自定义属性的资源ID. int defStyleAttr: 这是当前Theme中的包含的一个指向style的引用.当我们没有给自定义View设置declare-styleable资源集合时,默认从这个集合里面查找布局文件中配置属性值.传入0表示不向该defStyleAttr中查找默认值. int defStyleRes: 这个也是一个指向Style的资源ID,但是仅在defStyleAttr为0或者defStyleAttr不为0但Theme中没有为defStyleAttr属性赋值时起作用. 属性赋值优先级次序表:在布局xml中直接定义 &gt; 在布局xml中通过style定义 &gt; 自定义View所在的Activity的Theme中指定style引用 &gt; 构造函数中defStyleRes指定的默认值 自定义view的xml赋值我们经常可以看到使用xml的属性可以为view进行各种赋值,那么是怎么做到的呢，如图，在values目录下新建一个attrs.xml的文件，文件内容如下：12345&lt;resources&gt; &lt;declare-styleable name="mView"&gt; &lt;attr name="mview_color" format="color"/&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 我在这里声明了一个mview_color属性，用于定义颜色值，format代表属性的格式，有许多，读者查阅文档即可了解。 接下来,我在View中做如下处理：123456789101112131415161718public class mView extends View &#123; int defultColor = 0xFFFFFF6; int mColor; public mView(Context context) &#123; this(context,null); &#125; public mView(Context context, @Nullable AttributeSet attrs) &#123; this(context, attrs,0); &#125; public mView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); TypedArray t = context.obtainStyledAttributes(attrs, R.styleable.mView); mColor = t.getColor(R.styleable.mView_mview_color,defultColor); t.recycle(); //记得回收 &#125;&#125; 使用TypedArray来解析我们定义的属性,接着就赋值给我们的变量，最后回收，这样解析工作就完成了 接下来我们在xml中使用我们的View:123456789101112131415&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" //为了使用自定义属性，必须作此声明，app可以换成其他的名字 xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context="com.jie.demo_01.MainActivity"&gt; &lt;com.jie.demo_01.View.mView android:layout_width="match_parent" android:layout_height="100dp" app:mview_color="@color/colorAccent" //声明我们的自定义属性 /&gt;&lt;/LinearLayout&gt; 自定义view的绘制属性已经定义好了，接下来就是如何使用了，在这里我们重写它的onDraw方法：123456789101112131415161718192021222324252627282930public class mView extends View &#123; int defultColor = 0xFFFFFF6; int mColor; private Paint mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); public mView(Context context) &#123; this(context,null); &#125; public mView(Context context, @Nullable AttributeSet attrs) &#123; this(context, attrs,0); &#125; public mView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); TypedArray t = context.obtainStyledAttributes(attrs, R.styleable.mView); mColor = t.getColor(R.styleable.mView_mview_color,defultColor); t.recycle(); //记得回收 init(); &#125; private void init() &#123; mPaint.setColor(mColor); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawCircle(200,200,100,mPaint); //绘制一个位于200，200处的半径为100的圆 &#125;&#125; onDraw方法是view绘制图形图像的地方，通过画布（canvas）和画笔（paint）来灵活的绘制各种图形，这两个类所包含的方法多而全，读者可以多阅读文档来练习绘制各种图形,代码运行如图所示： 自定义View的注意事项上面的自定义view并不是一个标准的自定义view,标准的自定义view还应该包含onMeasure和onLayout的处理，让其支持wrap_content。 这里要注意了： 直接继承view或者viewgroup的控件不支持wrap_content,需要在onMeasure中进行特殊的处理才能达到预期的效果 如果有必要的话，需要在draw方法中处理padding，使view控件的padding生效，否则padding是无效的 尽量不在view中使用handler,因为view本身自带了post方法 如果在view中有线程或者动画，要及时关闭，关闭的时机是onDetachedFromWindow方法，当包含此view的Activity退出或者view被remove掉时，此方法会被调用 不要再onDraw方法中作初始化操作，因为这个方法会绘制多次，会产生很多不必要的开销 当View有滑动嵌套的情况，要处理好滑动冲突]]></content>
      <categories>
        <category>Android基础进阶</category>
        <category>安卓View体系</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓IPC机制:AIDL通信的使用和理解]]></title>
    <url>%2F%E5%AE%89%E5%8D%93IPC%E6%9C%BA%E5%88%B6-AIDL%E9%80%9A%E4%BF%A1%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E7%90%86%E8%A7%A3.html</url>
    <content type="text"><![CDATA[使用情景虽然Messenger对AIDL做了封装使其变得更易用，但Messenger只能一个一个的处理接收的数据,当有大量并发的数据涌入时，Messenger就显得不那么合适了,并且Messenger只能用来传递消息，如果需要调用跨进程的方法怎么办呢，这是，AIDL就派上用场了。 使用方法首先创建一个AIDL文件,在里面声明一些需要用到的方法接口，注意，并不是所有的数据类型在AIDL中都能使用，AIDL能够使用的数据类型如下: 基本数据类型 String,CharSequence ArrayList,里面包含的元素必须支持AIDL HashMap,里面包含的key和value必须被AIDL支持 Parcelable,所有实现了Parcelable接口的对象 AIDL接口本身也支持 123456789// IBookManager.aidlpackage com.jie.demo_01;import com.jie.demo_01.Book;// Declare any non-default types here with import statementsinterface IBookManager &#123; List&lt;Book&gt; getBookList(); void addBook(in Book book);&#125; 可以看到，我在里面引入了Book实体类，按照AIDL的规则，是需要再创建一个Book.aidl文件的，并且需要手动将引入路径导入123// Book.aidl.aidlpackage com.jie.demo_01;parcelable Book; 需要注意的是，AIDL中每个实现了Parcelable接口的类都需要按照这种方式创建相应的文件并且申明该类为Parcelable，并且，AIDL中除了基本数据类型，其他的参数都必须标上方向： in 表示输入型的参数 out 表示输出型的参数 inout 表示输入输出型参数并且AIDL不支持声明静态变量。 下面是远程服务端的实现:123456789101112131415161718192021222324252627282930313233343536373839404142package com.jie.demo_01;import android.app.Service;import android.content.Intent;import android.os.Binder;import android.os.IBinder;import android.os.RemoteException;import android.support.annotation.Nullable;import java.util.List;import java.util.concurrent.CopyOnWriteArrayList;public class mService extends Service &#123; private CopyOnWriteArrayList&lt;Book&gt; mBookList = new CopyOnWriteArrayList&lt;&gt;(); //支持并发读写的一个类，非Arraylist private Binder mbinder = new IBookManager.Stub() &#123; @Override public List&lt;Book&gt; getBookList() throws RemoteException &#123; return mBookList; &#125; @Override public void addBook(Book book) throws RemoteException &#123; mBookList.add(book); &#125; &#125;; @Nullable @Override public IBinder onBind(Intent intent) &#123; return mbinder; &#125; @Override public void onCreate() &#123; super.onCreate(); mBookList.add(new Book(1,"Kotlin实战")); mBookList.add(new Book(2,"编程珠玑")); mBookList.add(new Book(3,"Java数据与结构算法解析")); &#125;&#125; 服务端的实现比较简单，主要是通过IBookManager.Stub来获取Binder对象并实现定义的方法,最后在onBind中绑定`Binder对象,其中，IBookManager这个类是自动生成的，位于gen目录的aidl文件夹中,关于该类稍后再做分析。 以下是客户端的实现,也比较简单:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.jie.demo_01;import android.content.ComponentName;import android.content.Intent;import android.content.ServiceConnection;import android.os.Bundle;import android.os.IBinder;import android.os.RemoteException;import android.support.v7.app.AppCompatActivity;import android.util.Log;import java.util.List;public class MainActivity extends AppCompatActivity &#123; private ServiceConnection mConnection = new ServiceConnection() &#123; //Ibind监听，注意绑定是异步的 @Override public void onServiceConnected(ComponentName componentName, IBinder iBinder) &#123; //当与Service建立连接时调用 IBookManager manager = IBookManager.Stub.asInterface(iBinder); //获取AIDL管理类 //得到数据 try &#123; List&lt;Book&gt; bookList = manager.getBookList(); //这里实际上就是调用了Binder中的方法 Log.i("hj","从服务端获取的集合大小:"+bookList.size()); if (bookList.size()&gt;0)&#123; Log.i("hj","第一个书名是:"+bookList.get(0).bookName); &#125; &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onServiceDisconnected(ComponentName componentName) &#123; //与Service意外中断时调用 &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Intent intent = new Intent(MainActivity.this,mService.class); bindService(intent,mConnection,BIND_AUTO_CREATE); &#125; @Override protected void onDestroy() &#123; unbindService(mConnection); super.onDestroy(); &#125;&#125; 运行后打印如下：1212-09 17:05:46.447 19690-19690/? I/hj: 从服务端获取的集合大小:312-09 17:05:46.448 19690-19690/? I/hj: 第一个书名是:Kotlin实战 运行原理是通过IBookManager.Stub.asInterface方法获取到IBookManager,从而调用里面的方法来实现数据的传递与方法之间的调用，注意，这些方法都是运行在UI线程中的，所以不能有耗时的操作，如果有耗时的操作，应该新开启一个线程来解决。 还有一点需要注意的是，如果有类似于订阅者的实现，在进程通信中，不能简单的用List来管理接口，因为进程中的对象传输后其实变成了两个不同的对象，那么订阅和取消订阅将会失效，因此，系统提供了一个叫RemoteCallbackList的接口专门用来管理跨进程的接口，它的使用也很简单： beginBroadcast()方法会返回该类里所有集合的大小 getBroadcastItem(int position) 返回指定的item finishBroadcast() 结束遍历 通过以上三个方法可以循环遍历订阅者接口来达到取消订阅的目的。注意beginBroadcast和finishBroadcast必须配对使用 IBookManager 类分析通过以上的AIDL实现，我们发现了IBookManager类起到了制关重要的作用,所以我们来深入观察一下该类，理解了该类有助于我们更好的使用AIDL.以下是该类的源码。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133/* * This file is auto-generated. DO NOT MODIFY. * Original file: D:\\MyWork\\Studio_Work\\demo_01\\app\\src\\main\\aidl\\com\\jie\\demo_01\\IBookManager.aidl */package com.jie.demo_01;// Declare any non-default types here with import statementspublic interface IBookManager extends android.os.IInterface &#123; /** * Local-side IPC implementation stub class. */ public static abstract class Stub extends android.os.Binder implements com.jie.demo_01.IBookManager &#123; private static final java.lang.String DESCRIPTOR = "com.jie.demo_01.IBookManager"; /** * Construct the stub at attach it to the interface. */ public Stub() &#123; this.attachInterface(this, DESCRIPTOR); &#125; /** * Cast an IBinder object into an com.jie.demo_01.IBookManager interface, * generating a proxy if needed. */ public static com.jie.demo_01.IBookManager asInterface(android.os.IBinder obj) &#123; if ((obj == null)) &#123; return null; &#125; android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) &amp;&amp; (iin instanceof com.jie.demo_01.IBookManager))) &#123; return ((com.jie.demo_01.IBookManager) iin); &#125; return new com.jie.demo_01.IBookManager.Stub.Proxy(obj); &#125; @Override public android.os.IBinder asBinder() &#123; return this; &#125; @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123; switch (code) &#123; case INTERFACE_TRANSACTION: &#123; reply.writeString(DESCRIPTOR); return true; &#125; case TRANSACTION_getBookList: &#123; data.enforceInterface(DESCRIPTOR); java.util.List&lt;com.jie.demo_01.Book&gt; _result = this.getBookList(); reply.writeNoException(); reply.writeTypedList(_result); return true; &#125; case TRANSACTION_addBook: &#123; data.enforceInterface(DESCRIPTOR); com.jie.demo_01.Book _arg0; if ((0 != data.readInt())) &#123; _arg0 = com.jie.demo_01.Book.CREATOR.createFromParcel(data); &#125; else &#123; _arg0 = null; &#125; this.addBook(_arg0); reply.writeNoException(); return true; &#125; &#125; return super.onTransact(code, data, reply, flags); &#125; private static class Proxy implements com.jie.demo_01.IBookManager &#123; private android.os.IBinder mRemote; Proxy(android.os.IBinder remote) &#123; mRemote = remote; &#125; @Override public android.os.IBinder asBinder() &#123; return mRemote; &#125; public java.lang.String getInterfaceDescriptor() &#123; return DESCRIPTOR; &#125; @Override public java.util.List&lt;com.jie.demo_01.Book&gt; getBookList() throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); java.util.List&lt;com.jie.demo_01.Book&gt; _result; try &#123; _data.writeInterfaceToken(DESCRIPTOR); mRemote.transact(Stub.TRANSACTION_getBookList, _data, _reply, 0); _reply.readException(); _result = _reply.createTypedArrayList(com.jie.demo_01.Book.CREATOR); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; return _result; &#125; @Override public void addBook(com.jie.demo_01.Book book) throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); try &#123; _data.writeInterfaceToken(DESCRIPTOR); if ((book != null)) &#123; _data.writeInt(1); book.writeToParcel(_data, 0); &#125; else &#123; _data.writeInt(0); &#125; mRemote.transact(Stub.TRANSACTION_addBook, _data, _reply, 0); _reply.readException(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; &#125; &#125; static final int TRANSACTION_getBookList = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0); static final int TRANSACTION_addBook = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1); &#125; public java.util.List&lt;com.jie.demo_01.Book&gt; getBookList() throws android.os.RemoteException; public void addBook(com.jie.demo_01.Book book) throws android.os.RemoteException;&#125; 可以看到该类的结构还是比较清晰的,首先，它申明了getBookList和addBook两个方法，显然这是我在aidl接口中申明的方法，接着，还申明了两个int型的id,TRANSACTION_getBookList 和TRANSACTION_addBook，这两个id是为了在transact过程中区分客户端请求的是哪个方法，接着，它申明了一个内部类Stub,它是一个Binder类，接着还申明了一个Stub的内部代理类，以上就是该类的结构。下面详细介绍一下各个方法的作用 首先是Stub 类的方法： asInterface(android.os.IBinder obj)传入一个Binder对象，转换成客户端所需要的AIDL接口类型的对象，这种转换是区分进程的，如果服务端和客户端是在一个进程中，那么该方法会返回Stub对象本身，如果是两个进程，那么会返回Stub.proxy对象。 adBinder返回Binder对象. onTransact（(int code, android.os.Parcel data, android.os.Parcel reply, int flags）该方法是返回一个boolean对象，运行在Binder线程池中，当客户端发起请求，远程会通过系统底层封装后由此方法处理。code参数可以确定客户端请求的方法是什么，data中能取出目标的参数，然后执行目标的方法，当执行完毕后，就向reply中写入返回值（如果有返回值的话），而返回的boolean对象，如果为false,那么客户端会请求失败，因此可以通过这个返回值做权限验证。 Proxy中的方法： getBookList此方法运行在客户端，当客户端远程调用此方法时，它会创建该方法所需要的输入型Parcel对象data,输出型Parcel对象,_reply和返回值对象List,然后将该方法的参数信息写入_data中（如果有参数的话）；接着调用transact方法来发起请求，同时当前线程挂起，然后服务端的onTransatct方法会被调用，直到远程调用返回，当前线程继续执行，并从_reply中取出远程调用过程的返回结果，最后返回_reply数据。 addBook同getBookList一样，因为没有返回值，所以不需要从_reply中取值 整体来说整个类还是易于理解的，大多其实都是偏底层的实现,需要注意的是,客户端通过接口方法发起请求时，当前线程会被挂起直到服务端返回数据，因此，如果一个远程的方法非常耗时，那么就不能在主线程中发起请求，需要另开一个线程。]]></content>
      <categories>
        <category>Android基础进阶</category>
        <category>安卓IPC机制</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓IPC机制:使用Messenger通信]]></title>
    <url>%2F%E5%AE%89%E5%8D%93IPC%E6%9C%BA%E5%88%B6-%E4%BD%BF%E7%94%A8Messenger%E9%80%9A%E4%BF%A1.html</url>
    <content type="text"><![CDATA[Messenger原理Messenger的底层实现是AILD，它是一个Message的载体，通过它可以在不同进程间传递message对象,从而实现数据传递 使用代码示例：首先创建一个Service，让它运行在一个单独的进程中123&lt;service android:name=".mService" android:process=":remote" /&gt; 然后再来看服务端12345678910111213141516171819202122232425262728293031323334public class mService extends Service &#123; private final Messenger messenger = new Messenger(new messengerHandler()); private static class messengerHandler extends Handler &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case Constants.MSG_FROM_CLIENT: String clientMsg = msg.getData().getString("msg"); //接收客户端的消息 Log.i("hj","从客户端接收到的消息:"+clientMsg); Messenger messenger = msg.replyTo; //获取客户端发来的Messenger Message replyMessage = Message.obtain(null,Constants.MSG_FROM_SERVICE); //创建一个新的Message对象 Bundle bundle = new Bundle(); bundle.putString("reply", "已收到客户端的消息，稍后回复~"); replyMessage.setData(bundle); try &#123; messenger.send(replyMessage); //发送消息给客户端 &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; break; default: super.handleMessage(msg); &#125; &#125; &#125; @Nullable @Override public IBinder onBind(Intent intent) &#123; return messenger.getBinder(); &#125;&#125; 创建一个Handler并且传入到Messenger对象中,通过Handler来接收Message对象发来的消息,并且在Service的onBind中返回这个Messager对象底层的Binder。随后我又通过msg.replyTo方法获取到从客户端发来的Messenger对象，用于回复消息给客户端,最后调用send方法发出消息，这样就完成了消息的接收与回复，接下来再看客户端的实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.jie.demo_01;import android.content.ComponentName;import android.content.Intent;import android.content.ServiceConnection;import android.os.Bundle;import android.os.Handler;import android.os.IBinder;import android.os.Message;import android.os.Messenger;import android.os.RemoteException;import android.support.v7.app.AppCompatActivity;import android.util.Log;public class MainActivity extends AppCompatActivity &#123; private Messenger messenger; //客户端发送消息的messenger private ServiceConnection mConnection = new ServiceConnection() &#123; //Ibind监听，注意绑定是异步的 @Override public void onServiceConnected(ComponentName componentName, IBinder iBinder) &#123; //当与Service建立连接时调用 messenger = new Messenger(iBinder); Message message = Message.obtain(null,Constants.MSG_FROM_CLIENT); Bundle bundle = new Bundle(); bundle.putString("msg","Service兄弟在吗，是否已收到回复"); message.setData(bundle); message.replyTo = replyMessager; //注意这一句，将客户端用于接受消息的Messager对象传递给Service try &#123; messenger.send(message); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onServiceDisconnected(ComponentName componentName) &#123; //与Service意外中断时调用 &#125; &#125;; private Messenger replyMessager = new Messenger(new GetReplyMessenger()); //客户端接收消息的messenger private static class GetReplyMessenger extends Handler&#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what)&#123; case Constants.MSG_FROM_SERVICE: String reply = msg.getData().getString("reply"); Log.i("hj","从Service接收到的消息:"+reply); break; default: super.handleMessage(msg); break; &#125; &#125; &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Intent intent = new Intent(MainActivity.this,mService.class); bindService(intent,mConnection,BIND_AUTO_CREATE); &#125; @Override protected void onDestroy() &#123; unbindService(mConnection); super.onDestroy(); &#125;&#125; 首先是绑定一个Service，接下来在绑定监听中创建一个Messager对象,通过Messager就可以发消息给服务端了,注意，我在这里通过replyTo发送了一个新的Messager对象给服务端，这样服务端就可以回复消息给客户端了，客户端也是通过Handler来接收消息的。 运行结果如下：112-09 11:16:07.733 7900-7900/com.jie.demo_01:remote I/hj: 从客户端接收到的消息:Service兄弟在吗，是否已收到回复 112-09 11:16:07.753 7871-7871/com.jie.demo_01 I/hj: 从Service接收到的消息:已收到客户端的消息，稍后回复~ 可以看到两个不同进程之间通信成功了]]></content>
      <categories>
        <category>Android基础进阶</category>
        <category>安卓IPC机制</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓IPC机制：使用文件共享]]></title>
    <url>%2F%E5%AE%89%E5%8D%93IPC%E6%9C%BA%E5%88%B6%EF%BC%9A%E4%BD%BF%E7%94%A8%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB.html</url>
    <content type="text"><![CDATA[原理通过两个进程间读/写同一个文件来交换数据示例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.jie.demo_01;import android.content.Intent;import android.os.Bundle;import android.os.Environment;import android.support.v7.app.AppCompatActivity;import android.view.View;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectOutputStream;public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; @Override protected void onResume() &#123; super.onResume(); initWriteToFile(); &#125; //点击跳转到SecondActivity public void start(View v)&#123; startActivity(new Intent(MainActivity.this,SecondActivity.class)); &#125; private void initWriteToFile()&#123; new Thread()&#123; @Override public void run() &#123; User user = new User(); user.userName = &quot;Hello World&quot;; File file = new File(getDiskCacheDir()); ObjectOutputStream oos = null; try &#123; oos = new ObjectOutputStream(new FileOutputStream(file)); oos.writeObject(user); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; if (oos!=null) oos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;.start(); &#125; public String getDiskCacheDir() &#123; String cachePath = null; if (Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState()) || !Environment.isExternalStorageRemovable()) &#123; cachePath = getExternalCacheDir().getPath()+&quot;/cache.txt&quot;; &#125; else &#123; cachePath = getCacheDir().getPath()+&quot;/cache.txt&quot;; &#125; return cachePath; &#125;&#125; SecondActivity代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.jie.demo_01;import android.os.Bundle;import android.os.Environment;import android.support.v7.app.AppCompatActivity;import android.util.Log;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.ObjectInputStream;public class SecondActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; @Override protected void onResume() &#123; super.onResume(); getCacheFromFile(); &#125; private void getCacheFromFile ()&#123; new Thread()&#123; @Override public void run() &#123; User user = null; File file = new File(getDiskCacheDir()); if (file.exists())&#123; ObjectInputStream ois = null; try &#123; ois = new ObjectInputStream(new FileInputStream(file)); user = (User) ois.readObject(); Log.i(&quot;TAG&quot;,user.userName); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;.start(); &#125; public String getDiskCacheDir() &#123; String cachePath = null; if (Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState()) || !Environment.isExternalStorageRemovable()) &#123; cachePath = getExternalCacheDir().getPath()+&quot;/cache.txt&quot;; &#125; else &#123; cachePath = getCacheDir().getPath()+&quot;/cache.txt&quot;; &#125; return cachePath; &#125;&#125; 运行后，打印出日志：112-08 13:13:30.372 17706-17723/com.jie.demo_01.remote I/TAG: Hello World 文件传值成功 文件传值并没有具体的要求，不管是通过txt,xml,等等都可以，需要注意的是文件的并发问题，要避免获取文件值得时候同时去修改文件，这样会造成数据的混乱。]]></content>
      <categories>
        <category>Android基础进阶</category>
        <category>安卓IPC机制</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓IPC机制：Bundle数据传递]]></title>
    <url>%2F%E5%AE%89%E5%8D%93IPC%E6%9C%BA%E5%88%B6%EF%BC%9ABundle%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92.html</url>
    <content type="text"><![CDATA[序列化与反序列化要实现进程之间的通信，序列化是通信的基础，所以先要了解下什么是序列化安卓实现序列化有两种方式：1. 实现Serializable接口，使用相当简单，这个是JAVA提供的方法，需要注意的是,该接口有一个serialVersionUID参数：1private static final long serialVersionUID = 1L ; 可以选择不实现，依旧可以序列化，但是会对反序列化产生影响，如果在反序列化的过程中类发生了变化，那么将会报错。AndroidStudio默认不检查serialVersionUID的实现，因此，可以手动开启它，这样系统就会自动帮你实现serialVersionUID。开启方法：Settings-&gt;Editor-&gt;Inspections-&gt;serialization issues-&gt;Serializable class without ‘serialVersionUID’ 勾上确认就可以 序列化对象也非常简单，通过ObjectOutputStream和ObjectInputStream即可轻松实现 2.实现Parcelable接口,这是Android提供的方法，实现该接口，系统会自动帮你实现需要的代码，Android中推荐使用该方法，因为效率比Serializable高，Serializable需要进行大量的I/O操作。以下是完整实现实例：1234567891011121314151617181920212223242526272829303132333435363738public class User implements Parcelable &#123; public int userId; public String userName; public boolean isMale; public Book book; protected User(Parcel in) &#123; userId = in.readInt(); userName = in.readString(); isMale = in.readByte() != 0; book = in.readParcelable(Book.class.getClassLoader()); &#125; public static final Creator&lt;User&gt; CREATOR = new Creator&lt;User&gt;() &#123; @Override public User createFromParcel(Parcel in) &#123; return new User(in); &#125; @Override public User[] newArray(int size) &#123; return new User[size]; &#125; &#125;; @Override public int describeContents() &#123; return 0; &#125; @Override public void writeToParcel(Parcel parcel, int i) &#123; parcel.writeInt(userId); parcel.writeString(userName); parcel.writeByte((byte) (isMale ? 1 : 0)); parcel.writeParcelable(book, i); &#125;&#125; 方法详解见下表： 方法 功能 标记位 createFromParce(Parcel in)l 从序列化的对象中创建原始对象 newArray 创建指定长度的原始对象数组 User(Parcel in) 从序列化的对象中创建原始对象 writeToParcel(Parcel parcel, int i) 将当前对象写入序列化结构中,其中 i有两种值，1代表当前对象需要作为返回值返回，不能立即释放资源， PARCELABLE_WRITE_VALUE describeContents 返回当前对象的内容描述，如果含有文件扫描符，返回1（参见右侧标记位），否则返回0 CONTENTS_FILE_DESCRIPTOR 实现了序列化，我们就可以很方便的通过Intent发送Bundle,这是一种简单的进程间通信的方法12345Bundle bundle = new Bundle(); bundle.putParcelable(&quot;User&quot;,new User()); Intent intent = new Intent(MainActivity.this, SecondActivity.class); intent.putExtra(&quot;data&quot;,bundle); startActivity(intent);]]></content>
      <categories>
        <category>Android基础进阶</category>
        <category>安卓IPC机制</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓IPC机制:多进程]]></title>
    <url>%2F%E5%AE%89%E5%8D%93IPC%E6%9C%BA%E5%88%B6-%E5%A4%9A%E8%BF%9B%E7%A8%8B.html</url>
    <content type="text"><![CDATA[什么是IPC IPC是指进程间通信或者跨进程通信，指两个进程之间交换数据的过程。而IPC使用的场景往往是在多进程之间进行通信。 Android开启多进程 通过给Activity指定android:process属性来开启多进程模式,如下示例，123456789101112131415161718192021&lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:roundIcon=&quot;@mipmap/ic_launcher_round&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/AppTheme&quot;&gt; &lt;activity android:name=&quot;.MainActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=&quot;.ThirdActivity&quot; android:process=&quot;:remote&quot; /&gt; &lt;activity android:name=&quot;.SecondActivity&quot; android:process=&quot;com.jie.demo_01.remote&quot; /&gt; &lt;/application&gt; 示例中实现了两种不同的写法，这两种写法是有区别的,当ThirdActivity启动，系统会单独开启一个叫com.jie.demo_01:remote的进程(com.jie.demo_01为包名),当启动SecondActivity,系统会单独开启一个叫com.jie.demo_01.remote的进程，其中，“：”代表要在当前进程名前面加上当前的包名，并且代表此进程为私有进程，其他应用不能和它跑在一个进程中，而没有”：”的为全局进程。SecondActivity的这种写法，是一种完整的命名方式，不会附加包名信息。 开启多进程的一些坑当一个Activity单独开启了一个进程，那么这个Activity就不能和别的进程的Activity共享数据了，只能通过IPC机制来传递数据。 例如我申明了一个静态变量 Userid = 1;我在MainActivity中把它改为了2，我在SecondActivity中开启了一个进程，我获取这个Userid，你会发现Userid还是1，这是因为Android会为每一个进程分配一个虚拟机，不同的虚拟机在内存分配上会有不同的地址空间，所以Userid会在不同的虚拟机上产生不同的副本，并且副本之间是互不干扰的,我在MainActivity中把它改为2，在SecondActivity中的副本是不会变得,可以理解为又新开启了一个应用，所以，一般来说，多进程之间会存在下列一些问题： 静态成员和单例模式无效 线程同步机制失效 SharedPreferences的存储结果变得不再可靠 Application会多次创建 为了解决这些问题，系统引入了IPC机制，用于在进程间共享和传递数据，IPC的方式主要有以下几种： 使用Bundle 使用文件共享 使用Messenger 使用AIDL 其中Messenger底层其实使用的AILD，AIDL其实是依靠Binder,下一章将详细介绍这几种方法。]]></content>
      <categories>
        <category>Android基础进阶</category>
        <category>安卓IPC机制</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity的生命周期和启动模式]]></title>
    <url>%2FActivity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[此系列文章为进阶类文章,快餐类记录文,用于自己安卓知识点的复习 典型情况生命周期 onCreate() :Activity被创建 onRestart() : 正在重新启动。调用场景：当前Activity从不可见到变为可见状态 onStart(): Activity正在启动,此时Activity已经可见，但还不能和用户交互 onResume() :此时Activity已经可见并开始活动 onPause() :Activity正在停止，如果是从此Activity退到上一个Activity,那么会先执行此Activity的onPause,再执行上一个Activity的onResume,所以此方法不能执行耗时的操作，不然会影响新Activity的显示 onStop() : Activity即将停止,紧接着onPause后面执行 onDestroy() : Activity即将销毁,在这里主要做一些资源的释放完整的启动流程是从上到下,有几个具体情况说明:1)第一次启动一个新的Activity: onCreate-&gt;onStart-&gt;onResume2)再次打开一个Activity或者切换到桌面：onPause -&gt;onStop (注：如果新的Activity是用的透明主题,那么不会回调onStop)3) 再次回到此Activity：onRestar -&gt;onStart -&gt;onResume4)退出此Activity (finish掉)：onPause -&gt;onStop -&gt;onDestroty 异常情况生命周期资源相关的系统配置发生了改变导致Activity被杀死并重新创建发生此种情况最典型的就是横竖屏的切换,因为系统会去拿两张不同的图片，这时，Activity就会重新创建,它的onPause,onStop,onDestroy都会被调用,同时因为Activity是在异常情况下终止的,所以系统会调用onSaveInstanceState来保存当前Activity的状态，这个方法会在onStop方法之前调用。当Activity创建完成,系统会调用onRestoreInstanceState，可以从这个方法里拿到bundle对象并恢复Activity的状态 资源不足导致Activity被杀死此种情况和第一类差不多，都可以通过以上两种方法来恢复数据 此外，我们还可以不让Activity重新创建,通过在清单文件中指定Activity的configChanges属性,通过这些属性,可以让我们在特定场景下Activity不会被重新创建,此时，如果我们进行了特殊的操作,Activity会调用onConfigurationChanged方法 Activity的启动模式1)standard： 默认模式，每次都打开一个新的Activity,例如ABCD四个Activity,A是最底的Activity,D是当前的栈顶Activity,通过D启动D，此时栈中的Activity就会变成ABCDD2）singleTop： 栈顶复用模式，例如ABCD四个Activity,用D启动D,栈中的Activity还是ABCD，D被复用了,并且D不会再次调用onCreate，而是会调用onNewIntent3)singleTask: 栈内复用模式,例如ABCD,通过D启动B，栈中的Activity为：ACDB,B不会被重新创建,并且B会放入到栈顶,如果是通过D启动E，那个栈中Activcity为ABCDE,因为E在栈中没有，系统会创建一个新的实例。复用的Activity依旧会调用onNewInternt4) 单实例模式，可以理解为加强版的singTask.此种模式不但拥有singTask的全部特性，而且是单独的位于一个任务栈中，例如A是此种模式，那个系统会创建一个新的任务栈，那么由于栈的复用特性，后续的请求都不会重新创建新的Activity，除非被系统销毁了 启动模式的设置1）通过清单文件的launchMode属性设置2）通过Intent设置标志位来指定1234Intent intent = new Intent();intent.setClass(A.this,B.class);intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);startActivity(intent); 两者的区别:第二种的优先级会高于第一种，第一种无法设置FLAG_ACTIVITY_CLEAR_TOP标识,第二种无法为Activity指定singleInstance模式。 Activity的FlagsFLAG_ACTIVITY_NEW_TASKsingleTask模式FLAG_ACTIVITY_SINGLE_TOPsingleTop模式FLAG_ACTIVITY_CLEAR_TOP设置了此模式，如果是singleTask模式启动,那么就会调用onNewIntent，如果是standard模式启动,那么位于此Activity栈上的所有Activity都要出栈FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS具有这个标记的Activity不会出现在列表中,等同于xml中的excludeFromRecents=true;]]></content>
      <categories>
        <category>Android基础进阶</category>
        <category>安卓Activity</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有哪些送给年轻人的建议或道理？]]></title>
    <url>%2F%E6%9C%89%E5%93%AA%E4%BA%9B%E9%80%81%E7%BB%99%E5%B9%B4%E8%BD%BB%E4%BA%BA%E7%9A%84%E5%BB%BA%E8%AE%AE%E6%88%96%E9%81%93%E7%90%86%EF%BC%9F.html</url>
    <content type="text"><![CDATA[序言：这篇文章，写给你们，也写给我自己，我自己会经常阅读这篇文章来激励自己，每当自己茫然，无措，不知道该干嘛时，我都会读一遍，这样我的脑海就会自动给自己罗列出一些事情来做，哈哈哈。希望对阅读这篇文章的你会有启发,我相信未来的你一定会感谢现在这么努力的自己！ 学习很重要！学习很重要！学习很重要！ 知识或者技能这种东西，学到了就跟你一辈子，不管工作或时空跨度多大，新知和技能都能排上用场，请不要感叹时光已逝，学习不易，人家老来考研的，甚是80岁学编程的都有，请不要为你的懒惰找借口。 习惯很重要！ 有人总是和我们说，要养成好的习惯。可没人跟我说重要到深度影响自己生活、人生选择和生命质量的程度。因为几乎大多数人，每时每刻都生活在形形色色的思维习惯、生活习惯中，比如健身、跑步、阅读、表达、写作、沟通、学习等等，所有影响我们生活工作结果的全是这些习惯。我们养成习惯，然后习惯养成我们。 学会学习他人优秀的品质围剿式学习，也就是吸星大法，通过观察对方的沟通、演讲、写作方式，从而学习他们的思维方式、学习他们身上最优秀的思维习惯,当你们把优秀的人身上优秀的品质学习下来，这就是成功！ 真诚和诚信真诚是领导力的真谛，诚信是商业的真谛，每个人的年薪、领导能力、商业成就全部都可以从这两个词汇里诠释,当你自己做老板你就会觉得这两个品质是多么的重要了。 要多陪陪家人年轻人可能心里想得更多的是幸福生活，但父母的年纪，他们年龄越大，越要去面临离开这一主题，他们担心被世界抛弃，担心自己在儿女生活中扮演不了什么重要价值，特别渴望回馈、关注和尊重，不管多忙，能多打一个电话就多打一个电话，能多在一起吃顿饭，就多在一起吃顿饭，能满足他们想要的，不管大小，尽量去满足。可能你没察觉的是，随着你的逐渐成长，你的父母正逼近死亡！ 不要熬夜睡眠其实真正决定了生命的效率。因为睡眠决定着第二天的心情、状态、专注度等，而心情、状态、专注度直接影响结果，我们的现在就是由大大小小的这些结果构成的。所以睡个好觉可能是让生活变得更好的最大的捷径。不要相信什么狗血成功剧经常熬夜就能成功，成功是讲究效率的。 保持自我，不断完善保持自我，并不断变得更好，其实在一段感情里，远比委曲求全，一味地宠溺对方，更重要。保持自我可以测试出和对方是否合拍，不断变得更好，可以让感情更深刻而持久。千万不要因为孤独、无助、父母逼迫、个人面子、焦虑等原因仓促地选择一个人。这个人是自己生命的一部分，对自己施加着无以复加地影响，所以谨慎点，即便单身都比错误好很多。 用感官去发现更美好的世界利用所有的感官去体验周遭的世界是那么重要，刻意发现生活的美，发现细微处的不同，会给自己带来很多小惊喜 接下来聊聊职场发展的,人要舍得投资自己，这样你才会越来越值钱 不要让专业限制你的选择许多人或许都是一些刚刚步入社会的学生，学生思维的一大局限就是觉得找工作应该专业要对口，实际上从我个人的观察来看，大学毕业后，同学中反倒是从事本专业的属于小众，我觉得造成这个现象的原因有：（1）一般来说，填高考志愿的时候，你报的专业未来到底能做什么工作，你的父母如果不太了解的话，你必定也不太了解，况且很多学生报的专业都是那种所谓的热门专业，或者父母给选的，或者父母从事的专业；（2）上大学后，真正的学了专业课后，你很有可能并不感兴趣，或者并不擅长；（3）除了少数对专业知识要求较高的理工科专业，大部分专业毕业后去公司实习完全可以搞明白工作流程。所以除了队技术要求较高的理工科职位，其他大多数职位，毕业去公司，通过实际工作中学习，是完全可以的，只要你做了感兴趣，并且擅长的工作，工作技能都是学的很快的，而且在公司里你不懂的问题可以直接问资历老的员工，比你自己在学校里上课效率高多了，我本科学计算机的，班里同学有从事媒体的，金融的，出版社的，房地产的，考公务员的，还有经商的，反正干啥的都有，只要是你感兴趣的，并且觉得自己能做好的职位，大可以一试。 不要怕犯错，年轻没有失败网上很多人说过要找自己擅长的工作，但是问题是，一份工作你没干之前，很难知道自己到底是否擅长，那这份擅长的工作或行业要怎么找呢？答案是：多去尝试不同的职业。大学刚毕业一两年，很有可能你目前从事的工作并不是你喜欢的，也不是你一辈子只能干这个，如果干的不开心，并且在公司里干的也不算出色，那么，很可能就是你不擅长这个行业，这个时候，仗着你年轻，你大可以辞职转行，30岁之前你的转行成本是很低的，因为你年轻，大部分公司都会给你一个面试的机会，等你过了30岁再想转行，也不是不可能，但是难度比20几岁的时候会高几个量级：（1）从公司的角度来看，公司更爱培养年轻人；（2）30岁很可能结婚了，上有老，下有小，转行的风险特别的高，就是找1个月工作，很多家庭的房贷就要断供了，导致这个年纪即使想转行，需要考虑的因素也会多很多。所以，最好的选择就是在你的25-30岁之间这5年里，找到你擅长的行业或领域，这5年内你干的不爽尽可以换，但是最好在30岁之前找到自己能做一生的职业，并且稳定下来。 好好利用下班的时间，5年后会给你带来巨大的改变20-25岁的年轻人，如果指望不上父母，只能靠自己奋斗的话，说难听点，你随后的几年是不应该有过多的娱乐生活的。道理很简单，在你没有过多的好的选择的时候，好好工作，升职加薪是你能做到的风险最小的选择（创业风险太高，不适合普通人），而决定你升职加薪的关键就是你的工作技能，所以如果你想30岁混个一官半职当个小主管，不想再当普通打工仔，那么，有效的利用下班时间好好的给自己充电是你必须要做的。而现代社会每个人白天得上至少八小时的班（不加班的企业真是良心），即使你有幸在一家不加班的企业工作，晚上下班挤地铁/公交到家吃完饭，洗完澡之后，怎么着也得8点了，如果你12点睡的话（基本已是极限，再晚睡会影响白天的工作），你一天中有效的连续学习时间就是4小时（这是比较乐观的估计，还有很多人通勤时间就得1个多小时，所以能有4个小时的学习时间的人真是很幸运），4小时，乍一看不少了，但是实际用起来，减掉中间休息一下的时间，你就会发现，是很紧凑的，而且一旦开始决定晚上学习，基本就不能隔三差五的和朋友出去浪了，因为就怕一出去，打破了学习惯性，心就散了，无心再耐心学习下去了，所以如果你决定给自己充电，几乎也就可以告别娱乐生活了，虽然这样的生活很苦，但是人生是需要规划的，若干年后，你应该感谢曾经那么的努力的自己。一辈子很长，25岁是你播种的时候，为的是未来的收获。 对工作的爱好最重要爱好是最重要的，你不爱的工作再赚钱你也会忧郁症的，到时候每天起床都没动力，毕竟工作是半辈子的事情。 定制自己的职业发展计划,明确自己要的是什么提前给自己定好计划，避免让自己像一个无头苍蝇般到处乱飞，明确自己想要的是什么，该如何去努力，对自己的财产也要有规划，多阅读一些关于金融理财类的书籍。 最后，再来一个毒鸡汤总结 这是一个带毒的总结在年轻的时候，即使你知道再多“人生的道理”，即使你下了再大的决心，即使你做了再周密的计划。你还是可能一事无成。因为你并没有坚持下来,道理你都懂，要干什么事儿也都知道，为什么你做不到？有谁认真想过? 我们之所以做不到，是因为大部分人，都无法把自己眼前的事或即将要做的事，和今后的收益联系起来,因为你坚持了一个月后,你可能就会想，我这样做真的有用吗？这时你就会彷徨，甚至惊恐，毕竟，隔山的金子不如铜:我又不靠写作吃饭,看那么多书有什么用呢?一个月就那么点钱,理财有什么用呢?已经长那样了,健身有什么用呢?我又不想出国、不考外交部、不去外企,你让我努力打卡学英语不是搞笑吗?………人往往就是这样,事到临头才会想到要抱佛脚。那么如何才能去坚持，其实我也没什么方法可言，道理你都懂了，做与不做都是你的一念之间,我只能告诉你一个道理需要你们自己去悟： 你要让你所有做的事情，随着时间发展产生变化 你需要的只是在年轻的时候多用时间做资本，去为未来做投资.就能在未来取得收益后，买下更重要的时间。人的一生很宝贵，酒足饭饱之余，不妨多想想，做点什么更有用的事，才能在阶层固化之前尽量往上多蹦一两个台阶 因为，相对于你今后的每一天，现在的你都是最年轻的你。好文链接： 【习惯】你培养习惯的方法可能是个假方法 你的所谓成熟，不过是精神早衰 —————————–希望生活善待如此努力的你❤—————————-]]></content>
      <categories>
        <category>感悟</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如何将个人域名与github绑定]]></title>
    <url>%2F%E5%A6%82%E4%BD%95%E5%B0%86%E4%B8%AA%E4%BA%BA%E5%9F%9F%E5%90%8D%E4%B8%8Egithub%E7%BB%91%E5%AE%9A.html</url>
    <content type="text"><![CDATA[购买个人域名例如我的是在阿里云万网购买的,点击进入域名列表,点击解析,会出现一个添加解析按钮，点开有记录类型，主机记录，解析线路，记录值，TTL值五个选项依次填写： 记录类型：A 主机记录：www 解析线路：不用选，就用默认 记录值：填写你的github网址的ip,可以用ip查询或ping查到，一般都是151开头。 TTL值：不用管，默认10分钟。 填写完毕后就可以关闭页面了 Github配置在你的io网站本地仓库中新建一个CHAME(注意都要大写)文件，没有后缀，打开编辑，将你的域名添加进入，例如我的就是www.huangjie.name,保存，关闭,将文件提交到远程仓库,这时github应该会发一封邮件给你代表配置成功，更改不会立即生效，一般10分钟左右 如果你是用的hexo，可以将CHAME文件建立在source文件夹中，这样通过Hexo提交到github不会被覆盖]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客使用心得]]></title>
    <url>%2Fhello-world.html</url>
    <content type="text"><![CDATA[欢迎来到黄杰的个人博客，这是我写入的第一篇博文,此博客平台采用 Hexo + githubPages搭建而成,搭建日期：2017/11/29。这篇博客将持续记录hexo使用过程中的一些问题 引言记录一些自己搭建的参考资料 http://blog.haoji.me/build-blog-website-by-hexo-github.html?from=xa https://hexo.io/zh-cn/docs/generating.html http://blog.csdn.net/poem_of_sunshine/article/details/2936978 http://blog.sunnyxx.com/2014/02/27/hexo_startup/ 常用命令进入项目主结构，使用git bash执行命令 监听文件变动 $ hexo g 开启本地服务 $ hexo s ，开启后在浏览器输入http://localhost:4000 即可访问 提交代码 $ hexo d ，需要配置deploy 在主项目目录下有个_config.yml,为全局配置文件,在themes文件夹里，存放着网站使用的主题文件，打开主题文件夹，里面也有个_config.yml，为主题配置文件，与主题相关的在这里配置，我现在采用的是Next主题 遇到的问题一.首页的文章内容全部显示出来了，没有“阅读全文”?解决办法有两种方法 第一种：在主题配置文件里(themes/next/_config.yml)用编辑器打开，找到12345# Automatically Excerpt. Not recommend.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: false length: 150 将 enable：false 改为true就行了，后面的length:150代表显示的文本字数。 第二种：直接在编辑的.md文件里将要预览的文字后面加上&lt;!--more--&gt;,这样之前的就是预览的文字,后面的就不会显示了 二.如何将README.md文件传到github而不被编译成html在Hexo目录的source目录在建立一个README.md文件,修改Hexo目录的_config.yml配置,找到 skip_render参数设置,后面加上 README.md,关闭保存,之后编译就不会渲染README.md这个文件了 三.百度搜索引擎不能收录自己的网站地址原因是github屏蔽了百度的spider爬虫,导致百度不能收录,解决办法是使用coding来托管国内的流量访问,具体的方法可以参考这篇博文:hexo高阶教程：想让你的博客被更多的人在搜索引擎中搜到吗？ 写作技巧记录一.如何将md文件以时间命名 在_config.yml中找到new_post_name,修改名称为:year-:month-:day-:title.md,这样创建的文件就会以电脑时间命名，使用时间命名可以更方便的管理文章]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[About Me Android 小生一枚，轻微强迫症患者，非处女座，忠实谷粉兼果粉，喜欢看书听歌旅游，最近的目标是去西藏，有组团的欢迎私我 Email(QQ): jay@huangjie.name Github : Jay-huangjie Weixin: h289223562 QQ: 289223562 CSDN: _杰哥]]></content>
  </entry>
  <entry>
    <title><![CDATA[tags]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[分类]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
