<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[okhttp3Wiki文档译文]]></title>
      <url>/okhttp3-wiki-chinese.html</url>
      <content type="html"><![CDATA[<p><strong>版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起.</strong></p>
<hr>
<blockquote>
<p>本文主要是提供一些okhttp3的文档翻译,英文文档:<a href="https://github.com/square/okhttp/wiki" target="_blank" rel="noopener">https://github.com/square/okhttp/wiki</a></p>
</blockquote>
<a id="more"></a>
<h3 id="Calls-调用"><a href="#Calls-调用" class="headerlink" title="Calls(调用)"></a>Calls(调用)</h3><p>HTTP客户端的工作是接受你的请求并产生响应。这在理论上很简单，但在实践中会变得棘手。</p>
<h4 id="Requests"><a href="#Requests" class="headerlink" title="Requests"></a><a href="http://square.github.io/okhttp/3.x/okhttp/okhttp3/Request.html" target="_blank" rel="noopener">Requests</a></h4><p>每个HTTP请求都包含一个URL，一个方法（如GET或POST）和一个头部列表(headers)。请求也可能包含一个请求体(body)：特定内容类型的数据流。</p>
<h4 id="Responses"><a href="#Responses" class="headerlink" title="Responses"></a><a href="http://square.github.io/okhttp/3.x/okhttp/okhttp3/Response.html" target="_blank" rel="noopener">Responses</a></h4><p>每一个HTTP响应中都包含一个状态码（如200代表成功，404代表未找​​到），一个响应头列表（headers）和一个可选的响应体（body）。</p>
<h4 id="重写请求"><a href="#重写请求" class="headerlink" title="重写请求"></a>重写请求</h4><p>当你的OkHttp发送一个HTTP请求，你在描述一个高层次的要求：“给我获取这个网址中的这些请求头。”对于正确性和效率，OkHttp发送前会重写你的请求。</p>
<p>OkHttp可以在原先的请求中添加请求头（headers），包括Content-Length, Transfer-Encoding, User-Agent, Host, Connection, 和 Content-Type。除非请求头已经存在压缩响应，否则它还将添加一个Accept-Encoding请求头。如果你有cookies，OkHttp还将添加一个Cookie请求头。</p>
<p>一些请求会有一个缓存的响应。当这个缓存的响应不是最新的时候，OkHttp会发送一个有条件的GET来下载更新的响应，如果它比缓存还新。它将会添加需要的请求头，如IF-Modified-Since和If-None-Match。</p>
<h4 id="重写响应"><a href="#重写响应" class="headerlink" title="重写响应"></a>重写响应</h4><p>如果使用透明压缩，OkHttp将删除相应的响应头Content-Encoding，Content-Length因为它们不适用于解压缩的响应主体。</p>
<p>如果条件GET成功，则来自网络和缓存的响应将按照规范的指示进行合并。</p>
<h4 id="后续请求"><a href="#后续请求" class="headerlink" title="后续请求"></a>后续请求</h4><p>当您请求的URL已经移动时，Web服务器将返回一个响应代码，302以指示文档的新URL。OkHttp将按照重定向来检索最终响应。<br>如果响应发出授权质询，则OkHttp会询问<a href="http://square.github.io/okhttp/3.x/okhttp/okhttp3/Authenticator.html" target="_blank" rel="noopener">Authenticator</a>（如果已配置）以满足质询。如果认证者提供证书，则请求将会带着证书进行重试。</p>
<h4 id="重试请求"><a href="#重试请求" class="headerlink" title="重试请求"></a>重试请求</h4><p>有时连接失败：要么是连接池已经过时和断开，或是Web服务器本身无法达成。如果有一个是可用的，OkHttp将会使用不同的路由进行请求重试。</p>
<h4 id="呼叫"><a href="#呼叫" class="headerlink" title="呼叫"></a><a href="http://square.github.io/okhttp/3.x/okhttp/okhttp3/Call.html" target="_blank" rel="noopener">呼叫</a></h4><p>随着重写，重定向，后续和重试，你简单的要求可能会产生很多请求和响应。OkHttp使用呼叫（Call）并通过许多必要的中间请求和响应来满足你请求的任务模型。通常情况，这是不是很多！如果您的网址被重定向，或者如果您故障转移到另一个IP地址，但它会欣慰的知道你的代码会继续工作。</p>
<p>通过以下两种方式进行呼叫： </p>
<ul>
<li>同步：直到响应,你的线程块是可读的。 </li>
<li>异步：你在任何线程进行排队请求，并且当响应是可读的时候，你会在另一个线程得到回调。</li>
</ul>
<p>呼叫（Calls）可以在任何线程中取消。如果它尚未完成，它将作为失败的呼叫（Calls）！当呼叫（Call）被取消的时候，如果代码试图进行写请求体（request body）或读取响应体（response body）会遭受IOException异常。</p>
<h4 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h4><p>对于同步呼叫，您需要自带线程，并负责管理多少个同时发出的请求。同时连接的垃圾资源过多; 太少的危害等待时间。</p>
<p>对于异步调用，<a href="http://square.github.io/okhttp/3.x/okhttp/okhttp3/Dispatcher.html" target="_blank" rel="noopener">Dispatcher</a>实现最大同时请求的策略。您可以设置每个网络服务器的最大数量（默认值是5），总体（默认值是64）。</p>
<h3 id="Connections-连接"><a href="#Connections-连接" class="headerlink" title="Connections(连接)"></a>Connections(连接)</h3><p>虽然您只提供了URL，但是OkHttp计划使用三种类型连接到你的web服务器：URL, Address, 和 Route</p>
<h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><p>URL（如<a href="https://github.com/square/okhttp）是HTTP和Internet的基础。除了作为网络上所有内容的通用分散命名方案之外，他们还指定如何访问网络资源。" target="_blank" rel="noopener">https://github.com/square/okhttp）是HTTP和Internet的基础。除了作为网络上所有内容的通用分散命名方案之外，他们还指定如何访问网络资源。</a></p>
<p>网址是抽象的：</p>
<ul>
<li>他们指定的调用可能是明文（http）或加密（https），但不应该使用哪些加密算法。他们也没有指定如何验证对等方的证书（HostnameVerifier）或哪些证书可以信任（SSLSocketFactory）。他们也是具体的：每个URL标识一个特定的路径（如/square/okhttp）和查询（如?q=sharks&amp;lang=en）。每个网络服务器都有许多网址。</li>
<li>它们不指定是否应该使用特定的代理服务器，或者如何使用该代理服务器进行身份验证。</li>
</ul>
<p>他们也是具体的：每个URL标识一个特定的路径（如/square/okhttp）和查询（如?q=sharks&amp;lang=en）。每个网络服务器都有许多网址。</p>
<h4 id="Addresses"><a href="#Addresses" class="headerlink" title="Addresses"></a>Addresses</h4><p>地址指定一个网络服务器（如github.com）以及连接到该服务器所需的所有静态配置：端口号，HTTPS设置和首选网络协议（如HTTP / 2或SPDY）。</p>
<p>共享相同地址的URL也可能共享相同的底层TCP套接字连接。共享连接具有显着的性能优势：更低的延迟，更高的吞吐量（由于<a href="http://www.igvita.com/2011/10/20/faster-web-vs-tcp-slow-start/" target="_blank" rel="noopener">TCP启动缓慢</a>）和保存的电池。OkHttp使用<a href="http://square.github.io/okhttp/3.x/okhttp/okhttp3/ConnectionPool.html" target="_blank" rel="noopener">ConnectionPool</a>自动重用HTTP / 1.x连接并复用HTTP / 2和SPDY连接。</p>
<p>在OkHttp地址的一些字段来自URL（方案，主机名，端口），其余来自<a href="http://square.github.io/okhttp/3.x/okhttp/okhttp3/OkHttpClient.html" target="_blank" rel="noopener">OkHttpClient</a>。</p>
<h4 id="Routes"><a href="#Routes" class="headerlink" title="Routes"></a>Routes</h4><p>路由提供实际连接到Web服务器所需的动态信息。这是要尝试的特定IP地址（通过DNS查询发现），要使用的确切代理服务器（如果正在使用<a href="http://developer.android.com/reference/java/net/ProxySelector.html" target="_blank" rel="noopener">ProxySelector</a>）以及要协商哪个版本的TLS（用于HTTPS连接）。</p>
<p>单个地址可能有很多路线。例如，托管在多个数据中心中的Web服务器可能会在其DNS响应中产生多个IP地址。</p>
<h4 id="Connections"><a href="#Connections" class="headerlink" title="Connections"></a>Connections</h4><p>当你用OkHttp请求一个URL的时候，它的功能如下：</p>
<p>它使用URL并配置OkHttpClient来创建一个地址。该地址指定我们将如何连接到Web服务器。<br>它尝试从连接池中检索具有该地址的连接。<br>如果在池中找不到连接，则选择要尝试的路由。这通常意味着发出DNS请求来获取服务器的IP地址。然后根据需要选择TLS版本和代理服务器。<br>如果是新路由，则通过构建直接套接字连接，TLS隧道（用于通过HTTP代理的HTTPS）或直接TLS连接进行连接。它根据需要进行TLS握手。<br>它发送HTTP请求并读取响应。<br>如果连接有问题，OkHttp会选择另外一个路径，然后重试。这允许OkHttp在服务器地址的子集无法访问时恢复。当池连接失效或尝试的TLS版本不受支持时，这也很有用。</p>
<p>一旦接收到响应，连接将被返回到池中，以便将来可以重复使用。经过一段时间的不活动之后，连接被从池中逐出。</p>
<h3 id="Recipes-方法"><a href="#Recipes-方法" class="headerlink" title="Recipes(方法)"></a>Recipes(方法)</h3><p>我们已经写了一些方法，演示了如何解决OkHttp常见问题。通过阅读他们了解一切是如何正常工作的。可以自由剪切和粘贴这些例子。</p>
<h4 id="同步获取-Synchronous-Get"><a href="#同步获取-Synchronous-Get" class="headerlink" title="同步获取(Synchronous Get)"></a>同步获取(Synchronous Get)</h4><p>下载文件，打印其头部，并以字符串形式打印其响应体。</p>
<p>该<code>string()</code>方法在响应体中是方便快捷的小型文件。但是，如果响应体较大（大于1 MIB以上），它会将整个较大文件加载到内存中，所以应该避免<code>string()</code> 。在这种情况下，更倾向于将响应体作为流进行处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">      .url(<span class="string">"https://publicobject.com/helloworld.txt"</span>)</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> (Response response = client.newCall(request).execute()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!response.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response);</span><br><span class="line"></span><br><span class="line">    Headers responseHeaders = response.headers();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; responseHeaders.size(); i++) &#123;</span><br><span class="line">      System.out.println(responseHeaders.name(i) + <span class="string">": "</span> + responseHeaders.value(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(response.body().string());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="异步获取-Asynchronous-Get"><a href="#异步获取-Asynchronous-Get" class="headerlink" title="异步获取(Asynchronous Get)"></a>异步获取(Asynchronous Get)</h4><p>下载一个工作线程的文件，当响应是可读的时候，获取回调（Callback）。当响应头已经准备好后，将产生回调（Callback）。读取响应体可能一直阻塞。目前OkHttp不提供异步API来接收响应体的部位。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">        .url(<span class="string">"http://publicobject.com/helloworld.txt"</span>)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    client.newCall(request).enqueue(<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call call, IOException e)</span> </span>&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call call, Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ResponseBody responseBody = response.body()) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!response.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response);</span><br><span class="line"></span><br><span class="line">          Headers responseHeaders = response.headers();</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = responseHeaders.size(); i &lt; size; i++) &#123;</span><br><span class="line">            System.out.println(responseHeaders.name(i) + <span class="string">": "</span> + responseHeaders.value(i));</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          System.out.println(responseBody.string());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="访问头"><a href="#访问头" class="headerlink" title="访问头"></a>访问头</h4><p>典型的HTTP头工作就像一个Map<string, string=""> ：每个字段都有一个值或无值。但是，一些头部(headers)允许多个值，比如Guava的Multimap。例如，它共同为一个HTTP响应提供多个Vary头。OkHttp的API，试图使这两种情况下都能舒适使用。</string,></p>
<p>当写请求头，用header(name, value)来为唯一出现的name设置value。如果它本身存在值，在添加新的value之前，他们会被移除。使用addHeader(name, value)来添加头部不需要移除当前存在的headers。</p>
<p>当读取响应头，用header(name)返回最后设置name的value。如果没有value，header(name)将返回null。可以使用headers(name)来读取所有列表字段的值，。</p>
<p>要访问所有的头部，用Headers类，它支持索引访问。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">      .url(<span class="string">"https://api.github.com/repos/square/okhttp/issues"</span>)</span><br><span class="line">      .header(<span class="string">"User-Agent"</span>, <span class="string">"OkHttp Headers.java"</span>)</span><br><span class="line">      .addHeader(<span class="string">"Accept"</span>, <span class="string">"application/json; q=0.5"</span>)</span><br><span class="line">      .addHeader(<span class="string">"Accept"</span>, <span class="string">"application/vnd.github.v3+json"</span>)</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> (Response response = client.newCall(request).execute()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!response.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"Server: "</span> + response.header(<span class="string">"Server"</span>));</span><br><span class="line">    System.out.println(<span class="string">"Date: "</span> + response.header(<span class="string">"Date"</span>));</span><br><span class="line">    System.out.println(<span class="string">"Vary: "</span> + response.headers(<span class="string">"Vary"</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="提交一个文本-Posting-a-String"><a href="#提交一个文本-Posting-a-String" class="headerlink" title="提交一个文本(Posting a String)"></a>提交一个文本(Posting a String)</h4><p>使用HTTP POST的请求体发送到服务。下面例子post了一个markdown文档到一个的Web服务（将markdown作为HTML）。由于整个请求体是同时在内存中，应避免使用此API发送较大（大于1 MIB）的文件。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MediaType MEDIA_TYPE_MARKDOWN</span><br><span class="line">    = MediaType.parse(<span class="string">"text/x-markdown; charset=utf-8"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  String postBody = <span class="string">""</span></span><br><span class="line">      + <span class="string">"Releases\n"</span></span><br><span class="line">      + <span class="string">"--------\n"</span></span><br><span class="line">      + <span class="string">"\n"</span></span><br><span class="line">      + <span class="string">" * _1.0_ May 6, 2013\n"</span></span><br><span class="line">      + <span class="string">" * _1.1_ June 15, 2013\n"</span></span><br><span class="line">      + <span class="string">" * _1.2_ August 11, 2013\n"</span>;</span><br><span class="line"></span><br><span class="line">  Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">      .url(<span class="string">"https://api.github.com/markdown/raw"</span>)</span><br><span class="line">      .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, postBody))</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> (Response response = client.newCall(request).execute()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!response.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response);</span><br><span class="line"></span><br><span class="line">    System.out.println(response.body().string());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="发布一个流-Post-Streaming"><a href="#发布一个流-Post-Streaming" class="headerlink" title="发布一个流(Post Streaming)"></a>发布一个流(Post Streaming)</h4><p>在这里，我们POST请求体作为stream。将正在生成请求体的内容写入到stream中。下面例子streams直接进入<a href="https://github.com/square/okio" target="_blank" rel="noopener">Okio</a>缓冲水槽。你的程序可能更喜欢使用OutputStream，你可以通过BufferedSink.outputStream（）获得 OutputStream。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MediaType MEDIA_TYPE_MARKDOWN</span><br><span class="line">    = MediaType.parse(<span class="string">"text/x-markdown; charset=utf-8"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  RequestBody requestBody = <span class="keyword">new</span> RequestBody() &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> MediaType <span class="title">contentType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> MEDIA_TYPE_MARKDOWN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeTo</span><span class="params">(BufferedSink sink)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      sink.writeUtf8(<span class="string">"Numbers\n"</span>);</span><br><span class="line">      sink.writeUtf8(<span class="string">"-------\n"</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">997</span>; i++) &#123;</span><br><span class="line">        sink.writeUtf8(String.format(<span class="string">" * %s = %s\n"</span>, i, factor(i)));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">factor</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = n / i;</span><br><span class="line">        <span class="keyword">if</span> (x * i == n) <span class="keyword">return</span> factor(x) + <span class="string">" × "</span> + i;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> Integer.toString(n);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">      .url(<span class="string">"https://api.github.com/markdown/raw"</span>)</span><br><span class="line">      .post(requestBody)</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> (Response response = client.newCall(request).execute()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!response.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response);</span><br><span class="line"></span><br><span class="line">    System.out.println(response.body().string());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="发布文件-Posting-a-File"><a href="#发布文件-Posting-a-File" class="headerlink" title="发布文件(Posting a File)"></a>发布文件(Posting a File)</h4><p>将文件作为请求体是很容易的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MediaType MEDIA_TYPE_MARKDOWN</span><br><span class="line">    = MediaType.parse(<span class="string">"text/x-markdown; charset=utf-8"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  File file = <span class="keyword">new</span> File(<span class="string">"README.md"</span>);</span><br><span class="line"></span><br><span class="line">  Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">      .url(<span class="string">"https://api.github.com/markdown/raw"</span>)</span><br><span class="line">      .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, file))</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> (Response response = client.newCall(request).execute()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!response.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response);</span><br><span class="line"></span><br><span class="line">    System.out.println(response.body().string());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="发布表单-Posting-form-parameters"><a href="#发布表单-Posting-form-parameters" class="headerlink" title="发布表单(Posting form parameters)"></a>发布表单(Posting form parameters)</h4><p>使用<code>FormBody.Builder</code>建立一个请求体，它就像一个HTML的<code>&lt;form&gt;</code>标记。<code>Names</code>和<code>values</code>将使用<code>HTML</code>兼容的表单URL编码进行编码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  RequestBody formBody = <span class="keyword">new</span> FormBody.Builder()</span><br><span class="line">      .add(<span class="string">"search"</span>, <span class="string">"Jurassic Park"</span>)</span><br><span class="line">      .build();</span><br><span class="line">  Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">      .url(<span class="string">"https://en.wikipedia.org/w/index.php"</span>)</span><br><span class="line">      .post(formBody)</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> (Response response = client.newCall(request).execute()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!response.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response);</span><br><span class="line"> </span><br><span class="line">    System.out.println(response.body().string());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="发布multipart请求-Posting-a-multipart-request"><a href="#发布multipart请求-Posting-a-multipart-request" class="headerlink" title="发布multipart请求(Posting a multipart request)"></a>发布multipart请求(Posting a multipart request)</h4><p><code>MultipartBody.Builder</code>可以构建与HTML文件上传表单兼容的复杂请求主体。multipart请求体的每一部分本身就是请求体，并且可以定义自己的头部。如果存在，这些头应该描述的部分请求体，如它的<code>Content-Disposition</code>。如果<code>Content-Length</code>和 <code>Content-Type</code>头部可以使用，则他们会自动添加。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The imgur client ID for OkHttp recipes. If you're using imgur for anything other than running</span></span><br><span class="line"><span class="comment"> * these examples, please request your own client ID! https://api.imgur.com/oauth2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String IMGUR_CLIENT_ID = <span class="string">"..."</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MediaType MEDIA_TYPE_PNG = MediaType.parse(<span class="string">"image/png"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="comment">// Use the imgur image upload API as documented at https://api.imgur.com/endpoints/image</span></span><br><span class="line">  RequestBody requestBody = <span class="keyword">new</span> MultipartBody.Builder()</span><br><span class="line">      .setType(MultipartBody.FORM)</span><br><span class="line">      .addFormDataPart(<span class="string">"title"</span>, <span class="string">"Square Logo"</span>)</span><br><span class="line">      .addFormDataPart(<span class="string">"image"</span>, <span class="string">"logo-square.png"</span>,</span><br><span class="line">          RequestBody.create(MEDIA_TYPE_PNG, <span class="keyword">new</span> File(<span class="string">"website/static/logo-square.png"</span>)))</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">  Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">      .header(<span class="string">"Authorization"</span>, <span class="string">"Client-ID "</span> + IMGUR_CLIENT_ID)</span><br><span class="line">      .url(<span class="string">"https://api.imgur.com/3/image"</span>)</span><br><span class="line">      .post(requestBody)</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> (Response response = client.newCall(request).execute()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!response.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response);</span><br><span class="line"></span><br><span class="line">    System.out.println(response.body().string());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="用Moshi解析JSON响应"><a href="#用Moshi解析JSON响应" class="headerlink" title="用Moshi解析JSON响应"></a>用<code>Moshi</code>解析JSON响应</h4><p><a href="https://github.com/square/moshi" target="_blank" rel="noopener">Moshi</a>是一个便捷的API，用于在JSON和Java对象之间进行转换。这里我们使用它来解码来自GitHub API的JSON响应。</p>
<p>请注意，<code>ResponseBody.charStream()</code>使用<code>Content-Type</code>响应头来选择解码响应主体时使用哪个字符集。如果没有指定字符集，它默认为<code>UTF-8</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Moshi moshi = <span class="keyword">new</span> Moshi.Builder().build();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> JsonAdapter&lt;Gist&gt; gistJsonAdapter = moshi.adapter(Gist.class);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">      .url(<span class="string">"https://api.github.com/gists/c2a7c39532239ff261be"</span>)</span><br><span class="line">      .build();</span><br><span class="line">  <span class="keyword">try</span> (Response response = client.newCall(request).execute()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!response.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response);</span><br><span class="line"></span><br><span class="line">    Gist gist = gistJsonAdapter.fromJson(response.body().source());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, GistFile&gt; entry : gist.files.entrySet()) &#123;</span><br><span class="line">      System.out.println(entry.getKey());</span><br><span class="line">      System.out.println(entry.getValue().content);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Gist</span> </span>&#123;</span><br><span class="line">  Map&lt;String, GistFile&gt; files;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">GistFile</span> </span>&#123;</span><br><span class="line">  String content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="响应缓存"><a href="#响应缓存" class="headerlink" title="响应缓存"></a>响应缓存</h4><p>要缓存响应，你需要有一个缓存目录来进行读取和写入，并限制缓存的大小。缓存目录应该是私有的，不被信任的应用程序不能够阅读其内容！</p>
<p>多个缓存同时访问相同的缓存目录，这是错误的。大多数应用程序应该调用一次new OkHttpClient()，在任何地方都使用相同的实例和自己的缓存配置。否则，这两个缓存实例将踩到对方，破坏响应缓存，这可能使你的程序崩溃。</p>
<p>响应缓存使用HTTP头进行配置。您可以添加请求头Cache-Control: max-stale=3600，这样OkHttp的缓存就会遵循他们。你的网络服务器可以通过自己的响应头配置缓存多长时间的响应，如Cache-Control: max-age=9600。有缓存头强制缓存的响应，强制网络响应，或强制使用条件GET验证的网络响应。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CacheResponse</span><span class="params">(File cacheDirectory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> cacheSize = <span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>; <span class="comment">// 10 MiB</span></span><br><span class="line">  Cache cache = <span class="keyword">new</span> Cache(cacheDirectory, cacheSize);</span><br><span class="line"></span><br><span class="line">  client = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">      .cache(cache)</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">      .url(<span class="string">"http://publicobject.com/helloworld.txt"</span>)</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">  String response1Body;</span><br><span class="line">  <span class="keyword">try</span> (Response response1 = client.newCall(request).execute()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!response1.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response1);</span><br><span class="line"></span><br><span class="line">    response1Body = response1.body().string();</span><br><span class="line">    System.out.println(<span class="string">"Response 1 response:          "</span> + response1);</span><br><span class="line">    System.out.println(<span class="string">"Response 1 cache response:    "</span> + response1.cacheResponse());</span><br><span class="line">    System.out.println(<span class="string">"Response 1 network response:  "</span> + response1.networkResponse());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  String response2Body;</span><br><span class="line">  <span class="keyword">try</span> (Response response2 = client.newCall(request).execute()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!response2.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response2);</span><br><span class="line"></span><br><span class="line">    response2Body = response2.body().string();</span><br><span class="line">    System.out.println(<span class="string">"Response 2 response:          "</span> + response2);</span><br><span class="line">    System.out.println(<span class="string">"Response 2 cache response:    "</span> + response2.cacheResponse());</span><br><span class="line">    System.out.println(<span class="string">"Response 2 network response:  "</span> + response2.networkResponse());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">"Response 2 equals Response 1? "</span> + response1Body.equals(response2Body));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>CacheControl.FORCE_NETWORK</code>可以禁止使用缓存的响应。使<code>用</code>CacheControl.FORCE_CACHE<code>可以禁止使用网络。警告：如果您使用FORCE_CACHE</code>和响应来自网络，OkHttp将会返回一个504不可满足请求的响应。</p>
<h4 id="取消Call"><a href="#取消Call" class="headerlink" title="取消Call"></a>取消Call</h4><p>通过<code>Call.cancel()</code>来立即停止正在进行的Call。如果一个线程目前正在写请求或读响应，它还将收到一个<code>IOException</code>异常。当一个Call不需要时，使用取消Call来保护网络; 例如，当用户从应用程序导航离开。同步和异步调用可以被取消。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService executor = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">      .url(<span class="string">"http://httpbin.org/delay/2"</span>) <span class="comment">// This URL is served with a 2 second delay.</span></span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">long</span> startNanos = System.nanoTime();</span><br><span class="line">  <span class="keyword">final</span> Call call = client.newCall(request);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Schedule a job to cancel the call in 1 second.</span></span><br><span class="line">  executor.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.printf(<span class="string">"%.2f Canceling call.%n"</span>, (System.nanoTime() - startNanos) / <span class="number">1e9f</span>);</span><br><span class="line">      call.cancel();</span><br><span class="line">      System.out.printf(<span class="string">"%.2f Canceled call.%n"</span>, (System.nanoTime() - startNanos) / <span class="number">1e9f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">  System.out.printf(<span class="string">"%.2f Executing call.%n"</span>, (System.nanoTime() - startNanos) / <span class="number">1e9f</span>);</span><br><span class="line">  <span class="keyword">try</span> (Response response = call.execute()) &#123;</span><br><span class="line">    System.out.printf(<span class="string">"%.2f Call was expected to fail, but completed: %s%n"</span>,</span><br><span class="line">        (System.nanoTime() - startNanos) / <span class="number">1e9f</span>, response);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    System.out.printf(<span class="string">"%.2f Call failed as expected: %s%n"</span>,</span><br><span class="line">        (System.nanoTime() - startNanos) / <span class="number">1e9f</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h4><p>当无法访问查询时，将调用超时失败。超时在网络划分中可以是由于客户端连接问题，服务器可用性的问题，或两者之间的任何东西。OkHttp支持连接，读取和写入超时。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConfigureTimeouts</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  client = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">      .connectTimeout(<span class="number">10</span>, TimeUnit.SECONDS)</span><br><span class="line">      .writeTimeout(<span class="number">10</span>, TimeUnit.SECONDS)</span><br><span class="line">      .readTimeout(<span class="number">30</span>, TimeUnit.SECONDS)</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">      .url(<span class="string">"http://httpbin.org/delay/2"</span>) <span class="comment">// This URL is served with a 2 second delay.</span></span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> (Response response = client.newCall(request).execute()) &#123;</span><br><span class="line">    System.out.println(<span class="string">"Response completed: "</span> + response);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="每个呼叫配置"><a href="#每个呼叫配置" class="headerlink" title="每个呼叫配置"></a>每个呼叫配置</h4><p>所有的HTTP客户端都在<code>OkHttpClient</code>中配置，这包括代理设置，超时和缓存。当你需要改变单一Call的配置时，调用<code>OkHttpClient.newBuilder()</code>。这将返回共享相同的连接池，调度和配置的原客户端的建造器。在下面的例子中，我们做了500毫秒超时，另外一个3000毫秒超时请求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">      .url(<span class="string">"http://httpbin.org/delay/1"</span>) <span class="comment">// This URL is served with a 1 second delay.</span></span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Copy to customize OkHttp for this request.</span></span><br><span class="line">  OkHttpClient client1 = client.newBuilder()</span><br><span class="line">      .readTimeout(<span class="number">500</span>, TimeUnit.MILLISECONDS)</span><br><span class="line">      .build();</span><br><span class="line">  <span class="keyword">try</span> (Response response = client1.newCall(request).execute()) &#123;</span><br><span class="line">    System.out.println(<span class="string">"Response 1 succeeded: "</span> + response);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">"Response 1 failed: "</span> + e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Copy to customize OkHttp for this request.</span></span><br><span class="line">  OkHttpClient client2 = client.newBuilder()</span><br><span class="line">      .readTimeout(<span class="number">3000</span>, TimeUnit.MILLISECONDS)</span><br><span class="line">      .build();</span><br><span class="line">  <span class="keyword">try</span> (Response response = client2.newCall(request).execute()) &#123;</span><br><span class="line">    System.out.println(<span class="string">"Response 2 succeeded: "</span> + response);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">"Response 2 failed: "</span> + e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="认证处理"><a href="#认证处理" class="headerlink" title="认证处理"></a>认证处理</h4><p>OkHttp能够自动重试未经授权的请求。当响应是<code>401 Not Authorized</code>，一个<code>Authenticator</code>被要求提供凭据。应该建立一个包含缺少凭据的新要求。如果没有凭证可用，则返回null跳过重试。</p>
<p>使用<code>Response.challenges（）</code>获得任何认证挑战方案和领域。当完成一个基本的挑战，用<code>Credentials.basic(username, password)</code>编码请求头。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Authenticate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  client = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">      .authenticator(<span class="keyword">new</span> Authenticator() &#123;</span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Request <span class="title">authenticate</span><span class="params">(Route route, Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (response.request().header(<span class="string">"Authorization"</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// Give up, we've already attempted to authenticate.</span></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          System.out.println(<span class="string">"Authenticating for response: "</span> + response);</span><br><span class="line">          System.out.println(<span class="string">"Challenges: "</span> + response.challenges());</span><br><span class="line">          String credential = Credentials.basic(<span class="string">"jesse"</span>, <span class="string">"password1"</span>);</span><br><span class="line">          <span class="keyword">return</span> response.request().newBuilder()</span><br><span class="line">              .header(<span class="string">"Authorization"</span>, credential)</span><br><span class="line">              .build();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">      .url(<span class="string">"http://publicobject.com/secrets/hellosecret.txt"</span>)</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> (Response response = client.newCall(request).execute()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!response.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response);</span><br><span class="line"></span><br><span class="line">    System.out.println(response.body().string());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了避免验证时不工作的重试，你可以返回null放弃。例如，当这些确切的凭据已经尝试,您可以跳过重试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (credential.equals(response.request().header(<span class="string">"Authorization"</span>))) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 如果我们已经使用这些凭据失败，不重试</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>当你的应用尝试的次数超过了限制的次数时，你可以跳过重试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (responseCount(response) &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">//如果我们已经失败了3次，放弃。 .</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>这上面的代码依赖于下面的<code>responseCount()</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">responseCount</span><span class="params">(Response response)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">while</span> ((response = response.priorResponse()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">     result++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Interceptors-拦截器"><a href="#Interceptors-拦截器" class="headerlink" title="Interceptors(拦截器)"></a>Interceptors(拦截器)</h3><p>拦截器是一个强大的机制，它可以监控，重写和重试Calls。下面是一个简单记录传出请求和响应传入的拦截器。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Interceptor.Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Request request = chain.request();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">    logger.info(String.format(<span class="string">"Sending request %s on %s%n%s"</span>,</span><br><span class="line">        request.url(), chain.connection(), request.headers()));</span><br><span class="line"></span><br><span class="line">    Response response = chain.proceed(request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> t2 = System.nanoTime();</span><br><span class="line">    logger.info(String.format(<span class="string">"Received response for %s in %.1fms%n%s"</span>,</span><br><span class="line">        response.request().url(), (t2 - t1) / <span class="number">1e6</span>d, response.headers()));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用<code>chain.proceed(request)</code>是每个拦截器实现的关键部分。这个看起来很简单的方法就是所有HTTP工作发生的地方，产生满足请求的响应。</p>
<p>拦截器可以被链接。假设你有一个压缩拦截器和一个校验和拦截器：你需要决定数据是压缩的，然后进行校验和，或者校验和压缩。OkHttp使用列表来跟踪拦截器，拦截器是按顺序调用的。<br><img src="https://raw.githubusercontent.com/wiki/square/okhttp/interceptors@2x.png" alt=""></p>
<h4 id="应用程序拦截器"><a href="#应用程序拦截器" class="headerlink" title="应用程序拦截器"></a>应用程序拦截器</h4><p>拦截器可以注册为应用拦截器或网络拦截器。我们将使用<code>LoggingInterceptor</code>来区别。</p>
<p>通过在<code>OkHttpClient.Builder</code>上调用<code>addInterceptor（）</code>来注册应用程序拦截器：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">    .addInterceptor(<span class="keyword">new</span> LoggingInterceptor())</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">    .url(<span class="string">"http://www.publicobject.com/helloworld.txt"</span>)</span><br><span class="line">    .header(<span class="string">"User-Agent"</span>, <span class="string">"OkHttp Example"</span>)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">Response response = client.newCall(request).execute();</span><br><span class="line">response.body().close();</span><br></pre></td></tr></table></figure></p>
<p>该URL：<a href="http://www.publicobject.com/helloworld.txt" target="_blank" rel="noopener">http://www.publicobject.com/helloworld.txt</a> 重定向到<a href="https://publicobject.com/helloworld.txt" target="_blank" rel="noopener">https://publicobject.com/helloworld.txt</a>, OkHttp自动重定向。我们的应用程序拦截器被调用一次，返回的响应chain.proceed()具有重定向的响应：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">INFO: Sending request http:<span class="comment">//www.publicobject.com/helloworld.txt on null</span></span><br><span class="line">User-Agent: OkHttp Example</span><br><span class="line"></span><br><span class="line">INFO: Received response <span class="keyword">for</span> https:<span class="comment">//publicobject.com/helloworld.txt in 1179.7ms</span></span><br><span class="line">Server: nginx/<span class="number">1.4</span>.6 (Ubuntu)</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Length: <span class="number">1759</span></span><br><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到，我们被重定向了，因为<code>response.request().url()</code>不同于<code>request.url()</code>。这两个日志语句记录两个不同的URL。</p>
<h4 id="网络拦截器"><a href="#网络拦截器" class="headerlink" title="网络拦截器"></a>网络拦截器</h4><p>注册网络拦截器很类似。调用<code>addNetworkInterceptor()</code>代替<code>addInterceptor()</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">    .addNetworkInterceptor(<span class="keyword">new</span> LoggingInterceptor())</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">    .url(<span class="string">"http://www.publicobject.com/helloworld.txt"</span>)</span><br><span class="line">    .header(<span class="string">"User-Agent"</span>, <span class="string">"OkHttp Example"</span>)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">Response response = client.newCall(request).execute();</span><br><span class="line">response.body().close();</span><br></pre></td></tr></table></figure></p>
<p>当我们运行这个代码时，拦截器运行两次。一次为最初的请求<code>http://www.publicobject.com/helloworld.txt</code>，另一个为重定向<code>https://publicobject.com/helloworld.txt</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">INFO: Sending request http:<span class="comment">//www.publicobject.com/helloworld.txt on Connection&#123;www.publicobject.com:80, proxy=DIRECT hostAddress=54.187.32.157 cipherSuite=none protocol=http/1.1&#125;</span></span><br><span class="line">User-Agent: OkHttp Example</span><br><span class="line">Host: www.publicobject.com</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Accept-Encoding: gzip</span><br><span class="line"></span><br><span class="line">INFO: Received response <span class="keyword">for</span> http:<span class="comment">//www.publicobject.com/helloworld.txt in 115.6ms</span></span><br><span class="line">Server: nginx/<span class="number">1.4</span>.6 (Ubuntu)</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: <span class="number">193</span></span><br><span class="line">Connection: keep-alive</span><br><span class="line">Location: https:<span class="comment">//publicobject.com/helloworld.txt</span></span><br><span class="line"></span><br><span class="line">INFO: Sending request https:<span class="comment">//publicobject.com/helloworld.txt on Connection&#123;publicobject.com:443, proxy=DIRECT hostAddress=54.187.32.157 cipherSuite=TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA protocol=http/1.1&#125;</span></span><br><span class="line">User-Agent: OkHttp Example</span><br><span class="line">Host: publicobject.com</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Accept-Encoding: gzip</span><br><span class="line"></span><br><span class="line">INFO: Received response <span class="keyword">for</span> https:<span class="comment">//publicobject.com/helloworld.txt in 80.9ms</span></span><br><span class="line">Server: nginx/<span class="number">1.4</span>.6 (Ubuntu)</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Length: <span class="number">1759</span></span><br><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure></p>
<p>网络请求还包含很多数据，如<code>OkHttp</code>加入<code>Accept-Encoding: gzip</code>头部通知支持压缩响应。网络拦截器的链具有非空的连接，它可用于询问IP地址和连接到网络服务器的TLS配置。</p>
<h4 id="应用程序和网络拦截之间进行选择"><a href="#应用程序和网络拦截之间进行选择" class="headerlink" title="应用程序和网络拦截之间进行选择"></a>应用程序和网络拦截之间进行选择</h4><p>每个拦截器链(interceptor chain)都具有相对优势。</p>
<h5 id="应用拦截器"><a href="#应用拦截器" class="headerlink" title="应用拦截器"></a>应用拦截器</h5><ul>
<li>不必担心像重定向和重试的中间响应。</li>
<li>总是被调用一次，即使HTTP响应来自缓存服务。</li>
<li>观察应用程序的原意。不关心OkHttp注入的头文件，如 If-None-Match。</li>
<li>允许短路和不调用Chain.proceed（） 。</li>
<li>允许重试，并多次调用Chain.proceed（） 。</li>
</ul>
<h5 id="网络拦截器-1"><a href="#网络拦截器-1" class="headerlink" title="网络拦截器"></a>网络拦截器</h5><ul>
<li>能够操作像重定向和重试的中间响应。</li>
<li>在短路网络上不调用缓存的响应。</li>
<li>观察在网络上传输的数据。</li>
<li>访问Connection承载请求。</li>
</ul>
<h4 id="重写请求-1"><a href="#重写请求-1" class="headerlink" title="重写请求"></a>重写请求</h4><p>拦截器可以添加，删除或替换请求头。他们还可以转换请求体。例如，如果你连接到已知支持它的网络服务器，你可以使用应用程序拦截器添加请求体的压缩。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** This interceptor compresses the HTTP request body. Many webservers can't handle this! */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">GzipRequestInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Interceptor.Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Request originalRequest = chain.request();</span><br><span class="line">    <span class="keyword">if</span> (originalRequest.body() == <span class="keyword">null</span> || originalRequest.header(<span class="string">"Content-Encoding"</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> chain.proceed(originalRequest);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Request compressedRequest = originalRequest.newBuilder()</span><br><span class="line">        .header(<span class="string">"Content-Encoding"</span>, <span class="string">"gzip"</span>)</span><br><span class="line">        .method(originalRequest.method(), gzip(originalRequest.body()))</span><br><span class="line">        .build();</span><br><span class="line">    <span class="keyword">return</span> chain.proceed(compressedRequest);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> RequestBody <span class="title">gzip</span><span class="params">(<span class="keyword">final</span> RequestBody body)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RequestBody() &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> MediaType <span class="title">contentType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> body.contentType();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">contentLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// We don't know the compressed length in advance!</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeTo</span><span class="params">(BufferedSink sink)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedSink gzipSink = Okio.buffer(<span class="keyword">new</span> GzipSink(sink));</span><br><span class="line">        body.writeTo(gzipSink);</span><br><span class="line">        gzipSink.close();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="重写响应-1"><a href="#重写响应-1" class="headerlink" title="重写响应"></a>重写响应</h4><p>相对应的，拦截器也可以重写响应头和转换响应体。通常不要重写请求头，因为它可能违反了Web服务器的期望导致更危险！</p>
<p>在一个棘手的情况下，如果已经做好应对的后果，重写响应头是解决问题的有效方式。例如，您可以修复服务器的配置错误的Cache-Control响应头以便更好地响应缓存：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Dangerous interceptor that rewrites the server's cache-control header. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Interceptor REWRITE_CACHE_CONTROL_INTERCEPTOR = <span class="keyword">new</span> Interceptor() &#123;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Interceptor.Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Response originalResponse = chain.proceed(chain.request());</span><br><span class="line">    <span class="keyword">return</span> originalResponse.newBuilder()</span><br><span class="line">        .header(<span class="string">"Cache-Control"</span>, <span class="string">"max-age=60"</span>)</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>通常此方法效果最好，它补充了在Web服务器上相应的修复！</p>
<h4 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h4><p>OkHttp的拦截器需要OkHttp 2.2或更高版本。不幸的是，拦截器不适<code>OkUrlFactory</code>用于构建它的库，包括<a href="http://square.github.io/retrofit/" target="_blank" rel="noopener">Retrofit≤1.8</a>和<a href="http://square.github.io/picasso/" target="_blank" rel="noopener">Picasso≤2.4</a>。</p>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>OkHttp试图平衡两个相互竞争的担忧：</p>
<ul>
<li>连接到尽可能多的主机。这包括运行最新版本的<a href="https://boringssl.googlesource.com/boringssl/" target="_blank" rel="noopener">boringssl</a>的高级主机，以及运行旧版本<a href="https://www.openssl.org/" target="_blank" rel="noopener">OpenSSL</a>的过时主机。</li>
<li>连接的安全性。这包括验证具有证书的远程网络服务器以及与强密码交换的数据的私密性。<br>协商连接到HTTPS服务器时，OkHttp需要知道提供哪些<a href="http://square.github.io/okhttp/3.x/okhttp/okhttp3/TlsVersion.html" target="_blank" rel="noopener">TLS</a>版本和<a href="http://square.github.io/okhttp/3.x/okhttp/okhttp3/CipherSuite.html" target="_blank" rel="noopener">密码套件</a>。希望最大化连接的客户端将包括过时的TLS版本和弱设计密码套件。一个想要最大限度地提高安全性的严格的客户端将仅限于最新的TLS版本和最强的密码套件。</li>
</ul>
<p><a href="http://square.github.io/okhttp/3.x/okhttp/okhttp3/ConnectionSpec.html" target="_blank" rel="noopener">ConnectionSpec</a>实现特定的安全性和连接性决定。OkHttp包含三个内置的连接规范：</p>
<ul>
<li><code>MODERN_TLS</code>是连接到现代HTTPS服务器的安全配置。</li>
<li><code>COMPATIBLE_TLS</code>是一种连接到安全但不是当前HTTPS服务器的安全配置。</li>
<li><code>CLEARTEXT</code>是用于<code>http://</code>URL 的不安全配置。</li>
</ul>
<p>默认情况下，OkHttp将尝试<code>MODERN_TLS</code>连接，<code>COMPATIBLE_TLS</code>如果现代配置失败，则回退连接。</p>
<p>每个规范中的TLS版本和密码套件可随每个版本而改变。例如，在OkHttp 2.2中，我们放弃了对SSL 3.0的支持来响应<code>POODLE</code>攻击。而在OkHttp 2.3我们放弃了对<code>RC4</code>的支持。与您的桌面网络浏览器一样，保持OkHttp的最新状态是保持安全的最佳方式。</p>
<p>您可以使用自定义的TLS版本和密码套件来构建自己的连接规范。例如，这种配置仅限于三个备受好评的密码套件。它的缺点是它需要Android 5.0+和一个类似的当前网络服务器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ConnectionSpec spec = <span class="keyword">new</span> ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)  </span><br><span class="line">    .tlsVersions(TlsVersion.TLS_1_2)</span><br><span class="line">    .cipherSuites(</span><br><span class="line">          CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,</span><br><span class="line">          CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,</span><br><span class="line">          CipherSuite.TLS_DHE_RSA_WITH_AES_128_GCM_SHA256)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient.Builder() </span><br><span class="line">    .connectionSpecs(Collections.singletonList(spec))</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>
<h4 id="证书锁定"><a href="#证书锁定" class="headerlink" title="证书锁定"></a>证书锁定</h4><p>默认情况下，OkHttp信任主机平台的证书权限。这一战略最大限度地提高了连接性，但是它受到证书颁发机构的攻击，例如[<a href="http://www.computerworld.com/article/2510951/cybercrime-hacking/hackers-spied-on-300-000-iranians-using-fake-google-certificate.html" target="_blank" rel="noopener">2011年DigiNotar攻击</a>。它还假定您的HTTPS服务器的证书由证书颁发机构签名。</p>
<p>使用<a href="http://square.github.io/okhttp/3.x/okhttp/okhttp3/CertificatePinner.html" target="_blank" rel="noopener">CertificatePinner</a>来限制哪些证书和证书颁发机构是可信的。证书固定增加了安全性，但是限制了您的服务器团队更新其TLS证书的能力。<strong>如果没有服务器的TLS管理员的同意，请勿使用证书锁定！</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CertificatePinning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  client = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">      .certificatePinner(<span class="keyword">new</span> CertificatePinner.Builder()</span><br><span class="line">          .add(<span class="string">"publicobject.com"</span>, <span class="string">"sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig="</span>)</span><br><span class="line">          .build())</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">      .url(<span class="string">"https://publicobject.com/robots.txt"</span>)</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">  Response response = client.newCall(request).execute();</span><br><span class="line">  <span class="keyword">if</span> (!response.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (Certificate certificate : response.handshake().peerCertificates()) &#123;</span><br><span class="line">    System.out.println(CertificatePinner.pin(certificate));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="自定义可信证书"><a href="#自定义可信证书" class="headerlink" title="自定义可信证书"></a>自定义可信证书</h4><p>完整的代码示例显示了如何用自己的集合替换主机平台的证书颁发机构。如上所述，<strong>请勿在没有服务器的TLS管理员同意的情况下使用自定义证书！</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CustomTrust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  SSLContext sslContext = sslContextForTrustedCertificates(trustedCertificatesInputStream());</span><br><span class="line">  client = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">      .sslSocketFactory(sslContext.getSocketFactory())</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">      .url(<span class="string">"https://publicobject.com/helloworld.txt"</span>)</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">  Response response = client.newCall(request).execute();</span><br><span class="line">  System.out.println(response.body().string());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> InputStream <span class="title">trustedCertificatesInputStream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ... <span class="comment">// Full source omitted. See sample.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> SSLContext <span class="title">sslContextForTrustedCertificates</span><span class="params">(InputStream in)</span> </span>&#123;</span><br><span class="line">  ... <span class="comment">// Full source omitted. See sample.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Events-事件监听"><a href="#Events-事件监听" class="headerlink" title="Events(事件监听)"></a>Events(事件监听)</h3><p>事件允许您在应用程序的HTTP调用中捕获度量值。使用事件进行监视：</p>
<ul>
<li>HTTP调用您的应用程序的大小和频率。如果你声明了太多的calls，或者你的calls太大，你应该知道它的一切</li>
<li>这些调用在底层网络上的性能。如果网络性能不足，则需要改善网络或少用网络。</li>
</ul>
<p><strong>警告：这是一个非最终的API。<br>从OkHttp 3.9开始，此功能是一个不稳定的预览：API可能会更改，并且实现不完整。我们预计OkHttp 3.10或3.11将完成这个API。在此之前，当您更新您的OkHttp依赖关系时，请准备API和行为更改。</strong></p>
<h4 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h4><p>子类<a href="https://square.github.io/okhttp/3.x/okhttp/okhttp3/EventListener.html" target="_blank" rel="noopener"> EventListener</a>,覆盖您感兴趣的事件的方法。在没有重定向或重试的成功HTTP调用中，事件序列由此流程描述。<br><img src="https://raw.githubusercontent.com/wiki/square/okhttp/events@2x.png" alt=""><br>以下是一个<a href="https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/PrintEventsNonConcurrent.java" target="_blank" rel="noopener">示例事件侦听器</a>，它使用时间戳打印每个事件。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintingEventListener</span> <span class="keyword">extends</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> callStartNanos;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printEvent</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> nowNanos = System.nanoTime();</span><br><span class="line">    <span class="keyword">if</span> (name.equals(<span class="string">"callStart"</span>)) &#123;</span><br><span class="line">      callStartNanos = nowNanos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> elapsedNanos = nowNanos - callStartNanos;</span><br><span class="line">    System.out.printf(<span class="string">"%.3f %s%n"</span>, elapsedNanos / <span class="number">1000000000</span>d, name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callStart</span><span class="params">(Call call)</span> </span>&#123;</span><br><span class="line">    printEvent(<span class="string">"callStart"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callEnd</span><span class="params">(Call call)</span> </span>&#123;</span><br><span class="line">    printEvent(<span class="string">"callEnd"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dnsStart</span><span class="params">(Call call, String domainName)</span> </span>&#123;</span><br><span class="line">    printEvent(<span class="string">"dnsStart"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dnsEnd</span><span class="params">(Call call, String domainName, List&lt;InetAddress&gt; inetAddressList)</span> </span>&#123;</span><br><span class="line">    printEvent(<span class="string">"dnsEnd"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们做几个calls：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">    .url(<span class="string">"https://publicobject.com/helloworld.txt"</span>)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"REQUEST 1 (new connection)"</span>);</span><br><span class="line"><span class="keyword">try</span> (Response response = client.newCall(request).execute()) &#123;</span><br><span class="line">  <span class="comment">// Consume and discard the response body.</span></span><br><span class="line">  response.body().source().readByteString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"REQUEST 2 (pooled connection)"</span>);</span><br><span class="line"><span class="keyword">try</span> (Response response = client.newCall(request).execute()) &#123;</span><br><span class="line">  <span class="comment">// Consume and discard the response body.</span></span><br><span class="line">  response.body().source().readByteString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>监听器打印相应的事件：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">REQUEST <span class="number">1</span> (<span class="keyword">new</span> connection)</span><br><span class="line"><span class="number">0.000</span> callStart</span><br><span class="line"><span class="number">0.010</span> dnsStart</span><br><span class="line"><span class="number">0.017</span> dnsEnd</span><br><span class="line"><span class="number">0.025</span> connectStart</span><br><span class="line"><span class="number">0.117</span> secureConnectStart</span><br><span class="line"><span class="number">0.586</span> secureConnectEnd</span><br><span class="line"><span class="number">0.586</span> connectEnd</span><br><span class="line"><span class="number">0.587</span> connectionAcquired</span><br><span class="line"><span class="number">0.588</span> requestHeadersStart</span><br><span class="line"><span class="number">0.590</span> requestHeadersEnd</span><br><span class="line"><span class="number">0.591</span> responseHeadersStart</span><br><span class="line"><span class="number">0.675</span> responseHeadersEnd</span><br><span class="line"><span class="number">0.676</span> responseBodyStart</span><br><span class="line"><span class="number">0.679</span> responseBodyEnd</span><br><span class="line"><span class="number">0.679</span> connectionReleased</span><br><span class="line"><span class="number">0.680</span> callEnd</span><br><span class="line">REQUEST <span class="number">2</span> (pooled connection)</span><br><span class="line"><span class="number">0.000</span> callStart</span><br><span class="line"><span class="number">0.001</span> connectionAcquired</span><br><span class="line"><span class="number">0.001</span> requestHeadersStart</span><br><span class="line"><span class="number">0.001</span> requestHeadersEnd</span><br><span class="line"><span class="number">0.002</span> responseHeadersStart</span><br><span class="line"><span class="number">0.082</span> responseHeadersEnd</span><br><span class="line"><span class="number">0.082</span> responseBodyStart</span><br><span class="line"><span class="number">0.082</span> responseBodyEnd</span><br><span class="line"><span class="number">0.083</span> connectionReleased</span><br><span class="line"><span class="number">0.083</span> callEnd</span><br></pre></td></tr></table></figure></p>
<p>注意第二次调用没有连接事件。它重用了第一个请求的连接，以显着提高性能。</p>
<h4 id="EventListener-Factory"><a href="#EventListener-Factory" class="headerlink" title="EventListener.Factory"></a>EventListener.Factory</h4><p>在前面的例子中，我们使用了一个字段<code>callStartNanos</code>来跟踪每个事件的经过时间。这很方便，但是如果多个调用同时执行，它将不起作用。为了适应这个，使用一个<code>Factory</code>创建一个新的<code>EventListener</code>为每个<code>Call</code>。这允许每个监听者保持特定于呼叫的状态。</p>
<p>此<a href="https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/PrintEvents.java" target="_blank" rel="noopener">示例工厂</a>为每个呼叫创建一个唯一的ID，并使用该ID区分日志消息中的呼叫。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintingEventListener</span> <span class="keyword">extends</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Factory FACTORY = <span class="keyword">new</span> Factory() &#123;</span><br><span class="line">    <span class="keyword">final</span> AtomicLong nextCallId = <span class="keyword">new</span> AtomicLong(<span class="number">1L</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> EventListener <span class="title">create</span><span class="params">(Call call)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">long</span> callId = nextCallId.getAndIncrement();</span><br><span class="line">      System.out.printf(<span class="string">"%04d %s%n"</span>, callId, call.request().url());</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> PrintingEventListener(callId, System.nanoTime());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">long</span> callId;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">long</span> callStartNanos;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PrintingEventListener</span><span class="params">(<span class="keyword">long</span> callId, <span class="keyword">long</span> callStartNanos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.callId = callId;</span><br><span class="line">    <span class="keyword">this</span>.callStartNanos = callStartNanos;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printEvent</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> elapsedNanos = System.nanoTime() - callStartNanos;</span><br><span class="line">    System.out.printf(<span class="string">"%04d %.3f %s%n"</span>, callId, elapsedNanos / <span class="number">1000000000</span>d, name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callStart</span><span class="params">(Call call)</span> </span>&#123;</span><br><span class="line">    printEvent(<span class="string">"callStart"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callEnd</span><span class="params">(Call call)</span> </span>&#123;</span><br><span class="line">    printEvent(<span class="string">"callEnd"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以使用这个侦听器来竞争一对并发的HTTP请求：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Request washingtonPostRequest = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">    .url(<span class="string">"https://www.washingtonpost.com/"</span>)</span><br><span class="line">    .build();</span><br><span class="line">client.newCall(washingtonPostRequest).enqueue(<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Request newYorkTimesRequest = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">    .url(<span class="string">"https://www.nytimes.com/"</span>)</span><br><span class="line">    .build();</span><br><span class="line">client.newCall(newYorkTimesRequest).enqueue(<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>运行这场比赛的家庭无线网络显示，Times（<code>0002</code>）比Post（<code>0001</code>）略快一点：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0001</span> https:<span class="comment">//www.washingtonpost.com/</span></span><br><span class="line"><span class="number">0001</span> <span class="number">0.000</span> callStart</span><br><span class="line"><span class="number">0002</span> https:<span class="comment">//www.nytimes.com/</span></span><br><span class="line"><span class="number">0002</span> <span class="number">0.000</span> callStart</span><br><span class="line"><span class="number">0002</span> <span class="number">0.010</span> dnsStart</span><br><span class="line"><span class="number">0001</span> <span class="number">0.013</span> dnsStart</span><br><span class="line"><span class="number">0001</span> <span class="number">0.022</span> dnsEnd</span><br><span class="line"><span class="number">0002</span> <span class="number">0.019</span> dnsEnd</span><br><span class="line"><span class="number">0001</span> <span class="number">0.028</span> connectStart</span><br><span class="line"><span class="number">0002</span> <span class="number">0.025</span> connectStart</span><br><span class="line"><span class="number">0002</span> <span class="number">0.072</span> secureConnectStart</span><br><span class="line"><span class="number">0001</span> <span class="number">0.075</span> secureConnectStart</span><br><span class="line"><span class="number">0001</span> <span class="number">0.386</span> secureConnectEnd</span><br><span class="line"><span class="number">0002</span> <span class="number">0.390</span> secureConnectEnd</span><br><span class="line"><span class="number">0002</span> <span class="number">0.400</span> connectEnd</span><br><span class="line"><span class="number">0001</span> <span class="number">0.403</span> connectEnd</span><br><span class="line"><span class="number">0002</span> <span class="number">0.401</span> connectionAcquired</span><br><span class="line"><span class="number">0001</span> <span class="number">0.404</span> connectionAcquired</span><br><span class="line"><span class="number">0001</span> <span class="number">0.406</span> requestHeadersStart</span><br><span class="line"><span class="number">0002</span> <span class="number">0.403</span> requestHeadersStart</span><br><span class="line"><span class="number">0001</span> <span class="number">0.414</span> requestHeadersEnd</span><br><span class="line"><span class="number">0002</span> <span class="number">0.411</span> requestHeadersEnd</span><br><span class="line"><span class="number">0002</span> <span class="number">0.412</span> responseHeadersStart</span><br><span class="line"><span class="number">0001</span> <span class="number">0.415</span> responseHeadersStart</span><br><span class="line"><span class="number">0002</span> <span class="number">0.474</span> responseHeadersEnd</span><br><span class="line"><span class="number">0002</span> <span class="number">0.475</span> responseBodyStart</span><br><span class="line"><span class="number">0001</span> <span class="number">0.554</span> responseHeadersEnd</span><br><span class="line"><span class="number">0001</span> <span class="number">0.555</span> responseBodyStart</span><br><span class="line"><span class="number">0002</span> <span class="number">0.554</span> responseBodyEnd</span><br><span class="line"><span class="number">0002</span> <span class="number">0.554</span> connectionReleased</span><br><span class="line"><span class="number">0002</span> <span class="number">0.554</span> callEnd</span><br><span class="line"><span class="number">0001</span> <span class="number">0.624</span> responseBodyEnd</span><br><span class="line"><span class="number">0001</span> <span class="number">0.624</span> connectionReleased</span><br><span class="line"><span class="number">0001</span> <span class="number">0.624</span> callEnd</span><br></pre></td></tr></table></figure></p>
<p>该<code>EventListener.Factory</code>还能够指标限制呼叫的子集。这一个随机捕获指标为10％：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MetricsEventListener</span> <span class="keyword">extends</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Factory FACTORY = <span class="keyword">new</span> Factory() &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> EventListener <span class="title">create</span><span class="params">(Call call)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (Math.random() &lt; <span class="number">0.10</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MetricsEventListener(call);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> EventListener.NONE;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="事件与失败"><a href="#事件与失败" class="headerlink" title="事件与失败"></a>事件与失败</h4><p>当操作失败时，调用失败方法。这是<code>connectFailed()</code>在建立到服务器的连接<code>callFailed()</code>时，以及HTTP调用永久失败时的失败。发生故障时，<code>start</code>事件可能没有相应的<code>end</code>事件。<br><img src="https://raw.githubusercontent.com/wiki/square/okhttp/events_with_failures@2x.png" alt=""></p>
<h4 id="事件与重试和跟进"><a href="#事件与重试和跟进" class="headerlink" title="事件与重试和跟进"></a>事件与重试和跟进</h4><p>OkHttp具有弹性，可以自动从一些连接失败中恢复。在这种情况下，<code>connectFailed()</code>事件不是终端，也不是随之而来的<code>callFailed()</code>。当尝试重试时，事件监听器将收到多个相同类型的事件。</p>
<p>单个HTTP调用可能需要后续请求来处理认证挑战，重定向和HTTP层超时。在这种情况下，可能会尝试多个连接，请求和响应。跟进是单个电话可能触发多个相同类型事件的另一个原因。<br><img src="https://raw.githubusercontent.com/wiki/square/okhttp/events_with_failures_and_retries@2x.png" alt=""></p>
<h4 id="可用性-1"><a href="#可用性-1" class="headerlink" title="可用性"></a>可用性</h4><p>OkHttp 3.9中的预览版本提供了事件。我们预计OkHttp 3.10或3.11将完成这个API。未来版本可能会引入新的事件类型; 您将需要覆盖相应的方法来处理它们。</p>
<h3 id="FAQs-常见问题解答"><a href="#FAQs-常见问题解答" class="headerlink" title="FAQs(常见问题解答))"></a>FAQs(常见问题解答))</h3><h4 id="如何修复dalvikvm中的验证警告？"><a href="#如何修复dalvikvm中的验证警告？" class="headerlink" title="如何修复dalvikvm中的验证警告？"></a>如何修复dalvikvm中的验证警告？</h4><p>OkHttp支持一些需要Java 7+或Android API 20+的API。如果你在早期的Android版本上运行OkHttp，dalvikvm的验证器会警告你缺少的方法。这不是一个问题，你可以忽略警告。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">I/dalvikvm﹕ Could not find method okhttp3.internal.huc.HttpURLConnectionImpl.getContentLengthLong, referenced from method okhttp3.internal.huc.HttpsURLConnectionImpl.getContentLengthLong</span><br><span class="line">W/dalvikvm﹕ VFY: unable to resolve virtual method <span class="number">21498</span>: Lokhttp3/internal/huc/HttpURLConnectionImpl;.getContentLengthLong ()J</span><br><span class="line">D/dalvikvm﹕ VFY: replacing opcode <span class="number">0x6e</span> at <span class="number">0x0002</span></span><br><span class="line">I/dalvikvm﹕ Could not find method okhttp3.internal.huc.HttpURLConnectionImpl.getHeaderFieldLong, referenced from method okhttp3.internal.huc.HttpsURLConnectionImpl.getHeaderFieldLong</span><br><span class="line">W/dalvikvm﹕ VFY: unable to resolve virtual method <span class="number">21503</span>: Lokhttp3/internal/huc/HttpURLConnectionImpl;.getHeaderFieldLong (Ljava/lang/String;J)J</span><br><span class="line">D/dalvikvm﹕ VFY: replacing opcode <span class="number">0x6e</span> at <span class="number">0x0002</span></span><br><span class="line">W/dalvikvm﹕ VFY: <span class="function">unable to find class referenced in <span class="title">signature</span> <span class="params">(Ljava/nio/file/Path;)</span></span></span><br><span class="line"><span class="function">W/dalvikvm﹕ VFY: unable to find class referenced in <span class="title">signature</span> <span class="params">([Ljava/nio/file/OpenOption;)</span></span></span><br><span class="line"><span class="function">I/dalvikvm﹕ Could not find method java.nio.file.Files.newOutputStream, referenced from method okio.Okio.sink</span></span><br><span class="line"><span class="function">W/dalvikvm﹕ VFY: unable to resolve <span class="keyword">static</span> method 24080: Ljava/nio/file/Files</span>;.newOutputStream (Ljava/nio/file/Path;[Ljava/nio/file/OpenOption;)Ljava/io/OutputStream;</span><br><span class="line">D/dalvikvm﹕ VFY: replacing opcode <span class="number">0x71</span> at <span class="number">0x000a</span></span><br><span class="line">W/dalvikvm﹕ VFY: <span class="function">unable to find class referenced in <span class="title">signature</span> <span class="params">(Ljava/nio/file/Path;)</span></span></span><br><span class="line"><span class="function">W/dalvikvm﹕ VFY: unable to find class referenced in <span class="title">signature</span> <span class="params">([Ljava/nio/file/OpenOption;)</span></span></span><br><span class="line"><span class="function">I/dalvikvm﹕ Could not find method java.nio.file.Files.newInputStream, referenced from method okio.Okio.source</span></span><br><span class="line"><span class="function">W/dalvikvm﹕ VFY: unable to resolve <span class="keyword">static</span> method 24079: Ljava/nio/file/Files</span>;.newInputStream (Ljava/nio/file/Path;[Ljava/nio/file/OpenOption;)Ljava/io/InputStream;</span><br><span class="line">D/dalvikvm﹕ VFY: replacing opcode <span class="number">0x71</span> at <span class="number">0x000a</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 安卓开源库使用教程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> okhttp3 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Studio使用技巧和资源]]></title>
      <url>/AndroidStudio_uses_skills_and_resources.html</url>
      <content type="html"><![CDATA[<p><strong>版权声明：本文转载自:<a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/1116/6776.html" target="_blank" rel="noopener">http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/1116/6776.html</a>.</strong></p>
<hr>
<blockquote>
<p>对于AndroidStudio的使用，日常使用没问题，但依旧有些快捷技巧没有习惯使用,因此转载本篇文章常读，希望对文章的技巧有些记忆，做到以后的熟练使用</p>
</blockquote>
<a id="more"></a>
<p>本文列举出一些可以提高整体效率的Android Studio技巧和资源。</p>
<p>显然有太多太多这方面的东西，但是为了文章的简洁性，我把它限制在50个以内，希望你能喜欢！</p>
<h3 id="视觉效果"><a href="#视觉效果" class="headerlink" title="视觉效果"></a>视觉效果</h3><p><strong>1.Android Logcat的Material颜色主题。</strong><br><img src="http://www.jcodecraeer.com/uploads/20161114/1479092916140309.png" alt=""><br>要改变Android Studio的Logcat你需要这样做：进入Preferences (Windows上是Settings / Linux machines) → Editor → Colors &amp; Fonts → Android Logcat，然后为每种类型的log设置前景颜色（foreground）。</p>
<p>我使用的material颜色：</p>
<p>Assert #BA68C8<br>Debug #2196F3<br>Error #F44336<br>Info #4CAF50<br>Verbose #BBBBBB<br>Warning #FF9800<br>注意里面有几个现有的主题，可以直接修改现有主题（不建议），或者点击save  as按钮拷贝一个主题并改名为Material theme Color然后再改变每种类型log的颜色。</p>
<p><strong>2.防止当前应用崩溃时Logcat清除log。</strong></p>
<p>在Android Monitor面板的右上方点击下拉菜单中的Edit filter configuration：<br><img src="http://www.jcodecraeer.com/uploads/20161114/1479110913240289.gif" alt=""><br>注意是在工程界面的底部Android Monitor面板，而不是单独的Android Monitor工具中。</p>
<p><strong>3.使用一个适合自己的代码主题 (IntelliJ / Android Studio).</strong></p>
<p>找到Preferences → Code Style → Java，在Scheme下拉菜单中你可以选择一个代码风格（或者设置一个新的）。</p>
<p>有两个风格值得专门提一下：</p>
<ul>
<li><a href="https://github.com/square/java-code-styles" target="_blank" rel="noopener">Square Java Code Styles with Android</a></li>
<li><a href="https://github.com/google/styleguide/blob/gh-pages/intellij-java-google-style.xml" target="_blank" rel="noopener">Google Java Code Style</a></li>
</ul>
<p>你可以按照下面gif图中的做法导入主题：<br><img src="http://www.jcodecraeer.com/uploads/20161115/1479152735132116.gif" alt=""></p>
<p><strong>.使用分屏提高效率</strong><br><img src="http://www.jcodecraeer.com/uploads/20161115/1479184670241838.png" alt=""></p>
<p>要打开这个功能，右键主屏幕的选项卡（tab）选择 Split Vertically / Horizontally。<br><img src="http://www.jcodecraeer.com/uploads/20161115/1479185280137120.png" alt=""><br>但是为了尽量提高效率我们需要设置一个自定义的快捷方式。为此找到到Preferences → Keymap，搜索Split Vertically。然后打开一个上下文菜单，点击Add Keyboard Shortcut。</p>
<p>我的分屏（vertical）快捷键设置的是control + alt + v。做法如下面的gif图所示。同样的你还可以为 horizontal split设置快捷键。<br><img src="http://www.jcodecraeer.com/uploads/20161115/1479186609392277.gif" alt=""></p>
<p><strong>5.无干扰模式</strong><br>你可以到View → Enter Distraction Free Mode里启用它<br><img src="http://www.jcodecraeer.com/uploads/20161115/1479186797587469.png" alt=""></p>
<blockquote>
<p>在无干扰模式下，编辑器占据了整个IntelliJIDEA窗口，没有任何tab或者工具按钮。代码居中显示<br><img src="http://www.jcodecraeer.com/uploads/20161115/1479187051576195.png" alt=""></p>
</blockquote>
<p><strong>6.使用Live Templates</strong></p>
<ul>
<li>你可以使用快捷键：cmd + j (Windows / Linux: ctrl + j)。<br><img src="http://www.jcodecraeer.com/uploads/20161115/1479207132117532.gif" alt=""></li>
<li>可以使用已经定义好了的Live Templates，比如Toasts 或者if语句。<br><img src="http://www.jcodecraeer.com/uploads/20161115/1479207307260987.gif" alt=""></li>
<li>可以使用自定义的templates。这里是Reto Meier的一篇不错的参考文章。你也可以参考<a href="https://www.jetbrains.com/help/idea/2016.2/live-templates.html" target="_blank" rel="noopener">IntelliJ IDEA</a>的文档.</li>
</ul>
<h3 id="快捷键以及有用的命令"><a href="#快捷键以及有用的命令" class="headerlink" title="快捷键以及有用的命令"></a>快捷键以及有用的命令</h3><p>1.最有用的命令是搜索命令的命令：cmd + shift + a (Windows / Linux: ctrl + shift + a)。</p>
<p>假设你想关闭当前tab却不知道怎么做，你只需输入close你就可以得到一个正确的快捷键/命令。</p>
<p>2.选择最近的复制粘贴（管理剪切版）：cmd + shift + v (Windows / Linux: ctrl + shift + v)。<br>默认有5个最近的复制/粘贴元素。<br><img src="http://www.jcodecraeer.com/uploads/20161115/1479209676110910.png" alt=""></p>
<p>3.启用多光标功能：control + g (alt + j for Windows / Linux)。<br><img src="http://www.jcodecraeer.com/uploads/20161115/1479209848645605.gif" alt=""></p>
<p>4.打开一个类： cmd + o (Windows / Linux: ctrl + n)。</p>
<p>5.打开任意文件： cmd + shift + o (Windows / Linux: ctrl + shift + n)。</p>
<p>6.打开symbol：cmd + option + o (Windows / Linux: alt + shift + n)。</p>
<p>7.跳到实现：cmd + option + b (Windows / Linux:<br>ctrl + alt + b)。</p>
<p>假如你有一个interface。通过点击接口的名字，然后按下快捷键就可以跳转到这个接口的实现。如果有多个实现会出现下拉选择。</p>
<p>8.跳转到定义：cmd + b (Windows / Linux: ctrl + b)。</p>
<p>可以让你快速跳转到一个类，方法或者变量被定义的地方。</p>
<p>9.跳转到类型定义处：control + shift + b (Windows / Linux:<br>ctrl + shift + b)。</p>
<p>假设你定义了：</p>
<p>Employee employee = new Employee(“Michal”);</p>
<p>当你的插入符号在employee上，这时你按下快捷键，你将跳转到Employee类中。</p>
<p>10.跳转到super： cmd + u (Windows / Linux: ctrl + u)。</p>
<p>比如，你重写了一些方法,当你的插入符号在方法名上，按下这个快捷键你将跳转到parent的这个方法。</p>
<p>11.Move between tabs: cmd + shift + <a href="move right"> (move left) or cmd + shift + </a> (Windows / Linux: alt + ← / →).</p>
<p>12 Move between Design / Text tabs in layout’s view:<br>control + shift + ← / → (Windows / Linux: alt + shift + ← / →).</p>
<p>13.关闭当前的tab：cmd + w (Windows / Linux: ctrl + shift + a)。</p>
<p>14.隐藏所有窗口：cmd + shift + F12 (Windows / Linux:<br>ctrl + shift + F12)。</p>
<p>15.最小化 Android Studio instance: cmd + m (Windows / Linux:<br>ctrl + m)。</p>
<p>16.格式化代码: cmd + option + l (Windows / Linux:<br>ctrl + alt + l)。</p>
<p>17.Auto-indent lines: control + option + i (Windows / Linux:<br>ctrl + alt + i).</p>
<p>18.实现接口的方法: control + i (Windows / Linux: ctrl + i)。</p>
<p>假设你要实现一个接口。这个快捷键可以让你快速导入这个接口的所有方法。</p>
<p>19.Smart code completion (filters the list of methods and variables by expected type): control + shift + space (Windows / Linux: ctrl + shift + space).</p>
<p>20.查找: cmd + f (Windows / Linux: ctrl + f)。</p>
<p>21.查找并替换: cmd + r (Windows / Linux: ctrl + r)。</p>
<p>22.把一个硬编码的字符串放到资源文件中：option + return (Windows / Linux: alt + enter)。光标必须在这个文字之上时才能使用这个快捷键。看下面的gif图：<br><img src="http://www.jcodecraeer.com/uploads/20161116/1479268452113436.gif" alt=""></p>
<h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>1.<a href="https://plugins.jetbrains.com/plugin/4455" target="_blank" rel="noopener">Key promoter</a> - 快捷键提示插件 当你点击鼠标一个功能的时候,可以提示 你这个功能快捷键是什么 ,和这个按钮你的使用频率 </p>
<p>2.<a href="https://plugins.jetbrains.com/plugin/2162" target="_blank" rel="noopener">String Manipulation</a> - a plugin which provides actions for text manipulation (e.g. toggling styles like camelCase, hyphen-lowercase etc., capitalize text and many more).</p>
<p>3.<a href="https://github.com/konifar/android-material-design-icon-generator-plugin" target="_blank" rel="noopener">Android Material Design Icon Generator</a> -这个插件帮助你为工程添加Material Design图标。安装之后使用快捷键cmd + shift + m生成一个图标。</p>
<p>4.<a href="https://github.com/avast/android-butterknife-zelezny" target="_blank" rel="noopener">ButterKnifeZelezny</a> - 一键从 布局文件中 生成对于的 View 声明和 ButterKnife 注解：<br><img src="http://www.jcodecraeer.com/uploads/20161116/1479269691116405.gif" alt=""></p>
<p>5.<a href="https://github.com/mcharmas/android-parcelable-intellij-plugin" target="_blank" rel="noopener">IntelliJ/Android Studio Plugin for Android Parcelable boilerplate code generation</a> - 一个根据类的成员生成Parcelable的插件。</p>
<p>6.<a href="https://github.com/pbreault/adb-idea" target="_blank" rel="noopener">ADB Idea</a> - 一个帮助你使用adb命令的插件：卸载，杀死，启动，重启，清除数据等命令。</p>
<p>7.<a href="https://www.genymotion.com/plugins/" target="_blank" rel="noopener">Genymotion plugin</a> - 一个让你可以在Android Studio中创建和开启Genymotion虚拟设备的插件。</p>
<p>8.<a href="http://www.methodscount.com/plugins" target="_blank" rel="noopener">Android Methods Count</a> - a plugin that parses your Android library dependencies and shows the methods count as an handy hint.</p>
<p>9.<a href="https://plugins.jetbrains.com/plugin/7315" target="_blank" rel="noopener">Git Flow Integration</a> - a plugin for introducing a Git Flow branching model.</p>
<p>10.<a href="https://plugins.jetbrains.com/plugin/7567" target="_blank" rel="noopener">Builder plugin</a> - a plugin (from Square) that generates a static nested Builder for a class.</p>
<h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p>1.<a href="">Android Studio Tips of the Day by Philippe Breault</a><br>2.<a href="https://developer.android.com/studio/intro/keyboard-shortcuts.html" target="_blank" rel="noopener">快捷键参考</a><br>3.<a href="http://www.jcodecraeer.com/a/anzhuokaifa/Android_Studio/2016/0424/4172.html" target="_blank" rel="noopener">(About) 10 Things You (Probably) Didn’t Know You Could do in Android Studio by Reto Meier。中文版：10个你可能不知道的 Android Studio技巧。 </a><br>4.<a href="https://vimeo.com/98922030
5.[Android Studio Like a Boss by Philippe Breault](https://realm.io/news/360andev-philippe-breault-android-studio-ide-like-boss-structural-search-refactoring-java/" target="_blank" rel="noopener">无鼠标开发 by Hadi Hariri</a><br>6.<a href="https://www.youtube.com/watch?v=Y2GC6P5hPeA" target="_blank" rel="noopener">Android Studio for Experts (Android Dev Summit 2015)</a><br>7.<a href="http://michaelevans.org/blog/2016/01/06/android-studio-tips-and-tricks/" target="_blank" rel="noopener">Android Studio Tips and Tricks by Michael Evans</a><br>8.<a href="https://developer.android.com/studio/intro/index.html" target="_blank" rel="noopener">认识 Android Studio</a><br>9.<a href="http://www.donnfelker.com/android-studio-tips-and-tricks-part-1/" target="_blank" rel="noopener">Android Studio - Tips and Tricks by Donn Felker</a><br>10.<a href="https://developer.android.com/studio/debug/index.html" target="_blank" rel="noopener">Debug Your App with Android Studio</a><br>11.<a href="https://www.reddit.com/r/androiddev/comments/3ktqyb/what_are_some_of_your_musthave_plugins_for/" target="_blank" rel="noopener">What are some of your must-have plugins for - Reddit discussion</a></p>
]]></content>
      
        <categories>
            
            <category> AndroidStudio </category>
            
        </categories>
        
        
        <tags>
            
            <tag> AndroidStudio </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android5.0新控件学习]]></title>
      <url>/Android5-0-control-study-AppBarLayout-Toolbar-CoordinateLayout-cardView.html</url>
      <content type="html"><![CDATA[<p><strong>版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起.</strong></p>
<hr>
<blockquote>
<p>本文记录一些Androd5.0的新控件的一些学习总结，由于网上的博文总结的比较全面，我就不写博文总结了，这里主要是列举一些控件的学习资料</p>
</blockquote>
<a id="more"></a>
<h3 id="CoordinateLayout"><a href="#CoordinateLayout" class="headerlink" title="CoordinateLayout"></a>CoordinateLayout</h3><p>简介：协调布局,配合<code>Behavior</code>使用，特点是能根据一个<code>View</code>的动作协调另一个<code>View</code>的动作。<br>参考文章:<a href="https://www.jianshu.com/p/72d45d1f7d55" target="_blank" rel="noopener">CoordinatorLayout的使用如此简单</a></p>
<h3 id="ToolBar"><a href="#ToolBar" class="headerlink" title="ToolBar"></a>ToolBar</h3><p>简介：代替<code>ActionBar</code>，比它更加的灵活，实质是一个<code>ViewGroup</code></p>
<p>参考资料:<a href="http://blog.csdn.net/lmj623565791/article/details/45303349" target="_blank" rel="noopener">Android 5.x Theme 与 ToolBar 实战</a><br><a href="http://blog.csdn.net/kebi007/article/details/71247295" target="_blank" rel="noopener">xamarin android toolbar(踩坑完全入门详解)</a></p>
<h3 id="AppBarLayout"><a href="#AppBarLayout" class="headerlink" title="AppBarLayout"></a>AppBarLayout</h3><p>简介：继承自<code>LinearLayout</code>,它可以让你定制当某个可滚动<code>View</code>手势发生变化时，其内部子<code>View</code>会实现何种动作.</p>
<h3 id="CollapsingToolbarLayout"><a href="#CollapsingToolbarLayout" class="headerlink" title="CollapsingToolbarLayout"></a>CollapsingToolbarLayout</h3><p>简介：用来对<code>ToolBar</code>进行再次包装的<code>ViewGroup</code>，可以实现一些折叠的效果（更像是缩放），比如向上滑动标题文字逐渐缩小至左上角，它需要作为<code>AppBarLayout</code>布局里面并作为它的直接子<code>View</code>.</p>
<h3 id="NestedScrollView"><a href="#NestedScrollView" class="headerlink" title="NestedScrollView"></a>NestedScrollView</h3><p>简介：为了配合<code>AppBarLayout</code>的滚动效果而编写的滚动控件，继承自<code>FrameLayout</code>,随后使用<code>appbar_scrolling_view_behavior</code>即可实现相应的效果</p>
<p>参考文章:<a href="https://www.jianshu.com/p/d159f0176576" target="_blank" rel="noopener">玩转AppBarLayout，更酷炫的顶部栏</a></p>
<h3 id="CardView"><a href="#CardView" class="headerlink" title="CardView"></a>CardView</h3><p>简介：卡片布局，继承自<code>FrameLayout</code>，可实现阴影效果,通常与<code>RecycleView</code>或<code>ListView</code>配合使用作为<code>item</code>的容器<br>参考资料:<a href="https://www.jianshu.com/p/33b1d21d6ba6" target="_blank" rel="noopener">CardView的基本用法</a></p>
<h3 id="RecyclerView"><a href="#RecyclerView" class="headerlink" title="RecyclerView"></a>RecyclerView</h3><p>简介：比<code>ListView</code>更加灵活，更低耦合的列表展示控件，可轻易实现<code>ListView</code>,<code>GridView</code>,和瀑布流的效果</p>
<p>参考资料:<a href="http://blog.csdn.net/lmj623565791/article/details/45059587" target="_blank" rel="noopener"> Android RecyclerView 使用完全解析 体验艺术般的控件</a></p>
<h3 id="FloatingActionButton"><a href="#FloatingActionButton" class="headerlink" title="FloatingActionButton"></a>FloatingActionButton</h3><p>简介：用来在界面上显示一个悬浮的按钮<br>参考资料：<a href="http://blog.csdn.net/lmj623565791/article/details/46678867" target="_blank" rel="noopener">FloatingActionButton 完全解析[Design Support Library(2)]</a></p>
<h3 id="TextInputLayout"><a href="#TextInputLayout" class="headerlink" title="TextInputLayout"></a>TextInputLayout</h3><p>简介：通常与<code>EditText</code>配合使用，能在<code>EditText</code>输入时将<code>hint</code>放入到上方，还具有空校验的功能</p>
<p>参考资料：<br><a href="https://www.jianshu.com/p/c06b2a41f611" target="_blank" rel="noopener">TextInputlayout入门讲解</a><br><a href="http://blog.csdn.net/u011051627/article/details/48177095" target="_blank" rel="noopener">Android Design TextInputLayout 解析,带你深入TextInputLayout</a></p>
<h3 id="TabLayout"><a href="#TabLayout" class="headerlink" title="TabLayout"></a>TabLayout</h3><p>简介：提供一个水平的布局来展示<code>TAB</code></p>
<p>参考资料：<br><a href="https://www.jianshu.com/p/2b2bb6be83a8" target="_blank" rel="noopener">Design库-TabLayout属性详解</a><br><a href="https://www.jianshu.com/p/be1e8a1da639?nomobile=yes" target="_blank" rel="noopener">TabLayout的高端用法</a></p>
<h3 id="NavigationView"><a href="#NavigationView" class="headerlink" title="NavigationView"></a>NavigationView</h3><p>简介:在<code>Material Design</code>中，<code>Navigation drawer</code>导航抽屉，被设计用于应用导航，提供了一种通用的导航方式，体现了设计的一致性。<br>而<code>NavigationView</code>的典型用途就是配合之前v4包的<code>DrawerLayout</code>，作为其中的<code>Drawer</code>部分，即导航菜单的本体部分。<code>NavigationView</code>是一个导航菜单框架，使用<code>menu</code>资源填充数据，使我们可以更简单高效的实现导航菜单。它提供了不错的默认样式、选中项高亮、分组单选、分组子标题、以及可选的<code>Header</code>。</p>
<p>参考资料：<a href="http://blog.csdn.net/u012702547/article/details/51253222" target="_blank" rel="noopener"> Android5.0之NavigationView的使用</a></p>
<h3 id="Snackbar"><a href="#Snackbar" class="headerlink" title="Snackbar"></a>Snackbar</h3><p>简介：与<code>Toast</code>相似,弹出一个提示框</p>
<p>参考资料：<a href="https://www.jianshu.com/p/cd1e80e64311/" target="_blank" rel="noopener">没时间解释了，快使用Snackbar!——Android Snackbar花式使用指南
</a></p>
<h3 id="Palette"><a href="#Palette" class="headerlink" title="Palette"></a>Palette</h3><p>简介：取色器，从图片中提取关键的颜色，并将该颜色设置到别的控件上,可以和<code>ToolBar</code>配合使用动态改变颜色<br>参考资料:<br><a href="http://blog.csdn.net/u013278099/article/details/49887463" target="_blank" rel="noopener">安卓5.x的Palette之你不知道的事</a></p>
<p><a href="http://blog.csdn.net/bbld_/article/details/41439715" target="_blank" rel="noopener">Android Material Design之Toolbar与Palette实践</a></p>
<h3 id="RippleDrawable"><a href="#RippleDrawable" class="headerlink" title="RippleDrawable"></a>RippleDrawable</h3><p>简介：5.0以上的涟漪效果,需要兼容5.0以下需要使用开源库<a href="https://github.com/traex/RippleEffect" target="_blank" rel="noopener">RippleEffect</a>.<br>参考资料：<a href="http://blog.csdn.net/oqihaogongyuan/article/details/53102615" target="_blank" rel="noopener">Material Design之RippleDrawable详解</a></p>
]]></content>
      
        <categories>
            
            <category> Android基础进阶 </category>
            
            <category> 安卓控件 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android5.0 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一些关于安卓非编码问题的解决方案记录]]></title>
      <url>/%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8E%E5%AE%89%E5%8D%93%E9%9D%9E%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E8%AE%B0%E5%BD%95.html</url>
      <content type="html"><![CDATA[<p><strong>版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起.</strong></p>
<hr>
<blockquote>
<p>安卓的一些非编码问题的一些解决方案记录，如打包，加密等..</p>
</blockquote>
<a id="more"></a>
<h3 id="安卓自动化打包发布工作流-签名加密"><a href="#安卓自动化打包发布工作流-签名加密" class="headerlink" title="安卓自动化打包发布工作流,签名加密"></a>安卓自动化打包发布工作流,签名加密</h3><p>解决方案：<br>可使用Travis CI项目框架</p>
<p>未自动化前安卓开发的工作流程：</p>
<ol>
<li>开发一些新功能，提交代码</li>
<li>完成一部分功能后，打包一个测试版APK</li>
<li>将测试版APK上传到QQ群 / 网盘 / Fir.im / 蒲公英等</li>
<li>在QQ群或发布平台解释当前版本所完成的功能</li>
<li>通知测试人员测试</li>
</ol>
<p>实现了这套自动化发布后，工作流程被简化成：</p>
<ol>
<li>开发新功能，提交代码</li>
<li>通过git tag对代码打一个内测版的tag，在tag的描述中对写当前完成的功能</li>
</ol>
<p>此外还支持签名加密：<br>加密前:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    signingConfigs &#123;</span><br><span class="line">        releaseConfig &#123;</span><br><span class="line">            storeFile file(&quot;../keys/evandroid.jks&quot;)</span><br><span class="line">            storePassword &quot;123456&quot;</span><br><span class="line">            keyAlias &quot;evandroid_alias&quot;</span><br><span class="line">            keyPassword &quot;654321&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled false</span><br><span class="line">            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;</span><br><span class="line">            signingConfig signingConfigs.releaseConfig</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>加密后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">releaseConfig &#123;</span><br><span class="line">    storeFile file(&quot;../keys/evandroid.jks&quot;)</span><br><span class="line">    storePassword project.hasProperty(&quot;KEYSTORE_PASS&quot;) ? KEYSTORE_PASS : System.getenv(&quot;KEYSTORE_PASS&quot;)</span><br><span class="line">    keyAlias project.hasProperty(&quot;ALIAS_NAME&quot;) ? ALIAS_NAME : System.getenv(&quot;ALIAS_NAME&quot;)</span><br><span class="line">    keyPassword project.hasProperty(&quot;ALIAS_PASS&quot;) ? ALIAS_PASS : System.getenv(&quot;ALIAS_PASS&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>密钥完全从后台获取</p>
<p>关于<a href="https://travis-ci.org/" target="_blank" rel="noopener">Travis CI</a>的资料:</p>
<ul>
<li><a href="https://avnpc.com/pages/android-auto-deploy-workflow-on-travis-ci" target="_blank" rel="noopener">基于Travis CI搭建Android自动打包发布工作流（支持Github Release及fir.im)</a></li>
</ul>
<h3 id="安卓多渠道打包-同时打900个渠道包怎么办？？？"><a href="#安卓多渠道打包-同时打900个渠道包怎么办？？？" class="headerlink" title="安卓多渠道打包(同时打900个渠道包怎么办？？？)"></a>安卓多渠道打包(同时打900个渠道包怎么办？？？)</h3><p>解决方案：<br>V1签名下的快速打包工具：<a href="https://github.com/GavinCT/AndroidMultiChannelBuildTool" target="_blank" rel="noopener">AndroidMultiChannelBuildTool</a></p>
<p>不管多少渠道包，分分钟打完。</p>
<p>V2签名打包:<br>如果公司需要升级到V2签名,那么上面那个就不在适用，请移步到这个:<a href="https://github.com/Meituan-Dianping/walle" target="_blank" rel="noopener">walle</a>,美团针对V2签名设计的打包工具，不过使用方式与上面的那个不同，需要在项目中添加插件并用Gradle构建打包.</p>
]]></content>
      
        <categories>
            
            <category> 安卓杂记 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[objectBox数据库使用教程]]></title>
      <url>/objectBox%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B-objectbox-java.html</url>
      <content type="html"><![CDATA[<p><strong>版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起.</strong></p>
<hr>
<h2 id="数据库简介"><a href="#数据库简介" class="headerlink" title="数据库简介"></a>数据库简介</h2><p><a href="https://github.com/objectbox/objectbox-java" target="_blank" rel="noopener">objectbox</a>数据库是greenrobot团队开发的全新非关系型数据库框架，该团队还开发过greenDao,EventBus等热门框架，可谓实力雄厚。按照官方介绍，该库有如下特点:<br><a id="more"></a></p>
<ul>
<li>超快速:号称胜过测试过的所有嵌入式数据库</li>
<li>面向对象的 API: 没有 rows、columns 和 SQL，完全从0开始的对象（没有ORM，没有SQLite）</li>
<li>反应性:对数据变化的反应简单而强大,使用ObjectBox中的反应数据观察器或与RxJava集成。</li>
<li>多平台:已经支持安卓和java,ios和MacOs正在集成</li>
<li>简单的线程:ObjectBox返回的对象可以在所以线程中运行</li>
<li>没有手动模式迁移:ObjectBox负责添加，删除和重命名属性的新对象版本，意味着数据库的升级不再需要我们自己管理版本号，ObjectBox内部会自动帮我们管理</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>注意，本教程是基于截至于目前最新版1.4.0编写</p>
<p>根目录build.gradle中添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ext.objectboxVersion = &apos;1.4.0&apos;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123; url &quot;http://objectbox.net/beta-repo/&quot; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath &quot;io.objectbox:objectbox-gradle-plugin:$objectboxVersion&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123; url &quot;http://objectbox.net/beta-repo/&quot; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>app  build.gradle中添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;io.objectbox&apos; // after applying Android plugin</span><br></pre></td></tr></table></figure></p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>在Application中的<code>onCreate()</code>中初始化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boxStore = MyObjectBox.builder().androidContext(<span class="keyword">this</span>).build();</span><br></pre></td></tr></table></figure></p>
<p>初始化后得到一个<code>BoxStore</code>对象,该对象可以简单理解为获取查询对象的入口,因此，我们可以申明一个<code>get()</code>方法，像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class BaseApp extends Application &#123;</span><br><span class="line">    private static BaseApp baseApp;</span><br><span class="line">    private BoxStore boxStore; //数据库表的管理者</span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">        baseApp = this;</span><br><span class="line">        boxStore = MyObjectBox.builder().androidContext(this).build();</span><br><span class="line">        if (BuildConfig.DEBUG) &#123;</span><br><span class="line">            new AndroidObjectBrowser(boxStore).start(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BoxStore getBoxStore()&#123;</span><br><span class="line">        return boxStore;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static BaseApp getInstence()&#123;</span><br><span class="line">        return baseApp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="实体类的建立"><a href="#实体类的建立" class="headerlink" title="实体类的建立"></a>实体类的建立</h4><p>objectbox是通过注解来标明哪个类是实体，常用的注解如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Entity   //表示这是一个需要持久化的实体</span><br><span class="line">public class Student &#123;</span><br><span class="line">    @Id </span><br><span class="line">    public long id;</span><br><span class="line"></span><br><span class="line">    @Index</span><br><span class="line">    public String name;</span><br><span class="line"> </span><br><span class="line">    @Transient</span><br><span class="line">    public int tempUsageCount;</span><br><span class="line"></span><br><span class="line">    @NameInDb(&quot;USERNAME&quot;)</span><br><span class="line">    public String name;</span><br><span class="line"></span><br><span class="line">    public ToOne&lt;Class&gt; classToOne;</span><br><span class="line"></span><br><span class="line">    public int age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>@Entity：</strong>这个对象需要持久化。</p>
<p><strong>@Id：</strong>这个对象的主键,默认情况下，id是会被objectbox管理的，也就是自增id，如果你想手动管理id需要在注解的时候加上@Id(assignable = true)即可。当你在自己管理id的时候如果超过long的最大值，objectbox 会报错.id的值不能为负数。当id等于0时objectbox会认为这是一个新的实体对象,因此会新增到数据库表中</p>
<p><strong>@Index：</strong>这个对象中的索引。对经常大量进行查询的字段创建索引，会提高你的查询性能。</p>
<p><strong>@Transient:</strong>如果你有某个字段不想被持久化，可以使用此注解,那么该字段将不会保存到数据库</p>
<p><strong>@NameInDb：</strong>有的时候数据库中的字段跟你的对象字段不匹配的时候，可以使用此注解。</p>
<p><strong>@ToOne:</strong>做一对一的关联注解，例如示例中表示一张学生表（Student）关联一张班级表（Class）,此外还有一对多，多对多的关联，例如Class的示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Entity</span><br><span class="line">public class Class&#123;</span><br><span class="line">    @Id</span><br><span class="line">    long id;</span><br><span class="line">    </span><br><span class="line">    @Backlink(to = &quot;classToOne&quot;)</span><br><span class="line">    public ToMany&lt;Student&gt; studentEntitys;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>@ToMany:</strong>做一对多的关联注解，如示例中表示一张班级表(Class)关联多张学生表(Student)</p>
<p><strong>@Backlink:</strong>表示反向关联</p>
<h4 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h4><p>实体类建立完后，在Android Studio中使用Build&gt; Make project编译一次，objectbox会自动帮你生成相应的操作实体,例如·<code>Student</code>则会生成一个<code>Student_</code>的类，该类通常作为Params传递。</p>
<p><strong>增加一条数据</strong><br>首先我们获取该实体的<code>Box</code>对象，随后调用该对象的<code>put()</code>方法即可完成新增操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Box&lt;Student&gt; StudentBox = BaseApp.getInstence().getBoxStore().boxFor(Student.class);</span><br><span class="line">Student student = new Student();</span><br><span class="line">student.name = &quot;Jay&quot;;</span><br><span class="line">StudentBox.put(student);</span><br></pre></td></tr></table></figure></p>
<p><strong>删除数据</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StudentBox.remove(student);  //该参数可以传要删除的实体，也可以传入要删除的实体的id,可以批量传入</span><br></pre></td></tr></table></figure></p>
<p><strong>查询</strong><br>通过<code>Box</code>的<code>query()</code>方法可以得到一个<code>QueryBuilder</code>对象，该对象可以实现各种查询操作，里面包含<code>contains()</code>,<code>equal()</code>等各种便捷的查询方法，示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//查询一个名叫Jay的学生信息的表</span><br><span class="line">Student jayStudent = StudentBox.query().equal(Student_.name, &quot;Jay&quot;).build().find();</span><br></pre></td></tr></table></figure></p>
<p>里面的<code>Property</code>对象其实就是传入我们自动生成的<code>Student_</code>对象的参数。</p>
<p><strong>修改</strong><br>objectBox修改数据非常简单，首先得到要修改的实体类，直接修改数据，随后调用<code>put()</code>方法即可，示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//查询一个名叫Jay的学生信息的表</span><br><span class="line">Student jayStudent = StudentBox.query().equal(Student_.name, &quot;Jay&quot;).build().find();</span><br><span class="line">jayStudent.name = &quot;www.huangjie.name&quot;;</span><br><span class="line">StudentBox.put(jayStudent);</span><br></pre></td></tr></table></figure></p>
<p>这样就把Jay改成了我的博客地址,haha~</p>
<h4 id="数据库的其他操作"><a href="#数据库的其他操作" class="headerlink" title="数据库的其他操作"></a>数据库的其他操作</h4><p><strong>数据库的数据升级</strong><br>当我们需要新增和删除字段时，直接操作实体类即可，不需要做特殊的更改，如果需要重命名字段名或实体类名，可以按照如下步骤操作：<br>第一步：给需要修改的类名加上@UID注解<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Entity</span><br><span class="line">@Uid</span><br><span class="line">public class MyName &#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>第二步：编译项目，编译将失败，并且会给你一个UID<br><code>error: [ObjectBox] UID operations for entity &quot;MyName&quot;: 
  [Rename] apply the current UID using @Uid(6645479796472661392L) -
  [Change/reset] apply a new UID using @Uid(4385203238808477712L)</code><br>第三步：将Rename后面的UID放入到要修改的类中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Entity</span><br><span class="line">@Uid(6645479796472661392L)</span><br><span class="line">public class MyName &#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>第四步：进行数据的修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Entity</span><br><span class="line">@Uid(6645479796472661392L)</span><br><span class="line">public class MyNewName &#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>更改数据属性或重命名字段名同理操作。</p>
<h4 id="表关系"><a href="#表关系" class="headerlink" title="表关系"></a>表关系</h4><p>@ToOne和@ToMany可以看作JAVA中的T和List<t>的关系,拿班级和学生举例，设置相关的学生对象如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class class = new Class(); //先创建一个班级</span><br><span class="line">Student student = new Student();</span><br><span class="line">student.name = &quot;Jay&quot;;</span><br><span class="line">student.classToOne.setTarget(class);  //设置一对一的target对象，字段参见以上示例</span><br><span class="line">long studentId = StudentBox.put(student);</span><br></pre></td></tr></table></figure></t></p>
<p>获取该学生的班级信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student student = StudentBox.get(studentId);</span><br><span class="line">Class class = student.classToOne.getTarget();</span><br></pre></td></tr></table></figure></p>
<p>而一对多的关系更为简单，你可以像List集合一样去操作它：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Class class_ = new Class(); //先创建一个班级</span><br><span class="line">Student s1 = new Student(); //添加一个学生</span><br><span class="line">student.name = &quot;Jay&quot;;</span><br><span class="line"></span><br><span class="line">Student s2 = new Student();</span><br><span class="line">s2.name = &quot;Android&quot;;</span><br><span class="line"></span><br><span class="line">class_ .studentEntitys.add(s1);</span><br><span class="line">class_ .studentEntitys.add(s2);</span><br><span class="line">Box classBox = BaseApp.getInstence().getBoxStore().boxFor(Class.class);</span><br><span class="line">classBox.put(class);</span><br></pre></td></tr></table></figure></p>
<p>这样的话一张Class表中就有两个学生表的数据了，查询的话可以获取该Class的实体，随后像遍历List集合一样去遍历<code>studentEntitys</code>字段,objectBox提供的方法和List集合几乎一样，这里就不做示例了。</p>
<p><strong>求和等操作</strong><br>使用<code>Query</code>对象即可进行求和等操作,通过<code>QueryBuilder</code>的<code>build()</code>方法即可得到。随后调用<code>sumDouble()</code>等方法传入求和条件即可。我们获取实体类或实体类集合也是使用的该对象获取。</p>
<p>另外，objectBox还支持事务，Rxjava查询，Kotlin的支持，更多详情可以通过官方文档了解<a href="http://objectbox.io/" target="_blank" rel="noopener">http://objectbox.io</a>.</p>
<h4 id="End"><a href="#End" class="headerlink" title="End"></a>End</h4><p>emmmmmm…写了这么多，个人觉得objectBox挺好用的，目前没发现啥坑，唯一的坑是编译的时候提示找不到<code>MyObjectBox</code>这个类，这个不用担心，先确认一下配置是否有误，无误的话将项目<code>Make Project</code>一下或者重新编译一下就OK了，另外，推荐下我写的ObjectBox数据库的练手项目<a href="https://github.com/Jay-huangjie/Notes" target="_blank" rel="noopener">仿支付宝记账本</a>,仿的支付宝中的记账本功能，结合它看你的objectBox上手更快哦。</p>
]]></content>
      
        <categories>
            
            <category> 安卓开源库使用教程 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Android开发常见问题汇总]]></title>
      <url>/Android%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB.html</url>
      <content type="html"><![CDATA[<p><strong>版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起.</strong></p>
<hr>
<blockquote>
<p>此为开发中遇到的一些常见问题的整理，方便下次遇到问题能快速找到解决方案</p>
</blockquote>
<h4 id="1-编译出现："><a href="#1-编译出现：" class="headerlink" title="1 编译出现："></a>1 编译出现：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">All com.android.<span class="function">support libraries must use the exact same version <span class="title">specification</span> <span class="params">(mixing versions can lead to runtime crashes)</span>......</span></span><br></pre></td></tr></table></figure>
<p>如果引用的第三方库的支持库版本低于（或者不一致）app build.gradle中的支持库版本，就会出现这种问题,修改第三方的依赖的话工作量太大,因此考虑所有模块强制使用相同的版本号的支持库，代码如下：</p>
<p>在app build.gradle中添加：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">configurations.all &#123;</span><br><span class="line">    resolutionStrategy.eachDependency &#123; DependencyResolveDetails details -&gt;</span><br><span class="line">        def requested = details.requested</span><br><span class="line">        <span class="keyword">if</span> (requested.group == <span class="string">'com.android.support'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!requested.name.startsWith(<span class="string">"multidex"</span>)) &#123;</span><br><span class="line">                details.useVersion <span class="string">'26.1.0'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此代码声明了除multdex外全部使用26.1.0的版本库</p>
<h4 id="2-SVG图片兼容问题-主要针对5-0以下机型"><a href="#2-SVG图片兼容问题-主要针对5-0以下机型" class="headerlink" title="2 SVG图片兼容问题(主要针对5.0以下机型)"></a>2 SVG图片兼容问题(主要针对5.0以下机型)</h4><p>参考博客：<a href="https://www.jianshu.com/p/e3614e7abc03" target="_blank" rel="noopener">Android Vector曲折的兼容之路</a></p>
<p>基本适配方法：<br>在app build.gradle 的<code>defaultConfig</code>中添加<code>defaultvectorDrawables.useSupportLibrary = true</code></p>
<p>xml中使用：<br>ImageView原本是使用<code>src</code>加载,改为<code>app:srcCompat</code>.</p>
<p>java中使用：<br><code>ImageView iv = (ImageView) findViewById(R.id.iv);
iv.setImageResource(R.drawable.vector_image);</code></p>
]]></content>
      
        <categories>
            
            <category> Android基础进阶 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[2017年终总结]]></title>
      <url>/2017%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93.html</url>
      <content type="html"><![CDATA[<p><strong>版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起.</strong></p>
<hr>
<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>从自己开始坚持写博客也有1个月了，感觉非常的充实，博客就是注重总结归纳嘛，既然2017都已经过去，那么也有必要总结归纳一下啦。其实我认为我的2017总结起来就是：行动起来，不再等待，重在参与！<br><a id="more"></a></p>
<h4 id="回首"><a href="#回首" class="headerlink" title="回首"></a>回首</h4><p>一眨眼2017就过去了，想想自己今年，的确是成长最快的一年，也是忙碌而又平淡的一年，收获了许多。</p>
<p>依稀记得年初，就有了技术进阶的想法，因为感觉自己在许多功能点上‘会做’，但‘不懂’，无法深入的解决问题。于是，我就寻求进阶的方法，我在帅张的公众号上读了他写的一遍文章，文章指出，习惯很重要，我结合自身的行为揣摩这句话，总结发现，学习并不需要强迫自己去学，而应该把它当成一种自然习惯，就像渴了会喝水一样的生活习惯，这种习惯的培养需要的是坚持，以及自律！为此我尝试慢慢去培养自己的学习习惯：</p>
<p>因为公司搬家，我从家到公司需要30-40分钟，在地铁上，以前是都是看一下新闻啊，刷一下微博啊，现在我都是看掘金有没有什么新鲜的框架，看看简书有没有好看的技术文章，看看github有没有火热的技术排名，那些微博什么的我再也没打开过，我已经坚持有大半年的，甚至现在但凡座地铁我也会习惯性打开这些app</p>
<p>以前的我工作回到家都是刷电视剧，现在都是有目的性的去学习一个知识点或者一门语言，这样时间过得非常的快，每天感觉时间不够用，果然当投入到某一件事时时间的流逝是非常快速的。</p>
<p>先前都是自己写demo,自己总结知识点，然后写到印象笔记中，但是我发现里面的知识点太散乱，无法成为一个体系。于是我就试着写博客，为此，我发现了一个新大陆，写博客对于知识的梳理简直太有用了，前提是你想写好一篇博客。</p>
<p>学习知识就要善于总结归纳，书本是最好的老师，为此2017我阅读了一些的书籍：</p>
<p>郭神的《第一行代码》第二版，这是一本基础书籍，它让我对安卓的基础有了更加完善的了解和夯实。</p>
<p>任玉刚的《安卓开发艺术探索》，这是一本进阶类的书籍，它让我突破了瓶颈，对安卓的了解更加的深入了。</p>
<p>我对这两位都非常的钦佩，正是他们让我们这些开发者的进阶至少能提前0.5-1年的时间，《开发艺术探索》我来回读了好几遍，每一次都会有新的收获，再次感谢~</p>
<p>晚上，我也会偶尔看下慕课网上的视频，我觉得里面的老师讲的还是比较好的，为此我也推荐给大家。</p>
<p>回首2017的技术有如下的总结：</p>
<ul>
<li><p>学习了自定义View,对自定义的流程有了较为完善的了解</p>
</li>
<li><p>学习了View体系，view的确是一个非常有魅力的控件，它可以带来无穷的创造力</p>
</li>
<li><p>对数据库框架都有所了解：如公司项目正在使用的<a href="https://github.com/pardom/ActiveAndroid" target="_blank" rel="noopener">ActiveAndroid</a>(作者貌似不维护了？),使用<a href="https://github.com/greenrobot/greenDAO" target="_blank" rel="noopener">greenDAO</a>做过一些简单的demo,后来发现了greenDao的作者正在开发一个全新的数据库，号称最快的数据库，于是就没有继续深入greenDao的研究，转而研究新的数据库，它就是我现在正在研究的<a href="https://github.com/objectbox/objectbox-java" target="_blank" rel="noopener">object-box</a>,不过现在资料还较少，届时我会出一个教程。</p>
</li>
<li><p>学习了ExoPlayer视频播放框架，Rxjava,okhttp,mvp等等的一些热门框架和架构</p>
</li>
<li><p>学习了一些kotlin的基本语法</p>
</li>
<li><p>学习了html5的一些基本语法，能制作一些静态页面</p>
</li>
<li><p>基于hexo和coding搭建的博客平台.先前本来是上传到github的，由于百度被墙的关系，就移到coding了。</p>
</li>
</ul>
<h4 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h4><p>对于2018，我坚信我的坚持会带给我更多的收获。我依旧会努力坚持2017正在做的事情：</p>
<ul>
<li>坚持写博客，至少1周一篇</li>
<li>坚持技术学习</li>
</ul>
<p>2018要刷的书有《kotlin实战》，《Android神兵利器》，《安卓群英传》。</p>
<p>2018需要进阶的技术有：</p>
<ul>
<li>kotlin的熟练使用</li>
<li>自定义View的总结，动画系列</li>
<li>直播，视频播放技术要点总结</li>
<li>设计模式</li>
<li>内存优化</li>
<li>gradle精通</li>
<li>简单了解下逆向，反编译等技术</li>
</ul>
<p>2018，让我们一起加油<del>~</del></p>
]]></content>
      
        <categories>
            
            <category> 感悟 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[ExoPlayer视频框架：自定义UI界面及源码解析]]></title>
      <url>/ExoPlayer%E8%A7%86%E9%A2%91%E6%A1%86%E6%9E%B6%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89UI%E7%95%8C%E9%9D%A2%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.html</url>
      <content type="html"><![CDATA[<p><strong>版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起.</strong></p>
<hr>
<blockquote>
<p>本文主要讲述使用ExoPlayer框架时如何自定义自己的视频播放界面，来达到满意的效果，以及SimpleExoPlayerView的源码解析</p>
</blockquote>
<h4 id="SimpleExoPlayerView"><a href="#SimpleExoPlayerView" class="headerlink" title="SimpleExoPlayerView"></a>SimpleExoPlayerView</h4><a id="more"></a>
<h5 id="类介绍"><a href="#类介绍" class="headerlink" title="类介绍"></a>类介绍</h5><p>SimpleExoPlayerView是一个自定义FrameLayout,内部封装了视频，字幕，播放封面，播放控制器的View逻辑</p>
<h5 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h5><p><strong>在xml中声明该控件：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;com.google.android.exoplayer2.ui.SimpleExoPlayerView</span><br><span class="line">        android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">        android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">        android:id=<span class="string">"@+id/simpleExoPlayerView"</span></span><br><span class="line">        app:resize_mode=<span class="string">"fixed_width"</span></span><br><span class="line">        /&gt;</span><br></pre></td></tr></table></figure></p>
<p>SimpleExoPlayerView内部的AspectRatioFrameLayout封装了视频宽高比的计算，它根据视频流的宽高比来动态设置控件的宽高来达到适应屏幕的目的，<code>resize_mode</code>可以指定这种视频的宽高比计算模式，共有四种模式，<code>fixed_width</code>代表根据宽度来动态计算高度，宽度不会变化，<code>fixed_height</code>与之相反，<code>fill</code>模式会忽略宽高比，不进行动态计算，<code>fit</code>为默认模式，如果高度变形就动态计算高度来适配，宽度变形就动态计算宽度来适配。<br><strong>activity中：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">simpleExoPlayerView.setPlayer(player);</span><br></pre></td></tr></table></figure></p>
<p>通过<code>setPlayer</code>方法来与<code>ExoPlayer</code>绑定</p>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>要随心所欲的使用该View，来定制自己理想的UI，就得先了解其中的原理，方能全面掌控，下面我们就来撸一遍源码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TargetApi</span>(<span class="number">16</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleExoPlayerView</span> <span class="keyword">extends</span> <span class="title">FrameLayout</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SURFACE_TYPE_NONE = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SURFACE_TYPE_SURFACE_VIEW = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SURFACE_TYPE_TEXTURE_VIEW = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> AspectRatioFrameLayout contentFrame;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> View shutterView;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> View surfaceView;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ImageView artworkView;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SubtitleView subtitleView;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> PlaybackControlView controller;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ComponentListener componentListener;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> FrameLayout overlayFrameLayout;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> SimpleExoPlayer player;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> useController;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> useArtwork;</span><br><span class="line">  <span class="keyword">private</span> Bitmap defaultArtwork;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> controllerShowTimeoutMs;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> controllerAutoShow;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> controllerHideOnTouch;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SimpleExoPlayerView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SimpleExoPlayerView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SimpleExoPlayerView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isInEditMode()) &#123;</span><br><span class="line">      contentFrame = <span class="keyword">null</span>;</span><br><span class="line">      shutterView = <span class="keyword">null</span>;</span><br><span class="line">      surfaceView = <span class="keyword">null</span>;</span><br><span class="line">      artworkView = <span class="keyword">null</span>;</span><br><span class="line">      subtitleView = <span class="keyword">null</span>;</span><br><span class="line">      controller = <span class="keyword">null</span>;</span><br><span class="line">      componentListener = <span class="keyword">null</span>;</span><br><span class="line">      overlayFrameLayout = <span class="keyword">null</span>;</span><br><span class="line">      ImageView logo = <span class="keyword">new</span> ImageView(context);</span><br><span class="line">      <span class="keyword">if</span> (Util.SDK_INT &gt;= <span class="number">23</span>) &#123;</span><br><span class="line">        configureEditModeLogoV23(getResources(), logo);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        configureEditModeLogo(getResources(), logo);</span><br><span class="line">      &#125;</span><br><span class="line">      addView(logo);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> shutterColorSet = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> shutterColor = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> playerLayoutId = R.layout.exo_simple_player_view;</span><br><span class="line">    <span class="keyword">boolean</span> useArtwork = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span> defaultArtworkId = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> useController = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span> surfaceType = SURFACE_TYPE_SURFACE_VIEW;</span><br><span class="line">    <span class="keyword">int</span> resizeMode = AspectRatioFrameLayout.RESIZE_MODE_FIT;</span><br><span class="line">    <span class="keyword">int</span> controllerShowTimeoutMs = PlaybackControlView.DEFAULT_SHOW_TIMEOUT_MS;</span><br><span class="line">    <span class="keyword">boolean</span> controllerHideOnTouch = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span> controllerAutoShow = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (attrs != <span class="keyword">null</span>) &#123;</span><br><span class="line">      TypedArray a = context.getTheme().obtainStyledAttributes(attrs,</span><br><span class="line">              R.styleable.SimpleExoPlayerView, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        shutterColorSet = a.hasValue(R.styleable.SimpleExoPlayerView_shutter_background_color);</span><br><span class="line">        shutterColor = a.getColor(R.styleable.SimpleExoPlayerView_shutter_background_color,</span><br><span class="line">                shutterColor);</span><br><span class="line">        playerLayoutId = a.getResourceId(R.styleable.SimpleExoPlayerView_player_layout_id,</span><br><span class="line">                playerLayoutId);</span><br><span class="line">        useArtwork = a.getBoolean(R.styleable.SimpleExoPlayerView_use_artwork, useArtwork);</span><br><span class="line">        defaultArtworkId = a.getResourceId(R.styleable.SimpleExoPlayerView_default_artwork,</span><br><span class="line">                defaultArtworkId);</span><br><span class="line">        useController = a.getBoolean(R.styleable.SimpleExoPlayerView_use_controller, useController);</span><br><span class="line">        surfaceType = a.getInt(R.styleable.SimpleExoPlayerView_surface_type, surfaceType);</span><br><span class="line">        resizeMode = a.getInt(R.styleable.SimpleExoPlayerView_resize_mode, resizeMode);</span><br><span class="line">        controllerShowTimeoutMs = a.getInt(R.styleable.SimpleExoPlayerView_show_timeout,</span><br><span class="line">                controllerShowTimeoutMs);</span><br><span class="line">        controllerHideOnTouch = a.getBoolean(R.styleable.SimpleExoPlayerView_hide_on_touch,</span><br><span class="line">                controllerHideOnTouch);</span><br><span class="line">        controllerAutoShow = a.getBoolean(R.styleable.SimpleExoPlayerView_auto_show,</span><br><span class="line">                controllerAutoShow);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        a.recycle();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LayoutInflater.from(context).inflate(playerLayoutId, <span class="keyword">this</span>);</span><br><span class="line">    componentListener = <span class="keyword">new</span> ComponentListener();</span><br><span class="line">    setDescendantFocusability(FOCUS_AFTER_DESCENDANTS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Content frame.</span></span><br><span class="line">    contentFrame = findViewById(R.id.exo_content_frame);</span><br><span class="line">    <span class="keyword">if</span> (contentFrame != <span class="keyword">null</span>) &#123;</span><br><span class="line">      setResizeModeRaw(contentFrame, resizeMode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Shutter view.</span></span><br><span class="line">    shutterView = findViewById(R.id.exo_shutter);</span><br><span class="line">    <span class="keyword">if</span> (shutterView != <span class="keyword">null</span> &amp;&amp; shutterColorSet) &#123;</span><br><span class="line">      shutterView.setBackgroundColor(shutterColor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a surface view and insert it into the content frame, if there is one.</span></span><br><span class="line">    <span class="keyword">if</span> (contentFrame != <span class="keyword">null</span> &amp;&amp; surfaceType != SURFACE_TYPE_NONE) &#123;</span><br><span class="line">      ViewGroup.LayoutParams params = <span class="keyword">new</span> ViewGroup.LayoutParams(</span><br><span class="line">              ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);</span><br><span class="line">      surfaceView = surfaceType == SURFACE_TYPE_TEXTURE_VIEW ? <span class="keyword">new</span> TextureView(context)</span><br><span class="line">              : <span class="keyword">new</span> SurfaceView(context);</span><br><span class="line">      surfaceView.setLayoutParams(params);</span><br><span class="line">      contentFrame.addView(surfaceView, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      surfaceView = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Overlay frame layout.</span></span><br><span class="line">    overlayFrameLayout = findViewById(R.id.exo_overlay);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Artwork view.</span></span><br><span class="line">    artworkView = findViewById(R.id.exo_artwork);</span><br><span class="line">    <span class="keyword">this</span>.useArtwork = useArtwork &amp;&amp; artworkView != <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (defaultArtworkId != <span class="number">0</span>) &#123;</span><br><span class="line">      defaultArtwork = BitmapFactory.decodeResource(context.getResources(), defaultArtworkId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Subtitle view.</span></span><br><span class="line">    subtitleView = findViewById(R.id.exo_subtitles);</span><br><span class="line">    <span class="keyword">if</span> (subtitleView != <span class="keyword">null</span>) &#123;</span><br><span class="line">      subtitleView.setUserDefaultStyle();</span><br><span class="line">      subtitleView.setUserDefaultTextSize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Playback control view.</span></span><br><span class="line">    PlaybackControlView customController = findViewById(R.id.exo_controller);</span><br><span class="line">    View controllerPlaceholder = findViewById(R.id.exo_controller_placeholder);</span><br><span class="line">    <span class="keyword">if</span> (customController != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.controller = customController;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (controllerPlaceholder != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Propagate attrs as playbackAttrs so that PlaybackControlView's custom attributes are</span></span><br><span class="line">      <span class="comment">// transferred, but standard FrameLayout attributes (e.g. background) are not.</span></span><br><span class="line">      <span class="keyword">this</span>.controller = <span class="keyword">new</span> PlaybackControlView(context, <span class="keyword">null</span>, <span class="number">0</span>, attrs);</span><br><span class="line">      controller.setLayoutParams(controllerPlaceholder.getLayoutParams());</span><br><span class="line">      ViewGroup parent = ((ViewGroup) controllerPlaceholder.getParent());</span><br><span class="line">      <span class="keyword">int</span> controllerIndex = parent.indexOfChild(controllerPlaceholder);</span><br><span class="line">      parent.removeView(controllerPlaceholder);</span><br><span class="line">      parent.addView(controller, controllerIndex);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.controller = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.controllerShowTimeoutMs = controller != <span class="keyword">null</span> ? controllerShowTimeoutMs : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.controllerHideOnTouch = controllerHideOnTouch;</span><br><span class="line">    <span class="keyword">this</span>.controllerAutoShow = controllerAutoShow;</span><br><span class="line">    <span class="keyword">this</span>.useController = useController &amp;&amp; controller != <span class="keyword">null</span>;</span><br><span class="line">    hideController();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  以下是一些暴露的方法</span><br><span class="line">  .......</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>我们看下它的构造方法，首先通过<code>isInEditMode()</code>方法判断了是否是在可视化编辑器中加载的，是的话就return。</p>
<p>接下来声明了一些默认的变量，并赋予了一些默认的值，我们看到有一个<code>playerLayoutId</code>声明了一个默认的布局文件<code>exo_simple_player_view</code>，跟踪去看下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</span><br><span class="line">&lt;merge xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span><br><span class="line"></span><br><span class="line">  &lt;com.google.android.exoplayer2.ui.AspectRatioFrameLayout android:id=<span class="string">"@id/exo_content_frame"</span></span><br><span class="line">      android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">      android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">      android:layout_gravity=<span class="string">"center"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Video surface will be inserted as the first child of the content frame. --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;View android:id=<span class="string">"@id/exo_shutter"</span></span><br><span class="line">        android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">        android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">        android:background=<span class="string">"@android:color/black"</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;ImageView android:id=<span class="string">"@id/exo_artwork"</span></span><br><span class="line">        android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">        android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">        android:scaleType=<span class="string">"fitXY"</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;com.google.android.exoplayer2.ui.SubtitleView android:id=<span class="string">"@id/exo_subtitles"</span></span><br><span class="line">        android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">        android:layout_height=<span class="string">"match_parent"</span>/&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/com.google.android.exoplayer2.ui.AspectRatioFrameLayout&gt;</span><br><span class="line"></span><br><span class="line">  &lt;FrameLayout android:id=<span class="string">"@id/exo_overlay"</span></span><br><span class="line">      android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">      android:layout_height=<span class="string">"match_parent"</span>/&gt;</span><br><span class="line"></span><br><span class="line">  &lt;View android:id=<span class="string">"@id/exo_controller_placeholder"</span></span><br><span class="line">      android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">      android:layout_height=<span class="string">"match_parent"</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/merge&gt;</span><br></pre></td></tr></table></figure></p>
<p>这个布局文件就是我们的ExoPlayer ui包中的默认ui布局。<br><code>AspectRatioFrameLayout</code>是继承自<code>FragmeLayout</code>,也就是源码中的<code>contentFrame</code>，它的作用是根据视频的宽高比和屏幕的宽高比来动态计算视频View的宽高比例。而<code>SimpleExoPlayerView</code>会将<code>surfaceView</code>动态插入到<code>AspectRatioFrameLayout</code>的第一个子View中来，来作为播放的View.</p>
<p><code>exo_shutter</code>也就是源码中的shutterView，它的背景可以通过代码动态设置，可以作为视频的一个蒙层.</p>
<p><code>exo_artwork</code>为源码中的<code>artworkView</code>，是一个ImageView,可以放一些图片上去.</p>
<p><code>SubtitleView</code>是一个字幕显示器，为源码中的<code>subtitleView</code>，可以定制字幕文件。</p>
<p><code>exo_overlay</code>为源码中的<code>overlayFrameLayout</code>，在源码中没有定制任何东西，可以根据需求放入一些逻辑。</p>
<p><code>exo_controller_placeholder</code>为源码中的<code>controllerPlaceholder</code>，定义了<code>PlaybackControlView</code>的布局属性，在代码中<code>SimpleExoPlayer</code>会将<code>controllerPlaceholder</code>的Param属性添加到<code>PlaybackControlView</code>上。<br><code>PlaybackControlView</code>是一个播放控制器View.内部封装了播放器控制逻辑，也可以定制自定义ui和实现自己的控制逻辑。</p>
<p>介绍了这么多，接下来继续分析源码<br><code>LayoutInflater.from(context).inflate(playerLayoutId, this);</code><br>可以看到，SimpleExoPlayerView将playerLayoutId添加进了该视图，因此，我们可以通过xml的属性来指定该View的视图id，接着声明了该焦点模式为只有当子View不需要焦点时才获取焦点。<br><code>setDescendantFocusability(FOCUS_AFTER_DESCENDANTS);</code><br>接下来通过findViewById的模式得到视图的控件来进行不同的设置，因此，如果我们自定义的ui中想用到里面的功能，就必须申明一样的id.也可以通过findViewById的方式得到该控件。<br>接下来继续走：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a surface view and insert it into the content frame, if there is one.</span></span><br><span class="line">   <span class="keyword">if</span> (contentFrame != <span class="keyword">null</span> &amp;&amp; surfaceType != SURFACE_TYPE_NONE) &#123;</span><br><span class="line">     ViewGroup.LayoutParams params = <span class="keyword">new</span> ViewGroup.LayoutParams(</span><br><span class="line">         ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);</span><br><span class="line">     surfaceView = surfaceType == SURFACE_TYPE_TEXTURE_VIEW ? <span class="keyword">new</span> TextureView(context)</span><br><span class="line">         : <span class="keyword">new</span> SurfaceView(context);</span><br><span class="line">     surfaceView.setLayoutParams(params);</span><br><span class="line">     contentFrame.addView(surfaceView, <span class="number">0</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     surfaceView = <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>SimpleExoPlayerView</code>根据<code>sufaceType</code>自动创建一个<code>SufaceView</code>或<code>TextureView</code>,并将其添加到<code>AspectRatioFrameLayout</code>的第一个子View上，用来播放视频。因此如果自定义UI，一定要定义一个<code>AspectRatioFrameLayout</code>来包裹该View.<br>接着我们看一下控制器的逻辑：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Playback control view.</span></span><br><span class="line">   PlaybackControlView customController = findViewById(R.id.exo_controller);</span><br><span class="line">   View controllerPlaceholder = findViewById(R.id.exo_controller_placeholder);</span><br><span class="line">   <span class="keyword">if</span> (customController != <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="keyword">this</span>.controller = customController;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (controllerPlaceholder != <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="comment">// Propagate attrs as playbackAttrs so that PlaybackControlView's custom attributes are</span></span><br><span class="line">     <span class="comment">// transferred, but standard FrameLayout attributes (e.g. background) are not.</span></span><br><span class="line">     <span class="keyword">this</span>.controller = <span class="keyword">new</span> PlaybackControlView(context, <span class="keyword">null</span>, <span class="number">0</span>, attrs);</span><br><span class="line">     controller.setLayoutParams(controllerPlaceholder.getLayoutParams());</span><br><span class="line">     ViewGroup parent = ((ViewGroup) controllerPlaceholder.getParent());</span><br><span class="line">     <span class="keyword">int</span> controllerIndex = parent.indexOfChild(controllerPlaceholder);</span><br><span class="line">     parent.removeView(controllerPlaceholder);</span><br><span class="line">     parent.addView(controller, controllerIndex);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">this</span>.controller = <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到<code>PlaybackControlView</code>也是通过找id的方式获取，因此我们需要定制控制器ui的话可以通过继承<code>PlaybackControlView</code>的方式来定制我们自己的控制UI。<br>如果我们没有定义<code>PlaybackControlView</code>，那么会先创建一个<code>PlaybackControlView</code>，然后去取<code>exo_controller_placeholder</code>的<code>param</code>属性赋给<code>PlaybackControlView</code>，如果没有的话，那么不会申明一个控制器。</p>
<h4 id="UI定制"><a href="#UI定制" class="headerlink" title="UI定制"></a>UI定制</h4><p>以上通过源码分析，相信对该控件也有个大概的了解了，接下来看看如何定制我们的UI：<br>首先，在xml中我们可以通过<code>controller_layout_id</code>属性申明我们自己的<code>Layout id</code>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;com.google.android.exoplayer2.ui.SimpleExoPlayerView</span><br><span class="line">      android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">      android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">      android:id=<span class="string">"@+id/simpleExoPlayerView"</span></span><br><span class="line">      app:resize_mode=<span class="string">"fixed_width"</span></span><br><span class="line">      app:controller_layout_id=<span class="string">"@layout/simple_player_view"</span></span><br><span class="line">      /&gt;</span><br></pre></td></tr></table></figure></p>
<p><code>simple_player_view</code>为我自定义布局文件，看一下<code>simple_player_view</code>的代码：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;com.google.android.exoplayer2.ui.AspectRatioFrameLayout</span><br><span class="line">    android:id=<span class="string">"@id/exo_content_frame"</span></span><br><span class="line">    android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">    android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">    android:layout_gravity=<span class="string">"top"</span>&gt;</span><br><span class="line">    &lt;com.jie.exoplayerdemo.PlayControlView</span><br><span class="line">        android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">        android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">        android:id=<span class="string">"@id/exo_controller"</span></span><br><span class="line">        android:layout_gravity=<span class="string">"bottom"</span></span><br><span class="line">        app:controller_layout_id=<span class="string">"@layout/exo_playback_control_view"</span></span><br><span class="line">        /&gt;</span><br><span class="line">&lt;/com.google.android.exoplayer2.ui.AspectRatioFrameLayout&gt;</span><br></pre></td></tr></table></figure></p>
<p>该布局只要id与源码中对应即可随意定制，我在里面只是申明了一个<code>AspectRatioFrameLayout</code>和一个自定义的控制器，如果我们不想用该框架的默认控制器<code>PlaybackControlView</code>，可以自定义该控制器，控制器的自定义逻辑和<code>SimpleExoPlayerView</code>一样，也是通过申明id的方式来控制View的逻辑，并且该View不是final类，因此可以继承<code>PlaybackControlView</code>来实现自己的逻辑。<code>PlayControlView</code>就是继承<code>PlaybackControlView</code>来实现的自定义逻辑，我们可以直接通过找id的方式来获取<code>PlaybackControlView</code>里的控件，因此，里面的所有控件是可定制的。<br>可是，我们的<code>SimpleExoPlayerView</code>是一个final类，如果需要实现<code>SimpleExoPlayerView</code>没有的功能，我们需要将<code>SimpleExoPlayerView</code>的代码复制一份出来来达到修改的目的。</p>
]]></content>
      
        <categories>
            
            <category> Android视频播放 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ExoPlayer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[高效资源搜罗合集，不看保证后悔(持续更新)]]></title>
      <url>/Efficientresourcessearchtogethernoguaranteeofregret.html</url>
      <content type="html"><![CDATA[<p><strong>版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起.</strong></p>
<hr>
<blockquote>
<p>恭喜你发现了这篇博文，看了这篇博文，jay帮你打开新世界的大门，多年老司机开车，请系好安全带。</p>
</blockquote>
<h4 id="搜索篇-什么？说起搜索你只知道baidu-那你就out了"><a href="#搜索篇-什么？说起搜索你只知道baidu-那你就out了" class="headerlink" title="搜索篇(什么？说起搜索你只知道baidu?那你就out了)"></a>搜索篇(什么？说起搜索你只知道baidu?那你就out了)</h4><a id="more"></a>
<p><strong>快搜</strong>：<a href="http://search.chongbuluo.com/" target="_blank" rel="noopener">http://search.chongbuluo.com/</a></p>
<p><img src="http://p07lh1fh6.bkt.clouddn.com/%E5%BF%AB%E6%90%9C%20-%20%E6%90%9C%E7%B4%A2%E5%BF%AB%E4%BA%BA%E4%B8%80%E6%AD%A5%20-%20Google.png" alt=""></p>
<p>看图就知道，各种资源应有尽有，只有你想不到，没有你搜不到，强烈推荐</p>
<p><strong>西林街搜索</strong>：<a href="http://www.xilinjie.com/" target="_blank" rel="noopener">http://www.xilinjie.com/</a></p>
<p><img src="http://p07lh1fh6.bkt.clouddn.com/xilingjie.png" alt=""></p>
<p>各种电影资源,考试资料，都有，搜索比较精准，推荐</p>
<p><strong>WolframAlpha</strong> :<a href="http://www.wolframalpha.com/" target="_blank" rel="noopener">http://www.wolframalpha.com/</a><br>国外网站，就不放图了，可以在线解答问题，不管是数学，历史，生活，等等，都能帮你回答</p>
<p><strong>StackExchange</strong>： <a href="https://stackexchange.com/" target="_blank" rel="noopener">https://stackexchange.com/</a><br>国外的’知乎’,里面的问题和回答的质量很高，英语好的可以经常逛逛</p>
<p><strong>Github</strong>：<a href="http://www.github.com/" target="_blank" rel="noopener">http://www.github.com/</a><br>全球最大代码托管平台，没有程序员不知道的吧，在这里你可以找到各种开源项目和共享资源，比如谷歌镜像，host地址分享等</p>
<p><strong>种子搜索类(实在太多，随便列几个)</strong></p>
<p><strong>BTZO</strong> :<a href="http://www.btzo.net/" target="_blank" rel="noopener">http://www.btzo.net/</a><br><img src="http://p07lh1fh6.bkt.clouddn.com/BTAVA%20-%20BTSOW%20-%20BTSO%20-%20AVMOO%20-%20BTAVMO%20-%20BTZO.com%20%281%29.png-suofang" alt=""><br>电影资源挺丰富的，各种vip电影都有</p>
<p><strong>胖次搜索</strong> ：<a href="http://www.panc.cc/" target="_blank" rel="noopener">http://www.panc.cc/</a><br><img src="http://p07lh1fh6.bkt.clouddn.com/Panc.cc-%E8%83%96%E6%AC%A1%E7%BD%91%E7%9B%98%E6%90%9C%E7%B4%A2%20-%20%E8%83%96%E6%AC%A1%E5%88%86%E4%BA%AB%E7%A4%BE%E5%8C%BA%20-%20%E6%88%91%E4%BB%AC%E7%83%AD%E7%88%B1%E5%88%86%E4%BA%AB%20%281%29.png" alt=""></p>
<p>界面相当可爱有木有，当然资源也是相当多的</p>
<p><strong>网盘搜索</strong></p>
<p><strong>网盘搜</strong> ：<a href="http://www.wangpansou.com/" target="_blank" rel="noopener">http://www.wangpansou.com/</a><br>你是不是经常遇到想要的资源百度链接又失效了，不要害怕，使用了网盘搜，全网资源一网打尽，再也不需要等待别人分享资源了。</p>
<h4 id="图片类（设计师福利）"><a href="#图片类（设计师福利）" class="headerlink" title="图片类（设计师福利）"></a>图片类（设计师福利）</h4><p><strong>Everypixel</strong> : <a href="https://everypixel.com/" target="_blank" rel="noopener">https://everypixel.com/</a><br>国外图片搜索类网站</p>
<p><strong>图虫网</strong>        <a href="https://tuchong.com/" target="_blank" rel="noopener">https://tuchong.com/</a></p>
<p><img src="http://p07lh1fh6.bkt.clouddn.com/%E5%9B%BE%E8%99%AB%E7%BD%91%20-%20%E6%9C%80%E5%A5%BD%E7%9A%84%E6%91%84%E5%BD%B1%E5%B8%88%E9%83%BD%E5%9C%A8%E8%BF%99%20%281%29%20%281%29.png" alt=""></p>
<p>摄影爱好者必备</p>
<p><strong>Pixabay</strong>  : <a href="https://pixabay.com/" target="_blank" rel="noopener">https://pixabay.com/</a></p>
<p><img src="http://p07lh1fh6.bkt.clouddn.com/%E5%85%8D%E8%B4%B9%E5%9B%BE%E7%89%87%20-%20Pixabay.png" alt=""></p>
<p>嗯，免费高清图片！！！！</p>
<p><strong>Pexels</strong> : <a href="https://www.pexels.com/" target="_blank" rel="noopener">https://www.pexels.com/</a><br><img src="http://p07lh1fh6.bkt.clouddn.com/Free%20stock%20photos%20%C2%B7%20Pexels%20%281%29.png" alt=""><br>国外网站，素材很多而且免费。</p>
<p><strong>500PX</strong>：<a href="https://500px.com/" target="_blank" rel="noopener">https://500px.com/</a><br><img src="http://p07lh1fh6.bkt.clouddn.com/%E6%9C%80%E5%87%BA%E8%89%B2%E7%9A%84%E6%91%84%E5%BD%B1%E7%A4%BE%E5%8C%BA%20%20%20500px%20%281%29.png" alt=""></p>
<p>号称最出色的摄影专区，嗯，值得一试</p>
<p>还有几个找icon的网站：<br><strong>iconFont</strong> <a href="http://www.iconfont.cn/" target="_blank" rel="noopener">http://www.iconfont.cn/</a><br>阿里矢量图库，里面有许多app的图片资源和icon，并且提供svg和图标颜色转换，我平时仿写app就是用的它来找icon的</p>
<p><strong>easyicon</strong> :<a href="http://www.easyicon.net/iconsearch/See/" target="_blank" rel="noopener">http://www.easyicon.net/iconsearch/See/</a><br>一个icon图标搜索网站</p>
<p>此外，还有百度的百度识图也不错，有时候找到了一张非高清的图可以通过它找到高清的图：<br><a href="http://image.baidu.com/?fr=shitu" target="_blank" rel="noopener">http://image.baidu.com/?fr=shitu</a></p>
<h4 id="影视类（高清电影在线观看）"><a href="#影视类（高清电影在线观看）" class="headerlink" title="影视类（高清电影在线观看）"></a>影视类（高清电影在线观看）</h4><p>推荐几个在线观看电影的网站，没有广告哦,当然，这种网站现在很多，毕竟流量很大<br><strong>yy6080</strong> ：<a href="http://www.yy6080.org/" target="_blank" rel="noopener">http://www.yy6080.org/</a>,<br>类似还有80s(老牌电影网站),人人影视，天天美剧,1905电影网，BT天堂，童话村，这里就不贴地址了，百度就能找到</p>
<h4 id="音乐类（high到停不下来）"><a href="#音乐类（high到停不下来）" class="headerlink" title="音乐类（high到停不下来）"></a>音乐类（high到停不下来）</h4><p>强烈安利一款听歌神器：<br><strong>listen1</strong> :<a href="http://listen1.github.io/listen1/" target="_blank" rel="noopener">http://listen1.github.io/listen1/</a><br><img src="http://p07lh1fh6.bkt.clouddn.com/%E2%96%B6%20%E9%9A%94%E7%83%9F%E6%B0%B4%EF%BC%88Cover%20%E6%99%83%E5%84%BF%EF%BC%89%20-%20%E7%89%B9%E6%9B%BC%20%281%29.png" alt=""><br>这是一款谷歌浏览器插件，当你想听某一首有版权的歌，QQ音乐有这首歌的版权，而网易云没有，而你使用的是网易云，而你又想听这首歌，这个时候你就不得不使用QQ音乐播放器，是不是很闹心，这个插件的作用就是集结了三大主流平台的音乐，让你免去切播放器的烦恼，从此一次性可以听3个音乐平台的歌了。</p>
<p><strong>5Sing</strong> : <a href="http://5sing.kugou.com/index.html" target="_blank" rel="noopener">http://5sing.kugou.com/index.html</a><br>它是一个原创音乐基地，有许多的原创和翻唱伴奏歌曲。</p>
<h4 id="软件工具类（谁用谁知道）"><a href="#软件工具类（谁用谁知道）" class="headerlink" title="软件工具类（谁用谁知道）"></a>软件工具类（谁用谁知道）</h4><p>手机app:<br><strong>藏书库</strong> : <a href="http://www.geeboo.com/" target="_blank" rel="noopener">http://www.geeboo.com/</a></p>
<p>藏书馆，是读书爱好者在移动互联网空间里的专属私人图书馆，它通过共享借阅的模式，实现了书友间海量书籍的线上互借。</p>
<p><strong>网易蜗牛读书</strong>：<a href="http://du.163.com/" target="_blank" rel="noopener">http://du.163.com/</a><br>全网每天有1小时的免费读书时间，比较有特色</p>
<p>网站：<br><strong>TinyPNG</strong>:<a href="https://tinypng.com/" target="_blank" rel="noopener">https://tinypng.com/</a><br>这是一款可以在线压缩图片的网站，压缩后图片质量还挺好的，本人一直在用</p>
<p><strong>135编辑器</strong>：<a href="http://www.135editor.com/" target="_blank" rel="noopener">http://www.135editor.com/</a><br>如果你正在运营一个公众号，那么在公众号里写文章就可以使用这个网站，里面的公众号模板和排版个人一直很喜欢</p>
<p>另外，安利一个淘软件的神器网站：52破解论坛:<a href="https://www.52pojie.cn/" target="_blank" rel="noopener">https://www.52pojie.cn/</a><br>里面汇聚360，腾讯，阿里等安全大牛，每天都有原创破解软件发布，惊喜多多哦~~</p>
<p>资源暂时分享到这，后期还会持续更新，码字不易，如果觉得对你有帮助，不如点击下方赞赏按钮请我喝杯咖啡，另外，你可以按下Ctrl+D收藏该网址或者分享给好友，防止下次找不到了哦~~</p>
]]></content>
      
        <categories>
            
            <category> 资源整合 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> tools </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一看就懂的自定义顶部粘性下拉控件TouchPullView全面剖析]]></title>
      <url>/%E4%B8%80%E7%9C%8B%E5%B0%B1%E6%87%82%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E9%A1%B6%E9%83%A8%E7%B2%98%E6%80%A7%E4%B8%8B%E6%8B%89%E6%8E%A7%E4%BB%B6TouchPullView%E5%85%A8%E9%9D%A2%E5%89%96%E6%9E%90.html</url>
      <content type="html"><![CDATA[<p><strong>版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起.</strong></p>
<hr>
<blockquote>
<p>昨天在慕课上看到了一个自定义粘性头部的实现，发现现在有许多的app都有这个效果，于是跟着慕课上得视频敲了一遍。因为慕课上的老师对于后半部分的坐标运算讲的并不是很细致，因此我自己分析了一下源代码，总结了这篇博客，希望对同学们有所帮助。</p>
</blockquote>
<p>慕课视频地址：<a href="https://www.imooc.com/learn/830" target="_blank" rel="noopener">https://www.imooc.com/learn/830</a><br>源码下载地址：<a href="https://github.com/Jay-huangjie/TouchPullView" target="_blank" rel="noopener">https://github.com/Jay-huangjie/TouchPullView</a><br>建议大家先下载源码再来观看<br><a id="more"></a></p>
<h4 id="用到的知识点"><a href="#用到的知识点" class="headerlink" title="用到的知识点"></a>用到的知识点</h4><p><strong>我们先来复习一下需要用到的数学知识点</strong></p>
<p>三角函数：</p>
<ul>
<li>sin =  a/c;     </li>
<li>cos = b/c;         </li>
<li>tan = a/b;<br><img src="https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268/sign=1966ca03a0cc7cd9fa2d33df01032104/9825bc315c6034a8eb16696fc81349540823766c.jpg" alt=""></li>
</ul>
<p>贝塞尔曲线：<br><img src="https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D325/sign=391820be267f9e2f74351b0a2a31e962/91529822720e0cf34f59dca30b46f21fbe09aa38.jpg" alt=""></p>
<p>阅读本文需要了解自定义View的基本流程和贝塞尔曲线的绘制。</p>
<p>好，进入正题，我们先看一下它的运行效果：</p>
<p><img src="http://p07lh1fh6.bkt.clouddn.com/touch_demo.gif-sy" alt="效果图"></p>
<p>emmmmm,效果感觉还不错~</p>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>既然是拖动，肯定是基于Touch事件来实现的，通过Touch的Y坐标获取到拖动进度progress,然后通过requestLayout方法不断重绘界面，在onSizeChanged方法中通过计算不断移动圆心坐标，圆的左右两边是经典的贝塞尔曲线，只要获取到控制点和结束点的坐标就能绘制出来，通过控制点的不断移动和onDraw方法中的画布的不断移动来达到弹性和顶部两个起始点向中心靠拢的效果，中间的圆心与旁边的间距部分则是使用的drawable的Bounds效果,回弹则是利用的属性动画的addUpdateListener接口将progress数值由大到小执行回去从而达到的回弹效果</p>
<h4 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h4><p>光看原理肯定是四脸蒙蔽，还是结合代码分析才能达到事半功倍的效果。<br>我们先看OnTouch部分的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">findViewById(R.id.ll_mainLayout).setOnTouchListener(<span class="keyword">new</span> View.OnTouchListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View v, MotionEvent event)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> actionMasked = event.getActionMasked();</span><br><span class="line">                <span class="keyword">switch</span> (actionMasked) &#123;</span><br><span class="line">                    <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                        mTouchStartY = event.getY();</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                        <span class="keyword">float</span> y = event.getY();</span><br><span class="line">                        <span class="keyword">if</span> (y &gt;= mTouchStartY) &#123;  <span class="comment">//表示向下移动</span></span><br><span class="line">                            <span class="keyword">float</span> moveSize = y - mTouchStartY;</span><br><span class="line">                            <span class="keyword">float</span> progress = moveSize &gt; TOUCH_MOVE_MAX_Y ?</span><br><span class="line">                                    <span class="number">1</span> : moveSize / TOUCH_MOVE_MAX_Y;   <span class="comment">//计算进度值</span></span><br><span class="line">                            touchView.setProgress(progress);</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                        touchView.release();</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></p>
<p>这里还是比较简单，通过getY获取滑动的距离，按下去有一个点，滑动后有一个点，两点之间的距离就是我们的<br>moveSize了，由于progress是指当前滑动的进度值，取值肯定是在0~1之间，因此，当moveSize大于我们预设的最大值时，progress就返回1，否则就返回具体的进度值，最后在设置给touchView，touchView就会进行重绘。</p>
<p>再来看下TouchPullView里面的代码：<br>我们先看一下变量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Paint mCirclePaint = <span class="keyword">new</span> Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> mCircleRadius = <span class="number">50</span>; <span class="comment">//圆的半径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> mCirclePointX, mCirclePointY; <span class="comment">//圆心坐标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mDargHeight = <span class="number">400</span>;  <span class="comment">//最大可下拉的高度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> mProgress;  <span class="comment">//下拉进度值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mTargetWidth = <span class="number">400</span>; <span class="comment">//目标宽度</span></span><br><span class="line">    <span class="keyword">private</span> Path mPath = <span class="keyword">new</span> Path(); <span class="comment">//贝塞尔路径</span></span><br><span class="line">    <span class="keyword">private</span> Paint mPathPaint = <span class="keyword">new</span> Paint(Paint.ANTI_ALIAS_FLAG); <span class="comment">//贝塞尔画笔</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mTargetGravityHeight = <span class="number">10</span>; <span class="comment">//重心点最终高度，决定控制点的Y坐标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mTargetAngle = <span class="number">105</span>; <span class="comment">//角度变换 0~135</span></span><br><span class="line">    <span class="keyword">private</span> Interpolator mProgessInterpolator = <span class="keyword">new</span> DecelerateInterpolator(); <span class="comment">//一个由快到慢的插值器</span></span><br><span class="line">    <span class="keyword">private</span> Interpolator mTanentAngleInterpolator;</span><br><span class="line">    <span class="keyword">private</span> Drawable content = <span class="keyword">null</span>; <span class="comment">//中心圆drawable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mContentDrawableMargin = <span class="number">0</span>; <span class="comment">//中心圆Drawable边距</span></span><br></pre></td></tr></table></figure></p>
<p>大部分变量都简洁明了，mTargetGravityHeight规定了控制点上下浮动的最大距离，该值越大，控制点越往下移，mTargetAngle规定了结束点与圆心连线的那个角度的最大变幻值，因为不规定可以看到结束点会围绕圆心做圆环运动，最终导致变形，这不是我们希望看到的。mTargetWidth则规定了该控件能缩小的最小宽度。</p>
<p>接下来看onDraw()方法的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line">        <span class="comment">//基础坐标系改变</span></span><br><span class="line">        <span class="keyword">int</span> count = canvas.save();</span><br><span class="line">        <span class="comment">//获取平移画布的X的值,随着下滑起始点的坐标移动</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> transX = (getWidth() - getValueByLine(getWidth(), mTargetWidth, mProgress)) / <span class="number">2</span>;</span><br><span class="line">        canvas.translate(transX, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//绘制贝塞尔</span></span><br><span class="line">        canvas.drawPath(mPath, mPathPaint);</span><br><span class="line">        <span class="comment">//画圆</span></span><br><span class="line">        canvas.drawCircle(mCirclePointX, mCirclePointY, mCircleRadius, mCirclePaint);</span><br><span class="line">        <span class="comment">//绘制Drawable</span></span><br><span class="line">        Drawable drawable = content;</span><br><span class="line">        <span class="keyword">if</span> (drawable != <span class="keyword">null</span>) &#123;</span><br><span class="line">            canvas.save();</span><br><span class="line">            canvas.clipRect(drawable.getBounds());</span><br><span class="line">            drawable.draw(canvas);</span><br><span class="line">            canvas.restore();</span><br><span class="line">        &#125;</span><br><span class="line">        canvas.restoreToCount(count);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>getValueByLine</code>方法的作用是获取某一时刻贝塞尔曲线上的点的坐标，看一下它的方法实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取某一时刻的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> star      起始点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end       结束点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mProgress 当前进度值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">float</span> <span class="title">getValueByLine</span><span class="params">(<span class="keyword">float</span> star, <span class="keyword">float</span> end, <span class="keyword">float</span> mProgress)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> star + (end - star) * mProgress;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>它就是一个贝塞尔曲线公式Bt = P0+(P1-P0)*t，传入初始坐标P0和结束坐标P1和时间t，就能获取到Bt了。<br>接着它得到了一个transX,它等于起始点与屏幕左右的距离，通过画布的移动来实现起始点不断靠拢的效果，接下来是绘制贝塞尔曲线，画圆，根据Bounds大小添加Drawable到画布上。</p>
<p>接下来分析我们的重点：onSizeChanged中的实现,关键是这个方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updatePathLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> progress = mProgessInterpolator.getInterpolation(mProgress);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取所有的可绘制的宽/高  此值会根据progress不断的变化</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> w = getValueByLine(getWidth(), mTargetWidth, mProgress);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> h = getValueByLine(<span class="number">0</span>, mDargHeight, mProgress);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//圆心X坐标</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> cPointX = w / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//半径</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> cRadius = mCircleRadius;</span><br><span class="line">        <span class="comment">//圆心Y坐标</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> cPaintY = h - cRadius;</span><br><span class="line">        <span class="comment">//控制点结束Y的值</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> endPointY = mTargetGravityHeight;</span><br><span class="line">        <span class="comment">//更新圆心坐标</span></span><br><span class="line">        mCirclePointX = cPointX;</span><br><span class="line">        mCirclePointY = cPaintY;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Path path = mPath;</span><br><span class="line">        path.reset(); <span class="comment">//重置</span></span><br><span class="line">        path.moveTo(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//坐标系是以最左边的起始点为原点</span></span><br><span class="line">        <span class="keyword">float</span> lEndPointX, lEndPointY; <span class="comment">//结束点的X,Y坐标</span></span><br><span class="line">        <span class="keyword">float</span> lControlPointX, lControlPointY; <span class="comment">//控制点的X，Y坐标</span></span><br><span class="line">        <span class="comment">//获取当前切线的弧度</span></span><br><span class="line">        <span class="keyword">double</span> angle = mTanentAngleInterpolator.getInterpolation(progress) * mTargetAngle;<span class="comment">//获取当前的角度</span></span><br><span class="line">        <span class="keyword">double</span> radian = Math.toRadians(angle); <span class="comment">//获取当前弧度</span></span><br><span class="line">        <span class="keyword">float</span> x = (<span class="keyword">float</span>) (Math.sin(radian) * cRadius);  <span class="comment">//求出“股”的长度（长的那条直角边）</span></span><br><span class="line">        <span class="keyword">float</span> y = (<span class="keyword">float</span>) (Math.cos(radian) * cRadius);  <span class="comment">//求出“勾”的长度（短的那条直角边）</span></span><br><span class="line">        lEndPointX = cPointX - x; <span class="comment">//以起始点为原点，x坐标就等于圆的X坐标减去股的长度</span></span><br><span class="line">        lEndPointY = cPaintY + y; <span class="comment">//以起始点为原点，y坐标就等于圆的y坐标加上勾的长度</span></span><br><span class="line">        lControlPointY = getValueByLine(<span class="number">0</span>, endPointY, progress);<span class="comment">//获取控制点的Y坐标</span></span><br><span class="line">        <span class="keyword">float</span> tHeight = lEndPointY - lControlPointY; <span class="comment">//结束点与控制点的Y坐标差值</span></span><br><span class="line">        <span class="keyword">float</span> tWidth = (<span class="keyword">float</span>) (tHeight / Math.tan(radian));  <span class="comment">//通过计算两个角度是相等的，因此弧度依旧适用</span></span><br><span class="line">        lControlPointX = lEndPointX - tWidth; <span class="comment">//结束点的x - ‘勾’ 的长度求出了控制点的X坐标</span></span><br><span class="line"></span><br><span class="line">        path.quadTo(lControlPointX, lControlPointY, lEndPointX, lEndPointY); <span class="comment">//画左边贝塞尔曲线</span></span><br><span class="line">        path.lineTo(cPointX + (cPointX - lEndPointX), lEndPointY); <span class="comment">//左右两个结束点相连</span></span><br><span class="line">        path.quadTo(cPointX + (cPointX - lControlPointX), lControlPointY, w, <span class="number">0</span>); <span class="comment">//画右边贝塞尔曲线</span></span><br><span class="line"></span><br><span class="line">        updateContentLayout(cPointX, cPaintY, cRadius);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测量并设置中心Drawable</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> radius</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateContentLayout</span><span class="params">(<span class="keyword">float</span> cx, <span class="keyword">float</span> cy, <span class="keyword">float</span> radius)</span> </span>&#123;</span><br><span class="line">        Drawable drawable = content;</span><br><span class="line">        <span class="keyword">if</span> (drawable != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> margin = mContentDrawableMargin;</span><br><span class="line">            <span class="keyword">int</span> l = (<span class="keyword">int</span>) (cx - radius + margin);</span><br><span class="line">            <span class="keyword">int</span> r = (<span class="keyword">int</span>) (cx + radius - margin);</span><br><span class="line">            <span class="keyword">int</span> t = (<span class="keyword">int</span>) (cy - radius + margin);</span><br><span class="line">            <span class="keyword">int</span> b = (<span class="keyword">int</span>) (cy + radius - margin);</span><br><span class="line">            drawable.setBounds(l, t, r, b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>其中每一行我都备注了注释，要理解其中的计算，就得先上个图：</p>
<p><img src="http://p07lh1fh6.bkt.clouddn.com/touchpullview.jpg-sy" alt=""></p>
<p>我们脑海中要有一个清晰的定义，整个坐标系是基于起始点为原点，向右下延伸X，Y轴，左右的贝塞尔曲线是由一支画笔完成,通过lineTo相连接，因此整个曲线呈V字形。<br>接下来看代码：<br>首先求得了progress，这个无需解释，使用加速器只是为了更好的效果。<br>接下来是w和h,这是控件的某一进度下的宽和高，为什么通过getValueByLine方法就能得到呢？请看输入的参数，起始点是getWidth，也就是整个屏幕的宽度，终点是mTargetWidth也就是我们规定的最小宽度，而getValueByLine正好是求得某一时刻的贝塞尔值，因此将progress输入正好求得从整个屏幕运动到最小宽度之间的某一个宽度，高度同理。<br>宽高求出来了那个圆心的坐标也就相应出来了，注意整个圆的大小包含margin值，也就是圆与左右两边的边距也是包含的。因为mTargetGravityHeight是我们设定的控制点下移的高度，因此也就是控制点Y的坐标。<br>因为quadTo方法需要控制点的坐标和结束点的坐标，因此求出这两个点的坐标就大功告成了，接下来就是数学知识了。<br>首先，通过插值器的方法获得了某一时刻的角度，最后通过Math方法得到了弧度,也就是图中b的角度，半径我们是知道的，所以通过sin可以得出图中x的长度，然后通过半径的x坐标减去x的长度就得到了结束点的x坐标。<br>通过cos我们可以得到y的长度,圆心Y的坐标加上y的坐标就得到了结束点y的坐标，lEndPointX，lEndPointY的值也就得到了。<br>因为我们已知控制点上下运行的起始值和最大值，因此我们可以使用getValueByLine获取到当前的y坐标，接下来只需要求出控制点的x坐标就行了,tHeight表示左边这条直角的长直角边，结束点的y坐标已知，控制点的y坐标已知，因此可以求出tHeight。<br>因为平行线间的角度相等，因此a = c，又因为c+d = e+d = 90; 所以c = e；所以a = e;tHeight已知，e已知，所以tWidth的值就能求出来了。所以控制点的x坐标就等于结束点的x坐标减去tWidth。至此所有的坐标都已经求出来了，所以贝塞尔曲线也就能绘制出来了。</p>
<p>接下来还有个测量的过程，逻辑比较简单：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> MIN_W = (<span class="keyword">int</span>) (mCircleRadius * <span class="number">2</span> + getPaddingLeft() + getPaddingRight()); <span class="comment">//需要的最小宽度</span></span><br><span class="line">       <span class="keyword">int</span> MIN_H = (<span class="keyword">int</span>) ((mDargHeight * mProgress + <span class="number">0.5f</span>)  <span class="comment">//mDargHeight * mProgress = moveSize(即actionMove.getY - actionDown.getY),+0.5f为四舍五入</span></span><br><span class="line">               + getPaddingBottom() + getPaddingTop());</span><br><span class="line">       <span class="keyword">int</span> widthMeasure = getMeasureSize(widthMeasureSpec, MIN_W);</span><br><span class="line">       <span class="keyword">int</span> heightMeasure = getMeasureSize(heightMeasureSpec, MIN_H);</span><br><span class="line">       setMeasuredDimension(widthMeasure, heightMeasure);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取所需要的宽/高的测量结果</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> Spec     测量模式</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> minValue 规定的最小值</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 测量结果</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMeasureSize</span><span class="params">(<span class="keyword">int</span> Spec, <span class="keyword">int</span> minValue)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> result;</span><br><span class="line">       <span class="keyword">int</span> mode = MeasureSpec.getMode(Spec);</span><br><span class="line">       <span class="keyword">int</span> size = MeasureSpec.getSize(Spec);</span><br><span class="line">       <span class="keyword">switch</span> (mode) &#123;</span><br><span class="line">           <span class="keyword">case</span> MeasureSpec.AT_MOST: <span class="comment">//wrap_content</span></span><br><span class="line">               result = Math.min(size, minValue); <span class="comment">//取测量值和规定的最小宽度中的最小值</span></span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> MeasureSpec.EXACTLY: <span class="comment">//match_parent or exactly num</span></span><br><span class="line">               result = size;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">default</span>: <span class="comment">//其余情况取最小值</span></span><br><span class="line">               result = minValue;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>我将视频中的代码做了一下简单的封装，代码中有详细的注释，我这里就不做分析了。</p>
<p>整个分析流程就到这，如果有错误的地方，欢迎指正，Thanks~</p>
]]></content>
      
        <categories>
            
            <category> Android基础进阶 </category>
            
            <category> 安卓特效合集解析 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[安卓View体系-View的工作流程]]></title>
      <url>/%E5%AE%89%E5%8D%93View%E4%BD%93%E7%B3%BB-View%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.html</url>
      <content type="html"><![CDATA[<blockquote>
<p>自定义View三部曲：onMeasure –&gt; onLayout –&gt;onDraw,本文着重解析前两个方法</p>
</blockquote>
<h4 id="onMeasure"><a href="#onMeasure" class="headerlink" title="onMeasure"></a>onMeasure</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>提到这个方法，就必须先了解MeasureSpec这个类，它有一个getMode和getSize方法，用于获取SpecMode和SpecSize,那么这两个参数又是何物呢？<br>请看以下一般自定义View的完整实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">          setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(),widthMeasureSpec),getDefaultSize(getSuggestedMinimumHeight(),heightMeasureSpec));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size,<span class="keyword">int</span> measureSpec)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> result = size;</span><br><span class="line">       <span class="keyword">int</span> SpecMode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">       <span class="keyword">int</span> SpecSize = MeasureSpec.getSize(measureSpec);</span><br><span class="line">       <span class="keyword">switch</span> (SpecMode)&#123;</span><br><span class="line">           <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">               result = size;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">                   <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">                       result = SpecSize;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，SpecMode是指测量的模式，它有三种模式：</p>
<p><strong>UNSPECIFIED</strong><br>代表父容器不对View有任何的大小限制，一般用于系统的内部，很少用到</p>
<p><strong>AT_MOST</strong><br>代表父容器指定了一个大小即SpecSize,View的大小不能大于这个值，它对应于LayoutParams中的wrap_content，结合它你就很好理解了</p>
<p><strong>EXACTLY</strong><br>父容器已经检测到了view所需的精确大小，这时的view的最终大小就是SpecSize中的值，它对应于LayoutParam中的match_parent或者具体的数值</p>
<p>而SpecSize是指某种模式下的规格大小。</p>
<p>因此，结合此方法，当view的大小是wrap_content或者是match_parent或者是具体的数值时，都是使用的父容器给子view测量的specsize的值，当父容器对子view没有任何约束时，给view一个所规定的最小值（getSuggestedMinimum…方法获取）,setMeasuredDimension就是用来设置view的测量大小的。MeasureSpec类的值的获取是由父容器的MeasureSpec和自身的LayoutParams来共同确定的，MeasureSpec一旦确定，onMeasure中就可以确定view的测量宽高了。</p>
<p>这里再来讲解一下getSuggestedMinimumWidth这类方法，它的逻辑是这样的：<br>如果View没有设置背景，那么它会返回minWidth设置的值，可以为0，如果view设置了背景，那么它会返回minWidth和背景最小宽度的两者之间的最大值。</p>
<p>一般的自定义View我们主要是着重处理AT_MOST模式的值，需要根据实际的情况来，没有固定的依据，有兴趣的可以看下TextView等控件的源码是怎么处理的。</p>
<p><strong>Activity中View的宽/高获取</strong><br>通过以上分析读者已经知道View的宽高是需要父容器去测量的，因此我们如果在onCreate或者onStar方法中去获取View的宽高发现并不能保证百分百获取到，那么有什么方法能解决这个问题呢，以下有4个方法能解决这个问题：</p>
<p><strong>1.onWindowFocusChanged</strong><br>当Activity的窗口得到焦点或失去焦点都会被调用一次,并且此时View已经初始化完毕，因此此时去获取View的宽高是没问题的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onWindowFocusChanged</span><span class="params">(<span class="keyword">boolean</span> hasFocus)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>.onWindowFocusChanged(hasFocus);</span><br><span class="line">       <span class="keyword">if</span> (hasFocus)&#123;</span><br><span class="line">           <span class="keyword">int</span> width = view.getMeasuredWidth();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>2.view.post(runnable)</strong><br>通过post可以将一个runnable投递到消息队列的尾部，然后等待Looper调用此runnable的时候，view此时也已经初始化好了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">view.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">int</span> width = view.getMeasuredWidth();    </span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure></p>
<p><strong>3.ViewTreeObserver</strong><br>使用ViewTreeObserver这个类的回调可以完成，比如OnGlobalLayoutListener，当View树的状态改变或者内部view的可见性发生改变时，该接口会被回调，注意，此接口会回调多次。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ViewTreeObserver viewTreeObserver = view.getViewTreeObserver();</span><br><span class="line">       viewTreeObserver.addOnGlobalLayoutListener(<span class="keyword">new</span> ViewTreeObserver.OnGlobalLayoutListener() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onGlobalLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               view.getViewTreeObserver().removeOnGlobalLayoutListener(<span class="keyword">this</span>);</span><br><span class="line">               <span class="keyword">int</span> width = view.getMeasuredWidth();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure></p>
<p><strong>4.view.measure(int widthMeasureSpec, int heightMeasureSpec)</strong><br>手动对view进行测量来得出view的宽高，这种实现比较的复杂，需要看view的LayoutParam：</p>
<p><em>match_parent</em><br>无法得出View的宽/高，因为此种情况需要获取到父容器的剩余空间，而此时我们是获取不到的</p>
<p><em>具体的数值</em><br>比如宽/高都是50px,那么我们可以这样写来获取：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> widthMeasureSpec = View.MeasureSpec.makeMeasureSpec(<span class="number">100</span>, View.MeasureSpec.EXACTLY);</span><br><span class="line"><span class="keyword">int</span> heightMeasureSpec = View.MeasureSpec.makeMeasureSpec(<span class="number">100</span>,View.MeasureSpec.EXACTLY);</span><br><span class="line">view.measure(widthMeasureSpec,heightMeasureSpec);</span><br></pre></td></tr></table></figure></p>
<p><em>wrap_content</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">int</span> widthMeasureSpec = View.MeasureSpec.makeMeasureSpec((<span class="number">1</span>&lt;&lt;<span class="number">30</span>)-<span class="number">1</span>, View.MeasureSpec.AT_MOST);</span><br><span class="line"><span class="keyword">int</span> heightMeasureSpec = View.MeasureSpec.makeMeasureSpec((<span class="number">1</span>&lt;&lt;<span class="number">30</span>)-<span class="number">1</span>,View.MeasureSpec.AT_MOST);        </span><br><span class="line">view.measure(widthMeasureSpec,heightMeasureSpec);</span><br></pre></td></tr></table></figure></p>
<p>注意(1&lt;&lt;30)-1这个值，通过查看源码可以知道View的尺寸是使用的30位二进制表示，所以最大值是30个1（2^30-1），也就等于（1&lt;&lt;30）-1，所以给出这个数值是合理的。</p>
<h4 id="onLayout"><a href="#onLayout" class="headerlink" title="onLayout"></a>onLayout</h4><p>onLayout方法是ViewGroup用来给子元素确定位置的，相比如onMeasure方法，onLayout则简单多了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>.onLayout(changed, left, top, right, bottom);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>后四个参数分别代表左，上，右，下，只需返回不同的坐标即可确定View的位置。</p>
]]></content>
      
        <categories>
            
            <category> Android基础进阶 </category>
            
            <category> 安卓View体系 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[安卓View体系:View的一些基本知识点]]></title>
      <url>/%E5%AE%89%E5%8D%93View%E4%BD%93%E7%B3%BB-View%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E7%82%B9.html</url>
      <content type="html"><![CDATA[<blockquote>
<p>安卓开发中熟练使用自定义View是开发者必备的技能，因为安卓原生控件很多时候是不能满足需求的，而自定义控件能做出各种绚丽的效果,用于满足产品各种奇怪的需求(我为什么要用奇怪呢，哈哈哈哈)。</p>
</blockquote>
<h4 id="自定义View要掌握的内容"><a href="#自定义View要掌握的内容" class="headerlink" title="自定义View要掌握的内容"></a>自定义View要掌握的内容</h4><p>自定义View主要是掌握以下五个内容：</p>
<ul>
<li>绘制原理: 掌握onMeasure,onLayout,onDraw及相关类的使用。</li>
<li>事件传递：掌握dispathTouchEvent(),onInterceptEvent(),onTouchEvent()三者的传递逻辑.</li>
<li>动画：属性动画，用于对View进行动画操作</li>
<li>相关手势：GestureDetector，VelocityTracker等类的应用</li>
<li>滑动：滑动的三种实现方法，Scroller的运用</li>
</ul>
<h4 id="自定义View的基本知识"><a href="#自定义View的基本知识" class="headerlink" title="自定义View的基本知识"></a>自定义View的基本知识</h4><h5 id="自定义View的分类"><a href="#自定义View的分类" class="headerlink" title="自定义View的分类"></a>自定义View的分类</h5><p><strong>1. 直接继承View</strong><br>主要用于实现一些不规则的效果，不能通过现有控件扩展的一些效果</p>
<p><strong>2. 继承自viewGroup</strong><br>主要是为了实现自定义的布局，这个布局里包含了一些特定的控件，很像几个view组合在一起</p>
<p><strong>3.继承特定的view</strong><br>主要是为了扩展已有view的功能，比如TextView等</p>
<p><strong>4.继承特定的ViewGroup</strong><br>为了扩展特定的布局，比如LinearLayout</p>
<h5 id="自定义控件的构造函数"><a href="#自定义控件的构造函数" class="headerlink" title="自定义控件的构造函数"></a>自定义控件的构造函数</h5><p>建立一个class类继承自View,实现它的所有的构造方法，那么这个类就是一个可以在xml中使用的自定义View，以下是关于它的构造方法的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jie.demo_01.View;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.support.annotation.Nullable;</span><br><span class="line"><span class="keyword">import</span> android.util.AttributeSet;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">mView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">mView</span><span class="params">(Context context)</span> </span>&#123;  <span class="comment">//在代码中直接new出这个实例会调用这个方法</span></span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">mView</span><span class="params">(Context context, @Nullable AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//在xml中实现会调用这个方法（未指定style）</span></span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">mView</span><span class="params">(Context context, @Nullable AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//为view指定了一个style</span></span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">mView</span><span class="params">(Context context, @Nullable AttributeSet attrs, <span class="keyword">int</span> defStyleAttr, <span class="keyword">int</span> defStyleRes)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//api&gt;21时调用，一般不用实现</span></span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr, defStyleRes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关于构造函数中参数的含义：</p>
<ul>
<li><p>AttributeSet set:  属性值的集合.</p>
</li>
<li><p>int[] attrs:  我们自定义属性集合在R类中生成的int型数组.这个数组中包含了自定义属性的资源ID.</p>
</li>
<li><p>int defStyleAttr:  这是当前Theme中的包含的一个指向style的引用.当我们没有给自定义View设置declare-styleable资源集合时,默认从这个集合里面查找布局文件中配置属性值.传入0表示不向该defStyleAttr中查找默认值.</p>
</li>
<li><p>int defStyleRes:  这个也是一个指向Style的资源ID,但是仅在defStyleAttr为0或者defStyleAttr不为0但Theme中没有为defStyleAttr属性赋值时起作用.</p>
</li>
</ul>
<blockquote>
<p>属性赋值优先级次序表:<br>在布局xml中直接定义 &gt; 在布局xml中通过style定义 &gt; 自定义View所在的Activity的Theme中指定style引用 &gt; 构造函数中defStyleRes指定的默认值</p>
</blockquote>
<h5 id="自定义view的xml赋值"><a href="#自定义view的xml赋值" class="headerlink" title="自定义view的xml赋值"></a>自定义view的xml赋值</h5><p>我们经常可以看到使用xml的属性可以为view进行各种赋值,那么是怎么做到的呢，如图，在values目录下新建一个attrs.xml的文件，文件内容如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;resources&gt;</span><br><span class="line">    &lt;declare-styleable name=<span class="string">"mView"</span>&gt;</span><br><span class="line">        &lt;attr name=<span class="string">"mview_color"</span> format=<span class="string">"color"</span>/&gt;</span><br><span class="line">    &lt;/declare-styleable&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure></p>
<p>我在这里声明了一个mview_color属性，用于定义颜色值，format代表属性的格式，有许多，读者查阅文档即可了解。</p>
<p>接下来,我在View中做如下处理：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">mView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> defultColor = <span class="number">0xFFFFFF6</span>;</span><br><span class="line">    <span class="keyword">int</span> mColor;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">mView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">mView</span><span class="params">(Context context, @Nullable AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, attrs,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">mView</span><span class="params">(Context context, @Nullable AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">        TypedArray t = context.obtainStyledAttributes(attrs, R.styleable.mView);</span><br><span class="line">        mColor = t.getColor(R.styleable.mView_mview_color,defultColor);</span><br><span class="line">        t.recycle(); <span class="comment">//记得回收</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用TypedArray来解析我们定义的属性,接着就赋值给我们的变量，最后回收，这样解析工作就完成了</p>
<p>接下来我们在xml中使用我们的View:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">   <span class="comment">//为了使用自定义属性，必须作此声明，app可以换成其他的名字</span></span><br><span class="line">    xmlns:app=<span class="string">"http://schemas.android.com/apk/res-auto"</span>  </span><br><span class="line">    xmlns:tools=<span class="string">"http://schemas.android.com/tools"</span></span><br><span class="line">    android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">    android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">    tools:context=<span class="string">"com.jie.demo_01.MainActivity"</span>&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;com.jie.demo_01.View.mView</span><br><span class="line">        android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">        android:layout_height=<span class="string">"100dp"</span> </span><br><span class="line">        app:mview_color=<span class="string">"@color/colorAccent"</span>  <span class="comment">//声明我们的自定义属性</span></span><br><span class="line">        /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure></p>
<h5 id="自定义view的绘制"><a href="#自定义view的绘制" class="headerlink" title="自定义view的绘制"></a>自定义view的绘制</h5><p>属性已经定义好了，接下来就是如何使用了，在这里我们重写它的onDraw方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">mView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> defultColor = <span class="number">0xFFFFFF6</span>;</span><br><span class="line">    <span class="keyword">int</span> mColor;</span><br><span class="line">    <span class="keyword">private</span> Paint mPaint = <span class="keyword">new</span> Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">mView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">mView</span><span class="params">(Context context, @Nullable AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, attrs,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">mView</span><span class="params">(Context context, @Nullable AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">        TypedArray t = context.obtainStyledAttributes(attrs, R.styleable.mView);</span><br><span class="line">        mColor = t.getColor(R.styleable.mView_mview_color,defultColor);</span><br><span class="line">        t.recycle(); <span class="comment">//记得回收</span></span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mPaint.setColor(mColor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line">        canvas.drawCircle(<span class="number">200</span>,<span class="number">200</span>,<span class="number">100</span>,mPaint);  <span class="comment">//绘制一个位于200，200处的半径为100的圆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>onDraw方法是view绘制图形图像的地方，通过画布（canvas）和画笔（paint）来灵活的绘制各种图形，这两个类所包含的方法多而全，读者可以多阅读文档来练习绘制各种图形,代码运行如图所示：</p>
<p><img src="http://p07lh1fh6.bkt.clouddn.com/%E5%BA%94%E7%94%A8%E5%AE%9D%E6%88%AA%E5%B1%8F2017121601.png-suofang" alt=""></p>
<h4 id="自定义View的注意事项"><a href="#自定义View的注意事项" class="headerlink" title="自定义View的注意事项"></a>自定义View的注意事项</h4><p>上面的自定义view并不是一个标准的自定义view,标准的自定义view还应该包含onMeasure和onLayout的处理，让其支持wrap_content。</p>
<p>这里要注意了：</p>
<ul>
<li><p>直接继承view或者viewgroup的控件不支持wrap_content,需要在onMeasure中进行特殊的处理才能达到预期的效果</p>
</li>
<li><p>如果有必要的话，需要在draw方法中处理padding，使view控件的padding生效，否则padding是无效的</p>
</li>
<li><p>尽量不在view中使用handler,因为view本身自带了post方法</p>
</li>
<li><p>如果在view中有线程或者动画，要及时关闭，关闭的时机是onDetachedFromWindow方法，当包含此view的Activity退出或者view被remove掉时，此方法会被调用</p>
</li>
<li><p>不要再onDraw方法中作初始化操作，因为这个方法会绘制多次，会产生很多不必要的开销</p>
</li>
<li><p>当View有滑动嵌套的情况，要处理好滑动冲突</p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Android基础进阶 </category>
            
            <category> 安卓View体系 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[安卓IPC机制:AIDL通信的使用和理解]]></title>
      <url>/%E5%AE%89%E5%8D%93IPC%E6%9C%BA%E5%88%B6-AIDL%E9%80%9A%E4%BF%A1%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E7%90%86%E8%A7%A3.html</url>
      <content type="html"><![CDATA[<h4 id="使用情景"><a href="#使用情景" class="headerlink" title="使用情景"></a>使用情景</h4><p>虽然Messenger对AIDL做了封装使其变得更易用，但Messenger只能一个一个的处理接收的数据,当有大量并发的数据涌入时，Messenger就显得不那么合适了,并且Messenger只能用来传递消息，如果需要调用跨进程的方法怎么办呢，这是，AIDL就派上用场了。<br><a id="more"></a></p>
<h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>首先创建一个AIDL文件,在里面声明一些需要用到的方法接口，注意，并不是所有的数据类型在AIDL中都能使用，AIDL能够使用的数据类型如下:</p>
<ul>
<li>基本数据类型</li>
<li>String,CharSequence</li>
<li>ArrayList,里面包含的元素必须支持AIDL</li>
<li>HashMap,里面包含的key和value必须被AIDL支持</li>
<li>Parcelable,所有实现了Parcelable接口的对象</li>
<li>AIDL接口本身也支持</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IBookManager.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.jie.demo_01;</span><br><span class="line"><span class="keyword">import</span> com.jie.demo_01.Book;</span><br><span class="line"><span class="comment">// Declare any non-default types here with import statements</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IBookManager</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;Book&gt; <span class="title">getBookList</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addBook</span><span class="params">(in Book book)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，我在里面引入了Book实体类，按照AIDL的规则，是需要再创建一个Book.aidl文件的，并且需要手动将引入路径导入<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Book.aidl.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.jie.demo_01;</span><br><span class="line">parcelable Book;</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，AIDL中每个实现了Parcelable接口的类都需要按照这种方式创建相应的文件并且申明该类为Parcelable，并且，AIDL中除了基本数据类型，其他的参数都必须标上方向：</p>
<ul>
<li>in 表示输入型的参数</li>
<li>out 表示输出型的参数</li>
<li>inout 表示输入输出型参数<br>并且AIDL不支持声明静态变量。</li>
</ul>
<p>下面是远程服务端的实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jie.demo_01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Service;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.os.Binder;</span><br><span class="line"><span class="keyword">import</span> android.os.IBinder;</span><br><span class="line"><span class="keyword">import</span> android.os.RemoteException;</span><br><span class="line"><span class="keyword">import</span> android.support.annotation.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">mService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CopyOnWriteArrayList&lt;Book&gt; mBookList = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;(); <span class="comment">//支持并发读写的一个类，非Arraylist</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Binder mbinder = <span class="keyword">new</span> IBookManager.Stub() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">getBookList</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mBookList;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(Book book)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">             mBookList.add(book);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mbinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        mBookList.add(<span class="keyword">new</span> Book(<span class="number">1</span>,<span class="string">"Kotlin实战"</span>));</span><br><span class="line">        mBookList.add(<span class="keyword">new</span> Book(<span class="number">2</span>,<span class="string">"编程珠玑"</span>));</span><br><span class="line">        mBookList.add(<span class="keyword">new</span> Book(<span class="number">3</span>,<span class="string">"Java数据与结构算法解析"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>服务端的实现比较简单，主要是通过<code>IBookManager.Stub</code>来获取<code>Binder</code>对象并实现定义的方法,最后在<code>onBind</code>中绑定<code>`Binder</code>对象,其中，<code>IBookManager</code>这个类是自动生成的，位于gen目录的aidl文件夹中,关于该类稍后再做分析。</p>
<p>以下是客户端的实现,也比较简单:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jie.demo_01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.ComponentName;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.content.ServiceConnection;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.os.IBinder;</span><br><span class="line"><span class="keyword">import</span> android.os.RemoteException;</span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ServiceConnection mConnection = <span class="keyword">new</span> ServiceConnection() &#123;  <span class="comment">//Ibind监听，注意绑定是异步的</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName componentName, IBinder iBinder)</span> </span>&#123; <span class="comment">//当与Service建立连接时调用</span></span><br><span class="line">             IBookManager manager = IBookManager.Stub.asInterface(iBinder); <span class="comment">//获取AIDL管理类</span></span><br><span class="line">             <span class="comment">//得到数据</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                List&lt;Book&gt; bookList = manager.getBookList();  <span class="comment">//这里实际上就是调用了Binder中的方法</span></span><br><span class="line">                Log.i(<span class="string">"hj"</span>,<span class="string">"从服务端获取的集合大小:"</span>+bookList.size());</span><br><span class="line">                <span class="keyword">if</span> (bookList.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    Log.i(<span class="string">"hj"</span>,<span class="string">"第一个书名是:"</span>+bookList.get(<span class="number">0</span>).bookName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName componentName)</span> </span>&#123;  <span class="comment">//与Service意外中断时调用</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>,mService.class);</span><br><span class="line">        bindService(intent,mConnection,BIND_AUTO_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        unbindService(mConnection);</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行后打印如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span>-<span class="number">09</span> <span class="number">17</span>:<span class="number">05</span>:<span class="number">46.447</span> <span class="number">19690</span>-<span class="number">19690</span>/? I/hj: 从服务端获取的集合大小:<span class="number">3</span></span><br><span class="line"><span class="number">12</span>-<span class="number">09</span> <span class="number">17</span>:<span class="number">05</span>:<span class="number">46.448</span> <span class="number">19690</span>-<span class="number">19690</span>/? I/hj: 第一个书名是:Kotlin实战</span><br></pre></td></tr></table></figure></p>
<p>运行原理是通过<code>IBookManager.Stub.asInterface</code>方法获取到<code>IBookManager</code>,从而调用里面的方法来实现数据的传递与方法之间的调用，注意，这些方法都是运行在UI线程中的，所以不能有耗时的操作，如果有耗时的操作，应该新开启一个线程来解决。</p>
<p>还有一点需要注意的是，如果有类似于订阅者的实现，在进程通信中，不能简单的用List来管理接口，因为进程中的对象传输后其实变成了两个不同的对象，那么订阅和取消订阅将会失效，因此，系统提供了一个叫<code>RemoteCallbackList</code>的接口专门用来管理跨进程的接口，它的使用也很简单：</p>
<ul>
<li>beginBroadcast()方法会返回该类里所有集合的大小</li>
<li>getBroadcastItem(int position) 返回指定的item</li>
<li>finishBroadcast()  结束遍历</li>
</ul>
<p>通过以上三个方法可以循环遍历订阅者接口来达到取消订阅的目的。注意beginBroadcast和finishBroadcast必须配对使用</p>
<h4 id="IBookManager-类分析"><a href="#IBookManager-类分析" class="headerlink" title="IBookManager 类分析"></a>IBookManager 类分析</h4><p>通过以上的AIDL实现，我们发现了IBookManager类起到了制关重要的作用,所以我们来深入观察一下该类，理解了该类有助于我们更好的使用AIDL.以下是该类的源码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This file is auto-generated.  DO NOT MODIFY.</span></span><br><span class="line"><span class="comment"> * Original file: D:\\MyWork\\Studio_Work\\demo_01\\app\\src\\main\\aidl\\com\\jie\\demo_01\\IBookManager.aidl</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.jie.demo_01;</span><br><span class="line"><span class="comment">// Declare any non-default types here with import statements</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBookManager</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">IInterface</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Local-side IPC implementation stub class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Stub</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">Binder</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">jie</span>.<span class="title">demo_01</span>.<span class="title">IBookManager</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.String DESCRIPTOR = <span class="string">"com.jie.demo_01.IBookManager"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Construct the stub at attach it to the interface.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Stub</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.attachInterface(<span class="keyword">this</span>, DESCRIPTOR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Cast an IBinder object into an com.jie.demo_01.IBookManager interface,</span></span><br><span class="line"><span class="comment">         * generating a proxy if needed.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> com.jie.demo_01.<span class="function">IBookManager <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> ((obj == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">            <span class="keyword">if</span> (((iin != <span class="keyword">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> com.jie.demo_01.IBookManager))) &#123;</span><br><span class="line">                <span class="keyword">return</span> ((com.jie.demo_01.IBookManager) iin);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> com.jie.demo_01.IBookManager.Stub.Proxy(obj);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">                <span class="keyword">case</span> INTERFACE_TRANSACTION: &#123;</span><br><span class="line">                    reply.writeString(DESCRIPTOR);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> TRANSACTION_getBookList: &#123;</span><br><span class="line">                    data.enforceInterface(DESCRIPTOR);</span><br><span class="line">                    java.util.List&lt;com.jie.demo_01.Book&gt; _result = <span class="keyword">this</span>.getBookList();</span><br><span class="line">                    reply.writeNoException();</span><br><span class="line">                    reply.writeTypedList(_result);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> TRANSACTION_addBook: &#123;</span><br><span class="line">                    data.enforceInterface(DESCRIPTOR);</span><br><span class="line">                    com.jie.demo_01.Book _arg0;</span><br><span class="line">                    <span class="keyword">if</span> ((<span class="number">0</span> != data.readInt())) &#123;</span><br><span class="line">                        _arg0 = com.jie.demo_01.Book.CREATOR.createFromParcel(data);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        _arg0 = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">this</span>.addBook(_arg0);</span><br><span class="line">                    reply.writeNoException();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">jie</span>.<span class="title">demo_01</span>.<span class="title">IBookManager</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> android.os.IBinder mRemote;</span><br><span class="line"></span><br><span class="line">            Proxy(android.os.IBinder remote) &#123;</span><br><span class="line">                mRemote = remote;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mRemote;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getInterfaceDescriptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> DESCRIPTOR;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> java.util.List&lt;com.jie.demo_01.Book&gt; getBookList() <span class="keyword">throws</span> android.os.RemoteException &#123;</span><br><span class="line">                android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">                android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">                java.util.List&lt;com.jie.demo_01.Book&gt; _result;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">                    mRemote.transact(Stub.TRANSACTION_getBookList, _data, _reply, <span class="number">0</span>);</span><br><span class="line">                    _reply.readException();</span><br><span class="line">                    _result = _reply.createTypedArrayList(com.jie.demo_01.Book.CREATOR);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    _reply.recycle();</span><br><span class="line">                    _data.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> _result;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(com.jie.demo_01.Book book)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">                android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">                android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">                    <span class="keyword">if</span> ((book != <span class="keyword">null</span>)) &#123;</span><br><span class="line">                        _data.writeInt(<span class="number">1</span>);</span><br><span class="line">                        book.writeToParcel(_data, <span class="number">0</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        _data.writeInt(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    mRemote.transact(Stub.TRANSACTION_addBook, _data, _reply, <span class="number">0</span>);</span><br><span class="line">                    _reply.readException();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    _reply.recycle();</span><br><span class="line">                    _data.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_getBookList = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_addBook = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> java.util.List&lt;com.jie.demo_01.Book&gt; getBookList() <span class="keyword">throws</span> android.os.RemoteException;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(com.jie.demo_01.Book book)</span> <span class="keyword">throws</span> android.os.RemoteException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到该类的结构还是比较清晰的,首先，它申明了getBookList和addBook两个方法，显然这是我在aidl接口中申明的方法，接着，还申明了两个int型的id,TRANSACTION_getBookList 和TRANSACTION_addBook，这两个id是为了在transact过程中区分客户端请求的是哪个方法，接着，它申明了一个内部类Stub,它是一个Binder类，接着还申明了一个Stub的内部代理类，以上就是该类的结构。下面详细介绍一下各个方法的作用</p>
<p>首先是<code>Stub</code> 类的方法：</p>
<p><strong>asInterface(android.os.IBinder obj)</strong><br>传入一个Binder对象，转换成客户端所需要的AIDL接口类型的对象，这种转换是区分进程的，如果服务端和客户端是在一个进程中，那么该方法会返回Stub对象本身，如果是两个进程，那么会返回Stub.proxy对象。</p>
<p><strong>adBinder</strong><br>返回Binder对象.</p>
<p><strong>onTransact（(int code, android.os.Parcel data, android.os.Parcel reply, int flags）</strong><br>该方法是返回一个boolean对象，运行在Binder线程池中，当客户端发起请求，远程会通过系统底层封装后由此方法处理。code参数可以确定客户端请求的方法是什么，data中能取出目标的参数，然后执行目标的方法，当执行完毕后，就向reply中写入返回值（如果有返回值的话），而返回的boolean对象，如果为false,那么客户端会请求失败，因此可以通过这个返回值做权限验证。</p>
<p><code>Proxy</code>中的方法：</p>
<p><strong>getBookList</strong><br>此方法运行在客户端，当客户端远程调用此方法时，它会创建该方法所需要的输入型Parcel对象data,输出型Parcel对象,_reply和返回值对象List,然后将该方法的参数信息写入_data中（如果有参数的话）；接着调用transact方法来发起请求，同时当前线程挂起，然后服务端的onTransatct方法会被调用，直到远程调用返回，当前线程继续执行，并从_reply中取出远程调用过程的返回结果，最后返回_reply数据。</p>
<p><strong>addBook</strong><br>同<code>getBookList</code>一样，因为没有返回值，所以不需要从_reply中取值</p>
<p>整体来说整个类还是易于理解的，大多其实都是偏底层的实现,需要注意的是,客户端通过接口方法发起请求时，当前线程会被挂起直到服务端返回数据，因此，如果一个远程的方法非常耗时，那么就不能在主线程中发起请求，需要另开一个线程。</p>
]]></content>
      
        <categories>
            
            <category> Android基础进阶 </category>
            
            <category> 安卓IPC机制 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[安卓IPC机制:使用Messenger通信]]></title>
      <url>/%E5%AE%89%E5%8D%93IPC%E6%9C%BA%E5%88%B6-%E4%BD%BF%E7%94%A8Messenger%E9%80%9A%E4%BF%A1.html</url>
      <content type="html"><![CDATA[<h4 id="Messenger原理"><a href="#Messenger原理" class="headerlink" title="Messenger原理"></a>Messenger原理</h4><p>Messenger的底层实现是AILD，它是一个Message的载体，通过它可以在不同进程间传递message对象,从而实现数据传递<br><a id="more"></a></p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>代码示例：<br>首先创建一个Service，让它运行在一个单独的进程中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;service android:name=<span class="string">".mService"</span></span><br><span class="line">           android:process=<span class="string">":remote"</span></span><br><span class="line">           /&gt;</span><br></pre></td></tr></table></figure></p>
<p>然后再来看服务端<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">mService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Messenger messenger = <span class="keyword">new</span> Messenger(<span class="keyword">new</span> messengerHandler());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">messengerHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> Constants.MSG_FROM_CLIENT:</span><br><span class="line">                    String clientMsg = msg.getData().getString(<span class="string">"msg"</span>);  <span class="comment">//接收客户端的消息</span></span><br><span class="line">                    Log.i(<span class="string">"hj"</span>,<span class="string">"从客户端接收到的消息:"</span>+clientMsg);</span><br><span class="line">                    Messenger messenger = msg.replyTo;  <span class="comment">//获取客户端发来的Messenger</span></span><br><span class="line">                    Message replyMessage = Message.obtain(<span class="keyword">null</span>,Constants.MSG_FROM_SERVICE);  <span class="comment">//创建一个新的Message对象</span></span><br><span class="line">                    Bundle bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">                    bundle.putString(<span class="string">"reply"</span>, <span class="string">"已收到客户端的消息，稍后回复~"</span>);</span><br><span class="line">                    replyMessage.setData(bundle);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        messenger.send(replyMessage);  <span class="comment">//发送消息给客户端</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> messenger.getBinder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建一个Handler并且传入到Messenger对象中,通过Handler来接收Message对象发来的消息,并且在Service的onBind中返回这个Messager对象底层的Binder。随后我又通过msg.replyTo方法获取到从客户端发来的Messenger对象，用于回复消息给客户端,最后调用send方法发出消息，这样就完成了消息的接收与回复，接下来再看客户端的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jie.demo_01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.ComponentName;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.content.ServiceConnection;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.os.Handler;</span><br><span class="line"><span class="keyword">import</span> android.os.IBinder;</span><br><span class="line"><span class="keyword">import</span> android.os.Message;</span><br><span class="line"><span class="keyword">import</span> android.os.Messenger;</span><br><span class="line"><span class="keyword">import</span> android.os.RemoteException;</span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Messenger messenger;  <span class="comment">//客户端发送消息的messenger</span></span><br><span class="line">    <span class="keyword">private</span> ServiceConnection mConnection = <span class="keyword">new</span> ServiceConnection() &#123;  <span class="comment">//Ibind监听，注意绑定是异步的</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName componentName, IBinder iBinder)</span> </span>&#123; <span class="comment">//当与Service建立连接时调用</span></span><br><span class="line">              messenger = <span class="keyword">new</span> Messenger(iBinder);</span><br><span class="line">            Message message = Message.obtain(<span class="keyword">null</span>,Constants.MSG_FROM_CLIENT);</span><br><span class="line">            Bundle bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">            bundle.putString(<span class="string">"msg"</span>,<span class="string">"Service兄弟在吗，是否已收到回复"</span>);</span><br><span class="line">            message.setData(bundle);</span><br><span class="line">            message.replyTo = replyMessager;  <span class="comment">//注意这一句，将客户端用于接受消息的Messager对象传递给Service</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                messenger.send(message);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName componentName)</span> </span>&#123;  <span class="comment">//与Service意外中断时调用</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Messenger replyMessager = <span class="keyword">new</span> Messenger(<span class="keyword">new</span> GetReplyMessenger());  <span class="comment">//客户端接收消息的messenger</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">GetReplyMessenger</span> <span class="keyword">extends</span> <span class="title">Handler</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what)&#123;</span><br><span class="line">                <span class="keyword">case</span> Constants.MSG_FROM_SERVICE:</span><br><span class="line">                    String reply = msg.getData().getString(<span class="string">"reply"</span>);</span><br><span class="line">                    Log.i(<span class="string">"hj"</span>,<span class="string">"从Service接收到的消息:"</span>+reply);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>,mService.class);</span><br><span class="line">        bindService(intent,mConnection,BIND_AUTO_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        unbindService(mConnection);</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先是绑定一个Service，接下来在绑定监听中创建一个Messager对象,通过Messager就可以发消息给服务端了,注意，我在这里通过replyTo发送了一个新的Messager对象给服务端，这样服务端就可以回复消息给客户端了，客户端也是通过Handler来接收消息的。</p>
<p>运行结果如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span>-<span class="number">09</span> <span class="number">11</span>:<span class="number">16</span>:<span class="number">07.733</span> <span class="number">7900</span>-<span class="number">7900</span>/com.jie.demo_01:remote I/hj: 从客户端接收到的消息:Service兄弟在吗，是否已收到回复</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span>-<span class="number">09</span> <span class="number">11</span>:<span class="number">16</span>:<span class="number">07.753</span> <span class="number">7871</span>-<span class="number">7871</span>/com.jie.demo_01 I/hj: 从Service接收到的消息:已收到客户端的消息，稍后回复~</span><br></pre></td></tr></table></figure>
<p>可以看到两个不同进程之间通信成功了</p>
]]></content>
      
        <categories>
            
            <category> Android基础进阶 </category>
            
            <category> 安卓IPC机制 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[安卓IPC机制：使用文件共享]]></title>
      <url>/%E5%AE%89%E5%8D%93IPC%E6%9C%BA%E5%88%B6%EF%BC%9A%E4%BD%BF%E7%94%A8%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB.html</url>
      <content type="html"><![CDATA[<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>通过两个进程间读/写同一个文件来交换数据<br><a id="more"></a><br>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">package com.jie.demo_01;</span><br><span class="line"></span><br><span class="line">import android.content.Intent;</span><br><span class="line">import android.os.Bundle;</span><br><span class="line">import android.os.Environment;</span><br><span class="line">import android.support.v7.app.AppCompatActivity;</span><br><span class="line">import android.view.View;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line"></span><br><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onResume() &#123;</span><br><span class="line">        super.onResume();</span><br><span class="line">        initWriteToFile();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  //点击跳转到SecondActivity</span><br><span class="line">    public void start(View v)&#123;</span><br><span class="line">        startActivity(new Intent(MainActivity.this,SecondActivity.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void initWriteToFile()&#123;</span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                User user = new User();</span><br><span class="line">                user.userName = &quot;Hello World&quot;;</span><br><span class="line">                File file = new File(getDiskCacheDir());</span><br><span class="line">                ObjectOutputStream oos = null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    oos = new ObjectOutputStream(new FileOutputStream(file));</span><br><span class="line">                    oos.writeObject(user);</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;finally &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        if (oos!=null)</span><br><span class="line">                        oos.close();</span><br><span class="line">                    &#125; catch (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getDiskCacheDir() &#123;</span><br><span class="line">        String cachePath = null;</span><br><span class="line">        if (Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())</span><br><span class="line">                || !Environment.isExternalStorageRemovable()) &#123;</span><br><span class="line">            cachePath = getExternalCacheDir().getPath()+&quot;/cache.txt&quot;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            cachePath = getCacheDir().getPath()+&quot;/cache.txt&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        return cachePath;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>SecondActivity代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">package com.jie.demo_01;</span><br><span class="line"></span><br><span class="line">import android.os.Bundle;</span><br><span class="line">import android.os.Environment;</span><br><span class="line">import android.support.v7.app.AppCompatActivity;</span><br><span class="line">import android.util.Log;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line"></span><br><span class="line">public class SecondActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onResume() &#123;</span><br><span class="line">        super.onResume();</span><br><span class="line">        getCacheFromFile();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void getCacheFromFile ()&#123;</span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                User user = null;</span><br><span class="line">                File file = new File(getDiskCacheDir());</span><br><span class="line">                if (file.exists())&#123;</span><br><span class="line">                    ObjectInputStream ois = null;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        ois = new ObjectInputStream(new FileInputStream(file));</span><br><span class="line">                        user = (User) ois.readObject();</span><br><span class="line">                        Log.i(&quot;TAG&quot;,user.userName);</span><br><span class="line">                    &#125; catch (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getDiskCacheDir() &#123;</span><br><span class="line">        String cachePath = null;</span><br><span class="line">        if (Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())</span><br><span class="line">                || !Environment.isExternalStorageRemovable()) &#123;</span><br><span class="line">            cachePath = getExternalCacheDir().getPath()+&quot;/cache.txt&quot;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            cachePath = getCacheDir().getPath()+&quot;/cache.txt&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        return cachePath;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行后，打印出日志：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12-08 13:13:30.372 17706-17723/com.jie.demo_01.remote I/TAG: Hello World</span><br></pre></td></tr></table></figure></p>
<p>文件传值成功</p>
<p>文件传值并没有具体的要求，不管是通过txt,xml,等等都可以，需要注意的是文件的并发问题，要避免获取文件值得时候同时去修改文件，这样会造成数据的混乱。</p>
]]></content>
      
        <categories>
            
            <category> Android基础进阶 </category>
            
            <category> 安卓IPC机制 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[安卓IPC机制：Bundle数据传递]]></title>
      <url>/%E5%AE%89%E5%8D%93IPC%E6%9C%BA%E5%88%B6%EF%BC%9ABundle%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92.html</url>
      <content type="html"><![CDATA[<h4 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h4><p>要实现进程之间的通信，序列化是通信的基础，所以先要了解下什么是序列化<br><a id="more"></a><br>安卓实现序列化有两种方式：<br><strong>1. 实现Serializable接口</strong>，使用相当简单，这个是JAVA提供的方法，需要注意的是,该接口有一个serialVersionUID参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final long serialVersionUID = 1L ;</span><br></pre></td></tr></table></figure></p>
<p>可以选择不实现，依旧可以序列化，但是会对反序列化产生影响，如果在反序列化的过程中类发生了变化，那么将会报错。<br>AndroidStudio默认不检查serialVersionUID的实现，因此，可以手动开启它，这样系统就会自动帮你实现serialVersionUID。开启方法：<br>Settings-&gt;Editor-&gt;Inspections-&gt;serialization issues-&gt;Serializable class without ‘serialVersionUID’ 勾上确认就可以</p>
<p>序列化对象也非常简单，通过ObjectOutputStream和ObjectInputStream即可轻松实现</p>
<p><strong>2.实现Parcelable接口</strong>,这是Android提供的方法，实现该接口，系统会自动帮你实现需要的代码，Android中推荐使用该方法，因为效率比Serializable高，Serializable需要进行大量的I/O操作。以下是完整实现实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class User implements Parcelable &#123;</span><br><span class="line">    public int userId;</span><br><span class="line">    public String userName;</span><br><span class="line">    public boolean isMale;</span><br><span class="line">    public Book book;</span><br><span class="line"></span><br><span class="line">    protected User(Parcel in) &#123;</span><br><span class="line">        userId = in.readInt();</span><br><span class="line">        userName = in.readString();</span><br><span class="line">        isMale = in.readByte() != 0;</span><br><span class="line">        book = in.readParcelable(Book.class.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static final Creator&lt;User&gt; CREATOR = new Creator&lt;User&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public User createFromParcel(Parcel in) &#123;</span><br><span class="line">            return new User(in);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public User[] newArray(int size) &#123;</span><br><span class="line">            return new User[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int describeContents() &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void writeToParcel(Parcel parcel, int i) &#123;</span><br><span class="line">        parcel.writeInt(userId);</span><br><span class="line">        parcel.writeString(userName);</span><br><span class="line">        parcel.writeByte((byte) (isMale ? 1 : 0));</span><br><span class="line">        parcel.writeParcelable(book, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>方法详解见下表：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>功能</th>
<th>标记位</th>
</tr>
</thead>
<tbody>
<tr>
<td>createFromParce(Parcel in)l</td>
<td>从序列化的对象中创建原始对象</td>
<td></td>
</tr>
<tr>
<td>newArray</td>
<td>创建指定长度的原始对象数组</td>
<td></td>
</tr>
<tr>
<td>User(Parcel in)</td>
<td>从序列化的对象中创建原始对象</td>
<td></td>
</tr>
<tr>
<td>writeToParcel(Parcel parcel, int i)</td>
<td>将当前对象写入序列化结构中,其中 i有两种值，1代表当前对象需要作为返回值返回，不能立即释放资源，</td>
<td>PARCELABLE_WRITE_VALUE</td>
</tr>
<tr>
<td>describeContents</td>
<td>返回当前对象的内容描述，如果含有文件扫描符，返回1（参见右侧标记位），否则返回0</td>
<td>CONTENTS_FILE_DESCRIPTOR</td>
</tr>
</tbody>
</table>
<p>实现了序列化，我们就可以很方便的通过Intent发送Bundle,这是一种简单的进程间通信的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Bundle bundle = new Bundle();</span><br><span class="line">       bundle.putParcelable(&quot;User&quot;,new User());</span><br><span class="line">       Intent intent = new Intent(MainActivity.this, SecondActivity.class);</span><br><span class="line">       intent.putExtra(&quot;data&quot;,bundle);</span><br><span class="line">       startActivity(intent);</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Android基础进阶 </category>
            
            <category> 安卓IPC机制 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[安卓IPC机制:多进程]]></title>
      <url>/%E5%AE%89%E5%8D%93IPC%E6%9C%BA%E5%88%B6-%E5%A4%9A%E8%BF%9B%E7%A8%8B.html</url>
      <content type="html"><![CDATA[<h4 id="什么是IPC"><a href="#什么是IPC" class="headerlink" title="什么是IPC"></a>什么是IPC</h4><p> IPC是指进程间通信或者跨进程通信，指两个进程之间交换数据的过程。而IPC使用的场景往往是在多进程之间进行通信。</p>
<h4 id="Android开启多进程"><a href="#Android开启多进程" class="headerlink" title="Android开启多进程"></a>Android开启多进程</h4><p> 通过给Activity指定android:process属性来开启多进程模式,如下示例，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;application</span><br><span class="line">       android:allowBackup=&quot;true&quot;</span><br><span class="line">       android:icon=&quot;@mipmap/ic_launcher&quot;</span><br><span class="line">       android:label=&quot;@string/app_name&quot;</span><br><span class="line">       android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;</span><br><span class="line">       android:supportsRtl=&quot;true&quot;</span><br><span class="line">       android:theme=&quot;@style/AppTheme&quot;&gt;</span><br><span class="line">       &lt;activity android:name=&quot;.MainActivity&quot;&gt;</span><br><span class="line">           &lt;intent-filter&gt;</span><br><span class="line">               &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;</span><br><span class="line"></span><br><span class="line">               &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;</span><br><span class="line">           &lt;/intent-filter&gt;</span><br><span class="line">       &lt;/activity&gt;</span><br><span class="line">       &lt;activity android:name=&quot;.ThirdActivity&quot; </span><br><span class="line">           android:process=&quot;:remote&quot;</span><br><span class="line">           /&gt;</span><br><span class="line">       &lt;activity android:name=&quot;.SecondActivity&quot; </span><br><span class="line">           android:process=&quot;com.jie.demo_01.remote&quot;</span><br><span class="line">           /&gt;</span><br><span class="line">   &lt;/application&gt;</span><br></pre></td></tr></table></figure></p>
<p>示例中实现了两种不同的写法，这两种写法是有区别的,当ThirdActivity启动，系统会单独开启一个叫com.jie.demo_01:remote的进程(com.jie.demo_01为包名),当启动SecondActivity,系统会单独开启一个叫com.jie.demo_01.remote的进程，其中，“：”代表要在当前进程名前面加上当前的包名，并且代表此进程为私有进程，其他应用不能和它跑在一个进程中，而没有”：”的为全局进程。SecondActivity的这种写法，是一种完整的命名方式，不会附加包名信息。</p>
<h4 id="开启多进程的一些坑"><a href="#开启多进程的一些坑" class="headerlink" title="开启多进程的一些坑"></a>开启多进程的一些坑</h4><p>当一个Activity单独开启了一个进程，那么这个Activity就不能和别的进程的Activity共享数据了，只能通过IPC机制来传递数据。</p>
<p>例如我申明了一个静态变量 Userid = 1;我在MainActivity中把它改为了2，我在SecondActivity中开启了一个进程，我获取这个Userid，你会发现Userid还是1，这是因为Android会为每一个进程分配一个虚拟机，不同的虚拟机在内存分配上会有不同的地址空间，所以Userid会在不同的虚拟机上产生不同的副本，并且副本之间是互不干扰的,我在MainActivity中把它改为2，在SecondActivity中的副本是不会变得,可以理解为又新开启了一个应用，所以，一般来说，多进程之间会存在下列一些问题：</p>
<ul>
<li>静态成员和单例模式无效</li>
<li>线程同步机制失效</li>
<li>SharedPreferences的存储结果变得不再可靠</li>
<li>Application会多次创建</li>
</ul>
<p>为了解决这些问题，系统引入了IPC机制，用于在进程间共享和传递数据，IPC的方式主要有以下几种：</p>
<ul>
<li>使用Bundle</li>
<li>使用文件共享</li>
<li>使用Messenger</li>
<li>使用AIDL</li>
</ul>
<p>其中Messenger底层其实使用的AILD，AIDL其实是依靠Binder,下一章将详细介绍这几种方法。</p>
]]></content>
      
        <categories>
            
            <category> Android基础进阶 </category>
            
            <category> 安卓IPC机制 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Activity的生命周期和启动模式]]></title>
      <url>/Activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F.html</url>
      <content type="html"><![CDATA[<blockquote>
<p>此系列文章为进阶类文章,快餐类记录文,用于自己安卓知识点的复习</p>
</blockquote>
<h4 id="典型情况生命周期"><a href="#典型情况生命周期" class="headerlink" title="典型情况生命周期"></a>典型情况生命周期</h4><ul>
<li>onCreate() :Activity被创建<a id="more"></a></li>
<li>onRestart() : 正在重新启动。调用场景：当前Activity从不可见到变为可见状态</li>
<li>onStart():  Activity正在启动,此时Activity已经可见，但还不能和用户交互</li>
<li>onResume() :此时Activity已经可见并开始活动</li>
<li>onPause() :Activity正在停止，如果是从此Activity退到上一个Activity,那么会先执行此Activity的onPause,再执行上一个Activity的onResume,所以此方法不能执行耗时的操作，不然会影响新Activity的显示</li>
<li>onStop() : Activity即将停止,紧接着onPause后面执行</li>
<li>onDestroy() : Activity即将销毁,在这里主要做一些资源的释放<br>完整的启动流程是从上到下,有几个具体情况说明:<br>1)第一次启动一个新的Activity: onCreate-&gt;onStart-&gt;onResume<br>2)再次打开一个Activity或者切换到桌面：onPause -&gt;onStop (注：如果新的Activity是用的透明主题,那么不会回调onStop)<br>3) 再次回到此Activity：onRestar -&gt;onStart -&gt;onResume<br>4)退出此Activity (finish掉)：onPause -&gt;onStop -&gt;onDestroty</li>
</ul>
<h4 id="异常情况生命周期"><a href="#异常情况生命周期" class="headerlink" title="异常情况生命周期"></a>异常情况生命周期</h4><h5 id="资源相关的系统配置发生了改变导致Activity被杀死并重新创建"><a href="#资源相关的系统配置发生了改变导致Activity被杀死并重新创建" class="headerlink" title="资源相关的系统配置发生了改变导致Activity被杀死并重新创建"></a>资源相关的系统配置发生了改变导致Activity被杀死并重新创建</h5><p>发生此种情况最典型的就是横竖屏的切换,因为系统会去拿两张不同的图片，这时，Activity就会重新创建,它的onPause,onStop,onDestroy都会被调用,同时因为Activity是在异常情况下终止的,所以系统会调用onSaveInstanceState来保存当前Activity的状态，这个方法会在onStop方法之前调用。当Activity创建完成,系统会调用onRestoreInstanceState，可以从这个方法里拿到bundle对象并恢复Activity的状态</p>
<h5 id="资源不足导致Activity被杀死"><a href="#资源不足导致Activity被杀死" class="headerlink" title="资源不足导致Activity被杀死"></a>资源不足导致Activity被杀死</h5><p>此种情况和第一类差不多，都可以通过以上两种方法来恢复数据</p>
<p>此外，我们还可以不让Activity重新创建,通过在清单文件中指定Activity的configChanges属性,通过这些属性,可以让我们在特定场景下Activity不会被重新创建,此时，如果我们进行了特殊的操作,Activity会调用onConfigurationChanged方法</p>
<h4 id="Activity的启动模式"><a href="#Activity的启动模式" class="headerlink" title="Activity的启动模式"></a>Activity的启动模式</h4><p>1)standard： 默认模式，每次都打开一个新的Activity,例如ABCD四个Activity,A是最底的Activity,D是当前的栈顶Activity,通过D启动D，此时栈中的Activity就会变成ABCDD<br>2）singleTop： 栈顶复用模式，例如ABCD四个Activity,用D启动D,栈中的Activity还是ABCD，D被复用了,并且D不会再次调用onCreate，而是会调用onNewIntent<br>3)singleTask:  栈内复用模式,例如ABCD,通过D启动B，栈中的Activity为：ACDB,B不会被重新创建,并且B会放入到栈顶,如果是通过D启动E，那个栈中Activcity为ABCDE,因为E在栈中没有，系统会创建一个新的实例。复用的Activity依旧会调用onNewInternt<br>4) 单实例模式，可以理解为加强版的singTask.此种模式不但拥有singTask的全部特性，而且是单独的位于一个任务栈中，例如A是此种模式，那个系统会创建一个新的任务栈，那么由于栈的复用特性，后续的请求都不会重新创建新的Activity，除非被系统销毁了</p>
<h4 id="启动模式的设置"><a href="#启动模式的设置" class="headerlink" title="启动模式的设置"></a>启动模式的设置</h4><p>1）通过清单文件的launchMode属性设置<br>2）通过Intent设置标志位来指定<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = new Intent();</span><br><span class="line">intent.setClass(A.this,B.class);</span><br><span class="line">intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure></p>
<p>两者的区别:第二种的优先级会高于第一种，第一种无法设置FLAG_ACTIVITY_CLEAR_TOP标识,第二种无法为Activity指定singleInstance模式。</p>
<h4 id="Activity的Flags"><a href="#Activity的Flags" class="headerlink" title="Activity的Flags"></a>Activity的Flags</h4><p><strong>FLAG_ACTIVITY_NEW_TASK</strong><br>singleTask模式<br><strong>FLAG_ACTIVITY_SINGLE_TOP</strong><br>singleTop模式<br><strong>FLAG_ACTIVITY_CLEAR_TOP</strong><br>设置了此模式，如果是singleTask模式启动,那么就会调用onNewIntent，如果是standard模式启动,那么位于此Activity栈上的所有Activity都要出栈<br><strong>FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS</strong><br>具有这个标记的Activity不会出现在列表中,等同于xml中的excludeFromRecents=true;</p>
]]></content>
      
        <categories>
            
            <category> Android基础进阶 </category>
            
            <category> 安卓Activity </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[有哪些送给年轻人的建议或道理？]]></title>
      <url>/%E6%9C%89%E5%93%AA%E4%BA%9B%E9%80%81%E7%BB%99%E5%B9%B4%E8%BD%BB%E4%BA%BA%E7%9A%84%E5%BB%BA%E8%AE%AE%E6%88%96%E9%81%93%E7%90%86%EF%BC%9F.html</url>
      <content type="html"><![CDATA[<blockquote>
<p>序言：这篇文章，写给你们，也写给我自己，我自己会经常阅读这篇文章来激励自己，每当自己茫然，无措，不知道该干嘛时，我都会读一遍，这样我的脑海就会自动给自己罗列出一些事情来做，哈哈哈。希望对阅读这篇文章的你会有启发,我相信未来的你一定会感谢现在这么努力的自己！</p>
</blockquote>
<h4 id="学习很重要！学习很重要！学习很重要！"><a href="#学习很重要！学习很重要！学习很重要！" class="headerlink" title="学习很重要！学习很重要！学习很重要！"></a>学习很重要！学习很重要！学习很重要！</h4><p> 知识或者技能这种东西，学到了就跟你一辈子，不管工作或时空跨度多大，新知和技能都能排上用场，请不要感叹时光已逝，学习不易，人家老来考研的，甚是80岁学编程的都有，请不要为你的懒惰找借口。</p>
<h4 id="习惯很重要！"><a href="#习惯很重要！" class="headerlink" title="习惯很重要！"></a>习惯很重要！</h4><p> 有人总是和我们说，要养成好的习惯。可没人跟我说重要到深度影响自己生活、人生选择和生命质量的程度。因为几乎大多数人，每时每刻都生活在形形色色的思维习惯、生活习惯中，比如健身、跑步、阅读、表达、写作、沟通、学习等等，所有影响我们生活工作结果的全是这些习惯。我们养成习惯，然后习惯养成我们。</p>
<h4 id="学会学习他人优秀的品质"><a href="#学会学习他人优秀的品质" class="headerlink" title="学会学习他人优秀的品质"></a>学会学习他人优秀的品质</h4><p>围剿式学习，也就是吸星大法，通过观察对方的沟通、演讲、写作方式，从而学习他们的思维方式、学习他们身上最优秀的思维习惯,当你们把优秀的人身上优秀的品质学习下来，这就是成功！</p>
<h4 id="真诚和诚信"><a href="#真诚和诚信" class="headerlink" title="真诚和诚信"></a>真诚和诚信</h4><p>真诚是领导力的真谛，诚信是商业的真谛，每个人的年薪、领导能力、商业成就全部都可以从这两个词汇里诠释,当你自己做老板你就会觉得这两个品质是多么的重要了。</p>
<h4 id="要多陪陪家人"><a href="#要多陪陪家人" class="headerlink" title="要多陪陪家人"></a>要多陪陪家人</h4><p>年轻人可能心里想得更多的是幸福生活，但父母的年纪，他们年龄越大，越要去面临离开这一主题，他们担心被世界抛弃，担心自己在儿女生活中扮演不了什么重要价值，特别渴望回馈、关注和尊重，不管多忙，能多打一个电话就多打一个电话，能多在一起吃顿饭，就多在一起吃顿饭，能满足他们想要的，不管大小，尽量去满足。可能你没察觉的是，随着你的逐渐成长，你的父母正逼近死亡！</p>
<h4 id="不要熬夜"><a href="#不要熬夜" class="headerlink" title="不要熬夜"></a>不要熬夜</h4><p>睡眠其实真正决定了生命的效率。因为睡眠决定着第二天的心情、状态、专注度等，而心情、状态、专注度直接影响结果，我们的现在就是由大大小小的这些结果构成的。所以睡个好觉可能是让生活变得更好的最大的捷径。不要相信什么狗血成功剧经常熬夜就能成功，成功是讲究效率的。</p>
<h4 id="保持自我，不断完善"><a href="#保持自我，不断完善" class="headerlink" title="保持自我，不断完善"></a>保持自我，不断完善</h4><p>保持自我，并不断变得更好，其实在一段感情里，远比委曲求全，一味地宠溺对方，更重要。保持自我可以测试出和对方是否合拍，不断变得更好，可以让感情更深刻而持久。千万不要因为孤独、无助、父母逼迫、个人面子、焦虑等原因仓促地选择一个人。这个人是自己生命的一部分，对自己施加着无以复加地影响，所以谨慎点，即便单身都比错误好很多。</p>
<h4 id="用感官去发现更美好的世界"><a href="#用感官去发现更美好的世界" class="headerlink" title="用感官去发现更美好的世界"></a>用感官去发现更美好的世界</h4><p>利用所有的感官去体验周遭的世界是那么重要，刻意发现生活的美，发现细微处的不同，会给自己带来很多小惊喜</p>
<blockquote>
<p>接下来聊聊职场发展的,人要舍得投资自己，这样你才会越来越值钱</p>
</blockquote>
<h4 id="不要让专业限制你的选择"><a href="#不要让专业限制你的选择" class="headerlink" title="不要让专业限制你的选择"></a>不要让专业限制你的选择</h4><p>许多人或许都是一些刚刚步入社会的学生，学生思维的一大局限就是觉得找工作应该专业要对口，实际上从我个人的观察来看，大学毕业后，同学中反倒是从事本专业的属于小众，我觉得造成这个现象的原因有：<br>（1）一般来说，填高考志愿的时候，你报的专业未来到底能做什么工作，你的父母如果不太了解的话，你必定也不太了解，况且很多学生报的专业都是那种所谓的热门专业，或者父母给选的，或者父母从事的专业；<br>（2）上大学后，真正的学了专业课后，你很有可能并不感兴趣，或者并不擅长；<br>（3）除了少数对专业知识要求较高的理工科专业，大部分专业毕业后去公司实习完全可以搞明白工作流程。所以除了队技术要求较高的理工科职位，其他大多数职位，毕业去公司，通过实际工作中学习，是完全可以的，只要你做了感兴趣，并且擅长的工作，工作技能都是学的很快的，而且在公司里你不懂的问题可以直接问资历老的员工，比你自己在学校里上课效率高多了，我本科学计算机的，班里同学有从事媒体的，金融的，出版社的，房地产的，考公务员的，还有经商的，反正干啥的都有，只要是你感兴趣的，并且觉得自己能做好的职位，大可以一试。</p>
<h4 id="不要怕犯错，年轻没有失败"><a href="#不要怕犯错，年轻没有失败" class="headerlink" title="不要怕犯错，年轻没有失败"></a>不要怕犯错，年轻没有失败</h4><p>网上很多人说过要找自己擅长的工作，但是问题是，一份工作你没干之前，很难知道自己到底是否擅长，那这份擅长的工作或行业要怎么找呢？答案是：多去尝试不同的职业。大学刚毕业一两年，很有可能你目前从事的工作并不是你喜欢的，也不是你一辈子只能干这个，如果干的不开心，并且在公司里干的也不算出色，那么，很可能就是你不擅长这个行业，这个时候，仗着你年轻，你大可以辞职转行，30岁之前你的转行成本是很低的，因为你年轻，大部分公司都会给你一个面试的机会，等你过了30岁再想转行，也不是不可能，但是难度比20几岁的时候会高几个量级：<br>（1）从公司的角度来看，公司更爱培养年轻人；<br>（2）30岁很可能结婚了，上有老，下有小，转行的风险特别的高，就是找1个月工作，很多家庭的房贷就要断供了，导致这个年纪即使想转行，需要考虑的因素也会多很多。所以，最好的选择就是在你的25-30岁之间这5年里，找到你擅长的行业或领域，这5年内你干的不爽尽可以换，但是最好在30岁之前找到自己能做一生的职业，并且稳定下来。</p>
<h4 id="好好利用下班的时间，5年后会给你带来巨大的改变"><a href="#好好利用下班的时间，5年后会给你带来巨大的改变" class="headerlink" title="好好利用下班的时间，5年后会给你带来巨大的改变"></a>好好利用下班的时间，5年后会给你带来巨大的改变</h4><p>20-25岁的年轻人，如果指望不上父母，只能靠自己奋斗的话，说难听点，你随后的几年是不应该有过多的娱乐生活的。道理很简单，在你没有过多的好的选择的时候，好好工作，升职加薪是你能做到的风险最小的选择（创业风险太高，不适合普通人），而决定你升职加薪的关键就是你的工作技能，所以如果你想30岁混个一官半职当个小主管，不想再当普通打工仔，那么，有效的利用下班时间好好的给自己充电是你必须要做的。而现代社会每个人白天得上至少八小时的班（不加班的企业真是良心），即使你有幸在一家不加班的企业工作，晚上下班挤地铁/公交到家吃完饭，洗完澡之后，怎么着也得8点了，如果你12点睡的话（基本已是极限，再晚睡会影响白天的工作），你一天中有效的连续学习时间就是4小时（这是比较乐观的估计，还有很多人通勤时间就得1个多小时，所以能有4个小时的学习时间的人真是很幸运），4小时，乍一看不少了，但是实际用起来，减掉中间休息一下的时间，你就会发现，是很紧凑的，而且一旦开始决定晚上学习，基本就不能隔三差五的和朋友出去浪了，因为就怕一出去，打破了学习惯性，心就散了，无心再耐心学习下去了，所以如果你决定给自己充电，几乎也就可以告别娱乐生活了，虽然这样的生活很苦，但是人生是需要规划的，若干年后，你应该感谢曾经那么的努力的自己。一辈子很长，25岁是你播种的时候，为的是未来的收获。</p>
<h4 id="对工作的爱好最重要"><a href="#对工作的爱好最重要" class="headerlink" title="对工作的爱好最重要"></a>对工作的爱好最重要</h4><p>爱好是最重要的，你不爱的工作再赚钱你也会忧郁症的，到时候每天起床都没动力，毕竟工作是半辈子的事情。</p>
<h4 id="定制自己的职业发展计划-明确自己要的是什么"><a href="#定制自己的职业发展计划-明确自己要的是什么" class="headerlink" title="定制自己的职业发展计划,明确自己要的是什么"></a>定制自己的职业发展计划,明确自己要的是什么</h4><p>提前给自己定好计划，避免让自己像一个无头苍蝇般到处乱飞，明确自己想要的是什么，该如何去努力，对自己的财产也要有规划，多阅读一些关于金融理财类的书籍。</p>
<blockquote>
<p>最后，再来一个毒鸡汤总结</p>
</blockquote>
<h4 id="这是一个带毒的总结"><a href="#这是一个带毒的总结" class="headerlink" title="这是一个带毒的总结"></a>这是一个带毒的总结</h4><p>在年轻的时候，即使你知道再多“人生的道理”，即使你下了再大的决心，即使你做了再周密的计划。你还是可能一事无成。因为你并没有坚持下来,道理你都懂，要干什么事儿也都知道，为什么你做不到？有谁认真想过? </p>
<p>我们之所以做不到，是因为大部分人，都无法把自己眼前的事或即将要做的事，和今后的收益联系起来,因为你坚持了一个月后,你可能就会想，我这样做真的有用吗？这时你就会彷徨，甚至惊恐，毕竟，隔山的金子不如铜:<br>我又不靠写作吃饭,看那么多书有什么用呢?<br>一个月就那么点钱,理财有什么用呢?<br>已经长那样了,健身有什么用呢?<br>我又不想出国、不考外交部、不去外企,你让我努力打卡学英语不是搞笑吗?<br>………<br>人往往就是这样,事到临头才会想到要抱佛脚。<br>那么如何才能去坚持，其实我也没什么方法可言，道理你都懂了，做与不做都是你的一念之间,我只能告诉你一个道理需要你们自己去悟：</p>
<p><code>你要让你所有做的事情，随着时间发展产生变化</code></p>
<p>你需要的只是在年轻的时候多用时间做资本，去为未来做投资.<br>就能在未来取得收益后，买下更重要的时间。<br>人的一生很宝贵，酒足饭饱之余，不妨多想想，做点什么更有用的事，才能在阶层固化之前尽量往上多蹦一两个台阶</p>
<h5 id="因为，相对于你今后的每一天，现在的你都是最年轻的你。"><a href="#因为，相对于你今后的每一天，现在的你都是最年轻的你。" class="headerlink" title="因为，相对于你今后的每一天，现在的你都是最年轻的你。"></a>因为，相对于你今后的每一天，现在的你都是最年轻的你。</h5><p>好文链接：</p>
<ul>
<li><p><a href="https://www.jianshu.com/p/a5448821f9ad" target="_blank" rel="noopener">【习惯】你培养习惯的方法可能是个假方法</a></p>
</li>
<li><p><a href="https://www.jianshu.com/p/93e59aed232a?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=pc_all_hots&amp;utm_source=recommendation" target="_blank" rel="noopener">你的所谓成熟，不过是精神早衰</a></p>
</li>
</ul>
<p>—————————–希望生活善待如此努力的你❤—————————-</p>
]]></content>
      
        <categories>
            
            <category> 感悟 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[如何将个人域名与github绑定]]></title>
      <url>/%E5%A6%82%E4%BD%95%E5%B0%86%E4%B8%AA%E4%BA%BA%E5%9F%9F%E5%90%8D%E4%B8%8Egithub%E7%BB%91%E5%AE%9A.html</url>
      <content type="html"><![CDATA[<h1 id="购买个人域名"><a href="#购买个人域名" class="headerlink" title="购买个人域名"></a>购买个人域名</h1><p>例如我的是在阿里云万网购买的,点击进入域名列表,点击解析,会出现一个添加解析按钮，点开有记录类型，主机记录，解析线路，记录值，TTL值五个选项<br>依次填写：</p>
<ul>
<li>记录类型：A</li>
<li>主机记录：www</li>
<li>解析线路：不用选，就用默认</li>
<li>记录值：填写你的github网址的ip,可以用ip查询或ping查到，一般都是151开头。</li>
<li>TTL值：不用管，默认10分钟。</li>
</ul>
<p>填写完毕后就可以关闭页面了</p>
<h1 id="Github配置"><a href="#Github配置" class="headerlink" title="Github配置"></a>Github配置</h1><p>在你的io网站本地仓库中新建一个CHAME(注意都要大写)文件，没有后缀，打开编辑，将你的域名添加进入，例如我的就是www.huangjie.name,保存，关闭,将文件提交到远程仓库,这时github应该会发一封邮件给你代表配置成功，更改不会立即生效，一般10分钟左右</p>
<p>如果你是用的hexo，可以将CHAME文件建立在source文件夹中，这样通过Hexo提交到github不会被覆盖</p>
]]></content>
      
        <categories>
            
            <category> Hexo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo博客使用心得]]></title>
      <url>/hello-world.html</url>
      <content type="html"><![CDATA[<p>欢迎来到黄杰的个人博客，这是我写入的第一篇博文,此博客平台采用  <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> + <a href="https://github.com/" target="_blank" rel="noopener">githubPages</a>搭建而成,搭建日期：2017/11/29。这篇博客将持续记录hexo使用过程中的一些问题<br><a id="more"></a></p>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>记录一些自己搭建的参考资料</p>
<ul>
<li><a href="http://blog.haoji.me/build-blog-website-by-hexo-github.html?from=xa" target="_blank" rel="noopener">http://blog.haoji.me/build-blog-website-by-hexo-github.html?from=xa</a></li>
<li><a href="https://hexo.io/zh-cn/docs/generating.html" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/generating.html</a></li>
<li><a href="http://blog.csdn.net/poem_of_sunshine/article/details/2936978" target="_blank" rel="noopener">http://blog.csdn.net/poem_of_sunshine/article/details/2936978</a></li>
<li><a href="http://blog.sunnyxx.com/2014/02/27/hexo_startup/" target="_blank" rel="noopener">http://blog.sunnyxx.com/2014/02/27/hexo_startup/</a></li>
</ul>
<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><p>进入项目主结构，使用git bash执行命令</p>
<ul>
<li>监听文件变动  <code>$ hexo g</code></li>
<li>开启本地服务 <code>$ hexo s</code> ，开启后在浏览器输入<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 即可访问</li>
<li>提交代码 <code>$ hexo d</code>  ，需要配置deploy</li>
</ul>
<p>在主项目目录下有个_config.yml,为全局配置文件,在themes文件夹里，存放着网站使用的主题文件，打开主题文件夹，里面也有个_config.yml，为主题配置文件，与主题相关的在这里配置，我现在采用的是<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">Next</a>主题</p>
<h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><h4 id="一-首页的文章内容全部显示出来了，没有“阅读全文”"><a href="#一-首页的文章内容全部显示出来了，没有“阅读全文”" class="headerlink" title="一.首页的文章内容全部显示出来了，没有“阅读全文”?"></a>一.首页的文章内容全部显示出来了，没有“阅读全文”?</h4><h5 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h5><p>有两种方法</p>
<p>第一种：<br>在主题配置文件里(themes/next/_config.yml)用编辑器打开，找到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Automatically Excerpt. Not recommend.</span><br><span class="line"># Please use &lt;!-- more --&gt; in the post to control excerpt accurately.</span><br><span class="line">auto_excerpt:</span><br><span class="line">  enable: false</span><br><span class="line">  length: 150</span><br></pre></td></tr></table></figure></p>
<p>将 <code>enable：false</code> 改为<code>true</code>就行了，后面的<code>length:150</code>代表显示的文本字数。</p>
<p>第二种：<br>直接在编辑的.md文件里将要预览的文字后面加上<code>&lt;!--more--&gt;</code>,这样之前的就是预览的文字,后面的就不会显示了</p>
<h4 id="二-如何将README-md文件传到github而不被编译成html"><a href="#二-如何将README-md文件传到github而不被编译成html" class="headerlink" title="二.如何将README.md文件传到github而不被编译成html"></a>二.如何将README.md文件传到github而不被编译成html</h4><p>在Hexo目录的source目录在建立一个README.md文件,修改Hexo目录的_config.yml配置,找到 skip_render参数设置,后面加上 README.md,关闭保存,之后编译就不会渲染README.md这个文件了</p>
<h4 id="三-百度搜索引擎不能收录自己的网站地址"><a href="#三-百度搜索引擎不能收录自己的网站地址" class="headerlink" title="三.百度搜索引擎不能收录自己的网站地址"></a>三.百度搜索引擎不能收录自己的网站地址</h4><p>原因是github屏蔽了百度的spider爬虫,导致百度不能收录,解决办法是使用coding来托管国内的流量访问,具体的方法可以参考这篇博文:<a href="http://blog.csdn.net/sunshine940326/article/details/70936988" target="_blank" rel="noopener">hexo高阶教程：想让你的博客被更多的人在搜索引擎中搜到吗？</a></p>
<h1 id="写作技巧记录"><a href="#写作技巧记录" class="headerlink" title="写作技巧记录"></a>写作技巧记录</h1><h4 id="一-如何将md文件以时间命名"><a href="#一-如何将md文件以时间命名" class="headerlink" title="一.如何将md文件以时间命名"></a>一.如何将md文件以时间命名</h4><p>  在_config.yml中找到new_post_name,修改名称为<code>:year-:month-:day-:title.md</code>,这样创建的文件就会以电脑时间命名，使用时间命名可以更方便的管理文章</p>
]]></content>
      
        <categories>
            
            <category> Hexo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
        
    </entry>
    
  
  
    
    <entry>
      <title></title>
      <url>/about/index.html</url>
      <content type="html"><![CDATA[<h1 id="About-Me"><a href="#About-Me" class="headerlink" title="About Me"></a>About Me</h1><blockquote>
<p>Android 小生一枚，轻微强迫症患者，非处女座，忠实谷粉兼果粉，喜欢看书听歌旅游，最近的目标是去西藏，有组团的欢迎私我</p>
</blockquote>
<ul>
<li>Email(QQ): jay@huangjie.name</li>
<li>Github : <a href="https://github.com/Jay-huangjie" target="_blank" rel="noopener">Jay-huangjie</a></li>
<li>Weixin: h289223562</li>
<li>QQ: 289223562</li>
<li>CSDN: <a href="http://blog.csdn.net/qq289223562" target="_blank" rel="noopener">_杰哥</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[分类]]></title>
      <url>/categories/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[tags]]></title>
      <url>/tags/index.html</url>
      <content type="html"></content>
    </entry>
    
  
</search>
