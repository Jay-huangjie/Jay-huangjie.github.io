<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[玩转Class之Class的各种骚操作(反射封装必看)]]></title>
    <url>%2Fandroidclassstudy.html</url>
    <content type="text"><![CDATA[版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起. 文章首发于我的简书,本处只做整理归档用 简介Class类表示正在运行的Java应用程序中的类和接口，枚举和基本数据类型，我们可以从中获取到类的一切相关信息，包括字段，方法，名称，父类，接口等 常用方法介绍名称获取此类方法用于获取类的名称信息getName()方法 如果是一个实体类，则会返回完整包名路径名称,例如位于com.hj.testclass包下的student类，则会返回com.hj.testclass.student 如果是一个数组类型，则返回内部嵌套深度的一个或多个”[“字符，后面拼接上基本数据类型的二进制名称,二进制名称表如下： Element Type Encoding boolean Z byte B char C class or interface Lclassname double D float F int I long J short S 示例：123(new long[1][2][3]).getClass().getName()输出:[[[J 如果是基本数据类型，则会返回数据类型的关键字123byte.class.getName()输出：byte getSimpleName()方法返回源代码中给出的基础类的简单名称。 如果基础类是匿名的，则返回一个空字符串。12345Student student = new Student();Class mClass = student.getClass();log(&quot;getSimpleName:&quot;+mClass.getSimpleName());输出：Student getPackage()方法返回包名信息 注解相关可获取此类是否是注解，是否包含某注解并获取到其对象，获取全部注解| 方法| 作用 ||——-|——–||getAnnotation(Class annotationClass)|获取传入的注解对象，如果不存在，则返回null||getAnnotations()|返回此类上的所有注解||getAnnotationsByType(Class annotationClass)|返回传入的注解对象数组，与getAnnotation()的区别是检测传入的注解是否是重复元素||isAnnotation()|判断这个类是否是一个注解类||isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)|是否包含传入的注解类,效果与getAnnotation()!=null相同|举个栗子：新建一个注解对象：1234567/** * Created by hj on 2019/1/10. * 说明： */@Retention(RetentionPolicy.RUNTIME)public @interface MyAnnotation &#123;&#125; 新建一个Student并加入@MyAnnotation注解：12345678910111213141516171819202122232425262728/** * Created by hj on 2019/1/10. * 说明： */@MyAnnotationpublic class Student&#123; public static void main(String[] args) &#123; Student student = new Student(); Class studentClass = student.getClass(); boolean isAnnotation = studentClass.isAnnotation(); log(studentClass.getSimpleName()+&quot;是否是注解类:&quot;+isAnnotation); boolean isContainAnnotation = studentClass.isAnnotationPresent(MyAnnotation.class); log(studentClass.getSimpleName()+&quot;是否包含MyAnnotation注解类:&quot;+isContainAnnotation); Annotation annotation = studentClass.getAnnotation(MyAnnotation.class); Annotation[] annotations = studentClass.getAnnotations(); if (annotation != null) &#123; log(&quot;获取指定的MyAnnotation类:&quot;+annotation.toString()); &#125; if (annotations.length &gt; 0)&#123; log(&quot;获取注解集合中的第一个元素:&quot;+annotations[0].toString()); &#125; &#125; private static void log(String value) &#123; System.out.print(value); &#125;&#125; 打印：1234Student是否是注解类:falseStudent是否包含MyAnnotation注解类:true获取指定的MyAnnotation类:@jie.com.imageoptimize.mclass.MyAnnotation()获取注解集合中的第一个元素:@jie.com.imageoptimize.mclass.MyAnnotation() 构造方法相关在介绍构造方法之前，先介绍一个类Constructor,它的作用是提供一个类的单个构造方法的信息访问，如果一个类有两个构造方法，那么这个类就会对应有两个Constructor类，它可以使用newInstance方法来进行类的构造方法实现并进行扩展，但如果发生缩小转换则会抛出IllegalArgumentException异常，比如这个类有两个构造参数却只传入一个，就会抛异常。获取Constructor信息的方法有：| 方法| 作用 ||——-|——–||getConstructors()|返回这个类的公共构造函数的 Constructor对象的数组||getConstructor(Class&lt;?&gt;..parameterTypes)|传入一个指定的参数类型来获取特定的公共构造方法类||getDeclaredConstructors()|与getConstructors的区别是返回所有的构造方法数组，不限于public protected private||getDeclaredConstructor(Class&lt;?&gt;..parameterTypes)|与getConstructor的区别是会返回所有类型的构造方法|接下来介绍一下Constructor类的newInstance方法，这个方法说白了就是执行构造函数的，你传入一个当前构造函数的类型的值进去，那么就会执行这个类的构造方法。下面举一个反射调用构造方法的栗子：新建一个Student类，分别添加两个私有构造方法，一个公有构造方法，并添加两个参数，在构造方法处执行打印逻辑，代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * Created by hj on 2019/1/10. * 说明： */public class Student &#123; private String name; private int age; private Student() &#123; &#125; public Student(String name) &#123; this.name = name; log(&quot;公有构造方法执行了，打印传入的名称为:&quot;+name); &#125; private Student(int age)&#123; this.age = age; log(&quot;私有构造方法执行了，打印传入的年龄为:&quot;+age); &#125; public static void main(String[] args) &#123; Student student = new Student(); Class mClass = student.getClass(); Constructor[] constructors = mClass.getConstructors(); log(&quot;获取&quot; + mClass.getSimpleName() + &quot;的公共构造方法数量为:&quot; + constructors.length); try &#123; Constructor constructor = mClass.getConstructor(String.class); constructor.newInstance(&quot;张三&quot;); &#125; catch (NoSuchMethodException | IllegalAccessException | InstantiationException | InvocationTargetException e) &#123; e.printStackTrace(); &#125; Constructor[] declaredConstructors = mClass.getDeclaredConstructors(); log(&quot;获取&quot; + mClass.getSimpleName() + &quot;的所有构造方法数量为:&quot; + declaredConstructors.length); try &#123; Constructor constructor = mClass.getDeclaredConstructor(int.class); constructor.newInstance(18); &#125; catch (NoSuchMethodException | IllegalAccessException | InstantiationException | InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125; private static void log(String value) &#123; System.out.print(value); &#125;&#125; 打印结果如下：1234获取Student的公共构造方法数量为:1公有构造方法执行了，打印传入的名称为:张三获取Student的所有构造方法数量为:3私有构造方法执行了，打印传入的年龄为:18 怎么样，反射调用类的构造方法技能get到了吗 字段相关此类型方法是用的最多的一种，希望小伙伴们可以熟练掌握在介绍字段方法之前，先介绍一个类Field,它用于保存，修改字段的信息，甚至可以修改字段的访问权限,常用的方法如下:| 方法| 作用 ||——-|——–||getName()|获取字段名称||get()|传入需要获取的值的类的对象，获取该字段的值,返回object类型，使用的时候需要做类型判断||getBoolean(),getInt()…|获取指定类型的字段值||set()，setBoolean()…| 将指定的类的指定值设置为新值||isAccessible()|判断此字段是否有访问权限||setAccessible()|设置字段的权限，为true代表可以访问|接下来再来看看如何使用Class来获取字段信息:| 方法| 作用 ||——-|——–||getFields()|获取所有的公共字段||getField()|传入字段的名称，返回公共字段对象||getDeclaredFields()|获取所有字段，返回一个Field数组||getDeclaredField|传入字段的名称，返回字段对象,无访问限制|下面举个获取字段名称和内容的例子，并分享一个常用的套路写法，一般的都可以按照这个套路来写：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * Created by hj on 2019/1/10. * 说明： */public class Student &#123; public String name; private int age; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public static void main(String[] args) &#123; Student student = new Student(&quot;张三&quot;, 18); setAllComponentsName(student); &#125; private static void setAllComponentsName(Object f) &#123; Field[] fields = f.getClass().getDeclaredFields(); for (Field field : fields) &#123; // 对于每个属性，获取属性名 String varName = field.getName(); try &#123; // 获取原来的访问控制权限 boolean accessFlag = field.isAccessible(); // 修改访问控制权限 field.setAccessible(true); // 获取在对象f中属性fields[i]对应的对象中的变量 Object o = field.get(f); if (!&quot;&quot;.equals(varName)) &#123; //这里可以处理相关逻辑 if (o != null) &#123; if (o instanceof String) &#123; String value = (String) o; log(&quot;String类型字段:&quot; + value); &#125; else if (o instanceof Integer) &#123; int value = (int) o; log(&quot;int类型字段:&quot; + value); &#125; &#125; &#125; // 恢复访问控制权限 field.setAccessible(accessFlag); &#125; catch (IllegalArgumentException | IllegalAccessException ex) &#123; ex.printStackTrace(); &#125; &#125; &#125; private static void log(String value) &#123; System.out.print(value); &#125;&#125; 打印结果：12String类型字段:张三int类型字段:18 一般都是先将权限修改为true,再去读取字段内容，随后进行逻辑处理，最后记得将权限改回来. 方法相关此类型方法也是用的比较多的一种，是反射调用方法的关键class中关于方法的封装都是给Method类来操作的，它可以获取，修改，执行类的方法，核心方法就是invoke()，作用是执行方法，第一个参数是需要执行的方法的类对象，随后是需要执行的方法参数值。获取Method对象有四个方法:| 方法| 作用 ||——-|——–||getMethods()|获取类的所有公共方法||getMethod()|获取指定公共方法，传入一个方法的名称与参数的类型||getDeclaredMethods()|获取类的所有方法||getDeclaredMethod()|获取类的指定方法，传入参数同getMethod()|举个例子，将本来为张三的名称修改为李四：123456789101112131415161718192021222324252627282930313233343536/** * Created by hj on 2019/1/10. * 说明： */public class Student &#123; public String name; private int age; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; private void setName(String name)&#123; this.name = name; log(&quot;设置的名称为：&quot;+name); &#125; public static void main(String[] args) &#123; Student student = new Student(&quot;张三&quot;, 18); Class mClass = student.getClass(); try &#123; Method method = mClass.getDeclaredMethod(&quot;setName&quot;,String.class); method.invoke(student,&quot;李四&quot;); &#125; catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125; private static void log(String value) &#123; System.out.print(value); &#125;&#125; 打印结果:1设置的名称为：李四 在项目中使用，可以参考上面的Field类，其实都是差不多的，一通百通。 抽象,继承,接口,泛型相关此类方法虽然不常用到，但在某些情况下能发挥意想不到的作用，在许多框架的源码中也能看见它们的身影，如Gson的$Gson$Types类,Retrofit的Util类等，来跟我学习一下把。 泛型首先说说获取类的泛型获取，先介绍一个接口Type,它是java中所有类型的通用接口，类型包括原始类型(class)，参数化类型(ParameterizedType)，数组类型(GenericArrayType)，类型变量(TypeVariable)和基本数据类型。内部实现了一个方法getTypeName(),用于返回类型参数信息，基于它向外扩展的接口有： ParameterizedType表示一个参数化类型，说简单点就是带有参数类型的类型，如Collection ,如果带有了类型，如Collection，那么就是说String将Collection参数化 GenericArrayType表示一个参数化类型或类型变量的数组类型，简单说就是泛型A[]或泛型数组T[] TypeVariable所有类型变量的父接口,也就是我们定义抽象类中的那种K,E等泛型变量，可以泛指任何类 WildcardType表示一个通配符表达，例如?,? extends IntegerType可以通过class的getGenericInterfaces或getGenericSuperclass()方法来获取这么说或许还有点抽象，ParameterizedType与TypeVariable的概念或许还拎不太清。下面通过示例来加深理解先来说说ParameterizedType举个例子，先声明一个带泛型的超类Person12345678910/** * Created by hj on 2019/1/10. * 说明： */public class Person&lt;T&gt; &#123; public T feature;&#125; 随后定义一个实体类Feature1234567/** * Created by hj on 2019/1/10. * 说明： */public class Feature &#123;&#125; 最后申明一个Student并继承Person,将Feature作为T传入:123456789101112131415161718192021222324/** * Created by hj on 2019/1/10. * 说明： */public class Student extends Person&lt;Feature&gt; &#123; public static void main(String[] args) &#123; Student student = new Student(); Class mClass = student.getClass(); Type type = mClass.getGenericSuperclass(); //这里获取的type为Person&lt;Feature&gt;，所以属于ParameterizedType if (type instanceof ParameterizedType) &#123; //父类的泛型可能有多个，这里只写了一个，所以取第一个就行了，这里是取Person&lt;Feature&gt;中的Feature Class tClass = (Class) ((ParameterizedType) type).getActualTypeArguments()[0]; log(tClass.getSimpleName()); &#125; &#125; private static void log(String value) &#123; System.out.print(value); &#125;&#125; 因为Class类也实现了Type接口，所以是可以强制转化的打印结果如下:1Feature 可以看到在此示例中，只要是Person&lt;&gt;中传入的参数是一个参数类型，不管是实体类，String都行，只要是参数而没有泛指意义，那么它就属于ParameterizedType类型接下来将代码修改一下，将Feature改为T,修改获取逻辑：1234567891011121314151617181920212223242526/** * Created by hj on 2019/1/10. * 说明： */public class Student&lt;T&gt; extends Person&lt;T&gt; &#123; public static void main(String[] args) &#123; Student student = new Student(); Class mClass = student.getClass(); Type type = mClass.getGenericSuperclass(); //此时这里的type为Person&lt;T&gt;，而不是T，所以依旧属于ParameterizedType if (type instanceof ParameterizedType) &#123; //这里是从Person&lt;T&gt;中获取T Type childType = ((ParameterizedType)type).getActualTypeArguments()[0]; if (childType instanceof TypeVariable)&#123; log(((TypeVariable) childType).getName()); &#125; &#125; &#125; private static void log(String value) &#123; System.out.print(value); &#125;&#125; 输出名称为1T 不知道小伙伴们有没有理解了，当获取的类型是泛指的，如T等，那么就是TypeVariable类型，当类型是参数类型的，例如由子类传入的，具体化的，那么就是ParameterizedType类型。接下来的GenericArrayType和WildcardType就比较好理解了，将以上示例中的Person&lt;T&gt;改为Person&lt;T[]&gt;，将结果输出，代码如下：12345678910111213141516171819202122232425/** * Created by hj on 2019/1/10. * 说明： */public class Student&lt;T&gt; extends Person&lt;T[]&gt; &#123; public static void main(String[] args) &#123; Student student = new Student(); Class mClass = student.getClass(); Type type = mClass.getGenericSuperclass(); if (type instanceof ParameterizedType) &#123; //这里获取到的类型为：T[],是一个数组类型，所以是GenericArrayType Type childType = ((ParameterizedType)type).getActualTypeArguments()[0]; if (childType instanceof GenericArrayType)&#123; log(childType.toString()); &#125; &#125; &#125; private static void log(String value) &#123; System.out.print(value); &#125;&#125; 输出名称为：1T[] WildcardType就不演示了，将T改为带？的类型就可以了，如果封装类型实在太复杂，教大家一个技巧，打个断点，啥类型都帮你显示出来了。一看就知道是ParameterizedType类型了，哈哈哈，溜不溜。 这里给小伙伴一个作业：List&lt;? extends T&gt;[]中的List&lt;? extends T&gt;,? extends T，T ,List&lt;? extends T&gt;[]分别代表什么类型呢？ 继承获取父级类使用Class.getSuperclass()方法即可获取父类的class 接口获取接口也比较简单，一个接口实际上也是一个Class类，通过getInterfaces()获取到一个Class数组，而接口里声明的方法可以通过获取Method的方式来获取,举个栗子，先创建一个MyInterface接口1234567/** * Created by hj on 2019/1/11. * 说明： */public interface MyInterface &#123; void getName();&#125; 在Student类里实现并获取：12345678910111213141516171819202122232425262728/** * Created by hj on 2019/1/10. * 说明： */public class Student implements MyInterface&#123; public static void main(String[] args) &#123; Student student = new Student(); Class mClass = student.getClass(); Class interfaces = mClass.getInterfaces()[0]; try &#123; Method methods = interfaces.getMethod(&quot;getName&quot;,null); log(methods.getName()); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; &#125; private static void log(String value) &#123; System.out.print(value); &#125; @Override public void getName() &#123; &#125;&#125; 打印出方法名为：1getName 总结只要拿到Class类，我们就可以获取到它的父类，接口，方法，字段，以及泛型，从而做一些解耦封装，提高类的解耦性。或者在不修改源码的情况下执行或修改源码中的方法，字段，从而达到理想中的效果。小伙伴们快去练习一下把。]]></content>
      <categories>
        <category>Android基础进阶</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android性能优化-图片篇]]></title>
    <url>%2FAndroid%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E5%9B%BE%E7%89%87%E7%AF%87.html</url>
    <content type="text"><![CDATA[版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起. 文章首发于我的简书,本处只做整理归档用 (1)drawable目录详解(mdpi,hdpi,xhdpi,xxhdpi,xxxhdpi)1.1、图片在各个目录中要如何存放？（必须理解）android的drawable目录有： drawable-ldpi(低密度) drawable-mdpi(中等密度) drawable-hdpi(高密度) drawable-xhdpi(超高密度) drawable-xxhdpi(超超高密度) drawable-xxxhdpi(超超超高密度) drawable-nohdpi(无缩放) 默认的drawable 而安卓加载图片的原理是根据手机的密度(dpi)来选择不同的文件夹下的图片,如果没有，就会从别的密度文件夹来获取图片并按照一定比例来缩放展示图片。获取设备密度的方法为：12float xdpi = getResources().getDisplayMetrics().xdpi;float ydpi = getResources().getDisplayMetrics().ydpi; 知道了dpi,就知道会去哪个文件夹获取图片了:| 对应文件夹 | 密度范围（dpi）| 缩放比例 || ——| ——| ——|| ldpi | 0~120 | 0.75 || mdpi |120~160 | 1(基准)|| hdpi |160~240 | 1.5 || xhdpi |240~320 | 2.0 || xxhdpi |320~480 | 3.0 || xxxhdpi |480~640 | 4.0|而当前的主流机型密度基本都是在320~480之间，一般放两套图就够了，一套放到xhdpi,一套放到xxhdpi,那么如果是一个hdpi的手机来运行会发生什么呢？安卓是有一套图片匹配规则的: 一个hdpi密度的手机，肯定是先去匹配hdpi目录下的图片，如果没有，那么就会向上级去查找，分别是xhdpi-&gt;xxhdpi-&gt;xxxhdpi-&gt;nodpi，如果都没有，就会往下级目录去查，分别是mdpi-&gt;ldpi,如果还没有，就会去drawable目录去查找，如果还没有！就会开启自毁模式，嘣！！(resouse not found) 1.2、相同图片在不同目录所占用资源分析(了解即可)不知道有没有朋友做过这样一个实验，把一个xhdpi密度的图片放到xxhdpi密度的文件夹中去加载会发生什么,它所占的内存会有区别吗？例如一个在xhdpi下为200 200的图片，xxhdpi密度下为300 300,但此时图片只有200 200，所以它会放大到300 300，这时候图片就会出现模糊的情况了，所以如果你在项目中发现图片模糊的情况可以检查下图片的尺寸是否正确。 接下来我们来做一个实验,使用一个名叫icon_database_xls 64 * 64 PNG的图片，将它放到xhdpi目录中，执行下面的代码获取内存占用情况：12Bitmap bitmap = BitmapFactory.decodeResource(getResources(),R.mipmap.icon_database_xls);Log.i(&quot;HJ&quot;,bitmap.getByteCount()+&quot;&quot;); 结果如下：12019-01-08 10:56:01.872 18507-18507/jie.com.imageoptimize I/HJ: 30976 接下来将图片放到xxhdpi目录下，再次执行代码:12019-01-08 10:56:32.123 18677-18677/jie.com.imageoptimize I/HJ: 13924 可以看到结果差距巨大,我们知道，一个图片的内存占用公式为：图片内存宽度 图片内存高度 每像素占用的内存位数，那我们的内存宽高是如何计算的呢？我们可以追踪framework的源码，路径为/frameworks/base/core/jni/android/graphics/BitmapFactory.cpp,找到doDecode方法：123456789101112131415161718192021222324252627282930313233static jobject doDecode(JNIEnv* env, std::unique_ptr&lt;SkStreamRewindable&gt; stream, jobject padding, jobject options) &#123; int sampleSize = 1; bool onlyDecodeSize = false; ... ... float scale = 1.0f; ... ... if (options != NULL) &#123; sampleSize = env-&gt;GetIntField(options, gOptions_sampleSizeFieldID); if (sampleSize &lt;= 0) &#123; sampleSize = 1; &#125; if (env-&gt;GetBooleanField(options, gOptions_justBoundsFieldID)) &#123; onlyDecodeSize = true; &#125; ... ... if (env-&gt;GetBooleanField(options, gOptions_scaledFieldID)) &#123; const int density = env-&gt;GetIntField(options, gOptions_densityFieldID); const int targetDensity = env-&gt;GetIntField(options, gOptions_targetDensityFieldID); const int screenDensity = env-&gt;GetIntField(options, gOptions_screenDensityFieldID); if (density != 0 &amp;&amp; targetDensity != 0 &amp;&amp; density != screenDensity) &#123; scale = (float) targetDensity / density; //缩放比在这里计算的 &#125; &#125; &#125; ... ... if (scale != 1.0f) &#123; willScale = true; scaledWidth = static_cast&lt;int&gt;(scaledWidth * scale + 0.5f); //内存宽度计算 scaledHeight = static_cast&lt;int&gt;(scaledHeight * scale + 0.5f); //内存高度计算 &#125; 以上源码总结为：内存宽高 = 图片本身的宽高 * （设备密度/使用的密度）+ 0.5所以，内存的占用与图片所在的密度目录是有密切关系的 1.3、 drawable-xxhdpi与mipmap-xxhdpi的区别(了解即可)从新版Android studio开始，系统会默认给我们创建mipmap文件夹而不是drawable,先前我一直以为这个目录只是放icon的(流下了菜逼的心酸泪水),后来发现这个目录与drawable都可以放图片，而且貌似也没有任何差别????，为了弄清楚，上网查了一下，大意是会对图片缩放做性能优化，不过我在平常的使用中并没有发现有太大的区别，可能是高版本drawable也做了优化把，所以这个简单了解一下即可。 (2)Bitmap优化详解2.1、基础知识安卓的图片加载都会对应到bitmap对象,当bitmap占用的内存过高，超过了android为app分配的最大内存，那么它就会不开心，它就会OOM，所以我们的图片优化，本质就是内存优化。我们常用的图片格式一般有三种: JPEG 一种有损压缩格式，不支持透明通道,所以有透明背景需求的图片不要用jpeg格式，它会变成黑色，会变黑！！！，会变黑！！！，会变黑！！！ PNG 无损压缩格式,支持透明通道 WEBP 同时支持无损和有损压缩格式，然而兼容性较差，需要适配库 可参考:webp-android 在代码中可以通过Bitmap.CompressFormat来指定生成的图片格式bitmap还可以配置像素占用字节数（一个字节对应8位），这与内存占用息息相关，对应Bitmap.Config类： ALPHA_8 8位ALPHA通道，即A=8，一个像素占用一个字节，它是没有颜色的，只有透明度 ARGB_4444 16位 A=4,R=4,G=4,B=4,一个像素占用字节 = 4+4+4+4 = 16位 = 2个字节 ARGB_8888 32位 A=8,R=8,G=8,B=8,一个像素占用字节 = 8+8+8+8 = 32位 = 4个字节 RGB_565 16位 R=5,G=6,B=5,因为没有A，所以它没有透明度，计算同上也是占用2个字节像平常如果没有透明度要求使用RGB_565即可2.2、优化的本质前面已经提到我们的图片优化实际是内存的优化，而我们的内存计算公式是：内存占用宽高相乘 * 每像素占用的内存位数，所以要么就减少图片内存占用宽高，要么就减少像素占用内存数。减少像素内存占用数可以通过配置Bitmap.Config解决，而减少图片内存占用宽高，可以有以下几个方式：1.缩小图片实际宽高，缩小到正好正常展示2.匹配合适的像素密度此外还能主动回收占用的内存从而缓解内存紧张的问题。2.3、优化方式分析了一下优化的本质问题，我们可以针对性的使用以下几种方式来进行优化：1.配置BitmapConfig（前面已经讲到）2.拿到一个图片，通过inJustDecodeBounds不消耗内存拿到图片的宽高，然后使用inSampleSize来设置图片的缩放比。简单示例代码:12345678910BitmapFactory.Options options = new BitmapFactory.Options();options.inJustDecodeBounds = true;BitmapFactory.decodeResource(getResources(),R.mipmap.icon_database_xls,options);Log.i(&quot;HJ&quot;,&quot;初始图片宽:&quot;+options.outWidth);Log.i(&quot;HJ&quot;,&quot;初始图片高:&quot;+options.outHeight);options.inSampleSize = 2;options.inJustDecodeBounds = false;BitmapFactory.decodeResource(getResources(),R.mipmap.icon_database_xls,options);Log.i(&quot;HJ&quot;,&quot;缩放后图片宽:&quot;+options.outWidth);Log.i(&quot;HJ&quot;,&quot;缩放后图片高:&quot;+options.outHeight); 运行后：12342019-01-08 17:07:50.935 25900-25900/jie.com.imageoptimize I/HJ: 初始图片宽:642019-01-08 17:07:50.935 25900-25900/jie.com.imageoptimize I/HJ: 初始图片高:642019-01-08 17:07:50.936 25900-25900/jie.com.imageoptimize I/HJ: 缩放后图片宽:322019-01-08 17:07:50.937 25900-25900/jie.com.imageoptimize I/HJ: 缩放后图片高:32 可以看到inSampleSize设为2，图片的宽和高都变成了原来的一半，所以可得缩放公式为：原始图片宽度/inSampleSize = 缩放后的图片宽度。高度同理，所以图片的整体大小变为了原来的1/4。 3.压缩图片，除了外部压缩，内部也可以使用compress()来压缩图片。或者自定义压缩算法，使用比较广泛的有Luban算法 compress()示例代码：123Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.mipmap.icon_database_xls);ByteArrayOutputStream stream = new ByteArrayOutputStream();boolean compress = bitmap.compress(Bitmap.CompressFormat.PNG, 90, stream); 第一个参数是需要生成的图片格式，第二个是压缩百分比，第三个是生成的输出流容器。请注意，此方法只会压缩图片大小，但是并不会减少内存占用。 4.主动释放内存，绑定控件生命周期，在销毁的时候调用recycler()方法1234if(bitmap != null &amp;&amp; !bitmap.isRecycled())&#123; bitmap.recycle(); bitmap = null; &#125;]]></content>
      <categories>
        <category>Android基础进阶</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018年终总结]]></title>
    <url>%2F2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起. 前言人啊，最怕一生碌碌无为，与其平淡中度过，何不为自己定一个小目标，体验先赚他一个亿的刺激梦想!!!! 今年我总结起来就是:蓄势待发与蓄谋已久,嗯，分别对应2018与2019，谋，是我藏在心中的一个目标~ 面试的故事2018年初，考了驾照，回到了家乡长沙开始了长沙开发之旅，记得年初的时候投的第一家公司就是现在的这家公司，当时是技术总监面试的我，对我印象挺好的，当场就决定录用了我，问我什么时候可以过来上班，我因为是第一次在长沙面试，对长沙的大概薪资状况以及互联网发展情况并不是特别的了解，所以我打算再去其他公司看看，对整体都了解一下，我说3天后来上班，这三天里，我去了蓝思科技，世界500强企业，面试官看到我只有2年经验，连一个技术问题都没问就让我回去等通知，说实话我是比较伤心的，因为我觉得工作年限不等于技术，工作年限长不一定技术就会好，起码可以试一试啊，可能这是大公司的一个硬性标准吧，哎，都没领略过大海的波涛汹涌,就被拍死在了沙滩上。随后我去了一家总部在北京的长沙分公司，是做智能化管理的，面试官问了一些非常基础的问题，答完后直接和总监谈薪资，总监觉得我要价高，我说我最低要求就这个价，不能少，随后就GG了，我觉得这或许就是他在长沙开分公司的原因吧，招人相对于北京能节约更多的成本，但你这价格也压得太低了哎…面来面去最后还是第一家公司最满意，于是，我来到了现在的这家公司—–长沙居美网络科技有限公司，主要是做家居建材招商加盟的，现金流非常的充足，公司也挺大的，有200多号人，4个办公场地。 新公司的奋斗故事入职的第一天，技术总监就把我叫到一个会议室谈话，总监说，你是这家公司来的第一个Android开发，公司计划在7月份推出一款app,要在广州的建博会上亮相，天啊，那可是十几万人都会来参加的展会，必须要万无一失，马虎不得，可是，总监透漏，目前公司产品，测试，ui人员还没有招到位……emmmmmmm,我找不到语言来描述我当时的心情，但是这家公司给我的感觉还是挺靠谱的，不像是那种坑人的公司，所以我承诺了要替公司开发好这一款app. 到了3月份，人员果然陆陆续续都找齐了，于是开始干活。作为一款从0开发的app,并且公司在这方面没有任何的知识储备，可以想象难度还是有的，开发一款app,首先第一件事就是把架子搭起来，原来公司的app架构是不能用的，项目太旧，框架太老了，所以只能靠自己搭建。 首先确定的是MVP模式，这没的跑，然后把Activity等的一些基类写好，随后开始封装网络请求，本来考虑使用Retrofit，但是这款框架需要再次封装的东西还是蛮多的，基于快速开发的原因我就使用了OkGo框架，它把所有的一切都帮你封装好了，我在上层写了一些简单的封装就能直接使用了。随后就是各种Utils封装,UI封装，把Rxjava,Glide等常用的框架弄进来，随后的日子就开始了疯狂的码代码,那段时间基本没有在9点钟之前下过班，一直持续到项目成功上线。虽然辛苦，但看到自己的app代码逐渐的成熟完善，成就感也特别的强烈，而且收获也是满满的，懂得了如何搭建好的架构，封装功底也得到了提高，或许，这就是传说的魔鬼历练吧 Kotlin的故事随着项目的成功上线，时间渐渐变得充裕，公司前后也陆续招了一些Android开发进来，总监提拔我当了Android组的组长，每天向她汇报一些开发工作，由于项目处于推广阶段，后期需求增长乏力，留下的空余时间较多，总监说需要增加组员的工作饱和度，于是我就开始了Kotlin的代码重构，对于Kotlin,先前只是了解一点，但是当深入研究了这门语言之后，我意识到它的确能为开发带来很大的便捷（能偷懒）。使用了它之后，我们每一个类平均少了百来行代码，并且其中的扩展函数功能实在是不能太赞。由于不改逻辑，只是单纯的翻译，修改速度特别快，当我们把所有代码都换成Kotlin之后，我们就针对Kotlin的特性从底层到应用层来了个大的封装调整，让代码看起来就是Kotlin编程，而不是Java翻译语言,这样，我的第一个纯Kotlin语言开发的app就这样诞生了. 收获之后在公司的日子就比较平淡了，开发完需求，如果有剩余的时间都是学习新技术来提升自己，最大的收获是学习了小程序开发。而回首今年，在自定义View,多线程开发，以及设计模式的使用，类的封装方面技能上都有很大的提升。并且学会了Kotlin，也学会了看源码，从Kotlin的源码里可以看到许多Kotlin的使用技巧，这对于提升Kotlin的熟练度非常有帮助，并且习惯了研究系统源码，陆陆续续看了一些类的源码，发现源码的世界真的很奇妙，使用这些类时都有了不一样的感觉，通透了许多，果然，有些东西看透才是最重要的。 展望2019年，我已经确定了接下来需要研究的领域：图形图像和音视频领域，为此，我决定花一个多的时间学习c++语言，以应对之后的NDK开发，深入理解相机，美颜效果的实现，AR/VR，视频转码等等领域。并且同时提升一下H5/css/javaScript的开发水平，还有Flutter我也是比较看好的，希望能有个成绩，嗯，就这样~~~~2019加油!!!!]]></content>
      <categories>
        <category>感悟</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android/java 多线程(六)-AsyncTask使用详解及源码分析]]></title>
    <url>%2FThreadsource6.html</url>
    <content type="text"><![CDATA[版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起. 多线程系列历史文章:Android/java 多线程(一)-Thread的使用以及源码分析Android/java 多线程(二)-Thread的好兄弟HandlerAndroid/java 多线程(三)-HandlerThread的使用场景及源码解析Android/java 多线程(四)-IntentServiceAndroid/java 多线程(五)-ThreadPoolExecutor线程池的使用 简介一个Android封装好的轻量级异步抽象类，使用的话需要继承并重写部分方法 作用方便的实现多线程，并能方便的实现主线程与工作线程的通信，并且逻辑都在一个类中，不同于Handler的实现机制在不同的回调中，内部采用线程池管理策略，方便管理 使用介绍123public abstract class AsyncTask&lt;Params, Progress, Result&gt; &#123; ....&#125; 可以看到有三个泛型参数，它们的作用分别是： Params 传递给异步任务的参数类型，对应execute()方法和doInBackground()中的参数类型 Progress 进度跟新参数类型,对应onProgressUpdate()方法返回的参数类型 Result 异步任务执行完毕的返回结果类型，对应doInBackground()方法的返回结果类型和onPostExecute()方法的参数类型 如果不需要使用到，则可以使用Void类代替 简单示例： 申明一个实现类TestAsyncTask，主要打印方法的执行顺序以及参数及运行的线程名称1234567891011121314151617181920212223242526272829303132333435/** * Created by hj on 2018/12/29. * 说明： */public class TestAsyncTask extends AsyncTask&lt;String,Integer,Integer&gt; &#123; @Override protected void onPostExecute(Integer integer) &#123; super.onPostExecute(integer); Log.i(&quot;HJ&quot;,&quot;onPostExecute方法接收的参数值:&quot;+integer+&quot;--&quot;+runThreadName()); &#125; @Override protected void onPreExecute() &#123; super.onPreExecute(); Log.i(&quot;HJ&quot;,&quot;onPreExecute&quot;+&quot;--&quot;+runThreadName()); &#125; @Override protected void onProgressUpdate(Integer... values) &#123; super.onProgressUpdate(values); Log.i(&quot;HJ&quot;,&quot;onProgressUpdate:&quot;+ Arrays.toString(values)+&quot;--&quot;+runThreadName()); &#125; @Override protected Integer doInBackground(String... strings) &#123; Log.i(&quot;HJ&quot;,&quot;doInBackground()&quot;+&quot;--&quot;+runThreadName()); publishProgress(50); return 1; &#125; private String runThreadName()&#123; return &quot;运行在:&quot;+Thread.currentThread().getName()+&quot;线程&quot;; &#125;&#125; 使用：123//必须是在主线程中 TestAsyncTask task = new TestAsyncTask(); task.execute(); 打印结果：1234I/HJ: onPreExecute--运行在:main线程I/HJ: doInBackground()--运行在:AsyncTask #1线程I/HJ: onProgressUpdate:[50]--运行在:main线程I/HJ: onPostExecute方法接收的参数值:1--运行在:main线程 可以看到，只有doInBackground()方法执行在异步线程中，其他的方法都是运行在主线程中，方法执行顺序为：onPreExecute()—-&gt;doInBackground()—-&gt;调用publishProgress()方法—-&gt;onProgressUpdate()——&gt;onPostExecute() 下面介绍一下方法的具体作用: onPreExecute 在进行异步任务处理前的一些数据准备工作 doInBackground 处理异步任务逻辑，内部可以调用publishProgress更新进度 onProgressUpdate 进度更新回调 onPostExecute 异步处理完毕后的结果回调 ，处理ui逻辑 源码解析AsyncTask内部的实现原理为：线程池+Handler 其内部有两个线程池：123public static final Executor SERIAL_EXECUTOR = new SerialExecutor();private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;public static final Executor THREAD_POOL_EXECUTOR; SERIAL_EXECUTOR对应内部的SerialExecutor内部实现类，主要实现了异步任务的顺序分发:123456789101112131415161718192021222324252627282930private static class SerialExecutor implements Executor &#123; final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;(); Runnable mActive; //当前要处理的异步任务 //给execute方法加锁保证了顺序执行 public synchronized void execute(final Runnable r) &#123; //将一个runnable添加进双端队列中 mTasks.offer(new Runnable() &#123; public void run() &#123; try &#123; r.run(); //执行 &#125; finally &#123; scheduleNext(); &#125; &#125; &#125;); if (mActive == null) &#123; scheduleNext(); &#125; &#125; //此方法的作用是将SerialExecutor 池中的任务的第一个任务赋值给mActive ，并压入到 //THREAD_POOL_EXECUTOR线程池中 protected synchronized void scheduleNext() &#123; //poll()方法的作用是删除队列中的第一个并返回结果,如果为null则返回null if ((mActive = mTasks.poll()) != null) &#123; //将第一个任务添加到THREAD_POOL_EXECUTOR线程池中 THREAD_POOL_EXECUTOR.execute(mActive); &#125; &#125; &#125; 而THREAD_POOL_EXECUTOR的实现是在这里：1234567static &#123; ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory); threadPoolExecutor.allowCoreThreadTimeOut(true); THREAD_POOL_EXECUTOR = threadPoolExecutor;&#125; 可以看出它是一个常见的工作线程池，所以，这两个线程池，一个负责消息的任务调度，保证按照顺序执行，另外一个则是真正的异步任务处理池 接下来看一下它的构造方法：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public AsyncTask(@Nullable Looper callbackLooper) &#123; //初始化一个Handler处理主线程的通信 mHandler = callbackLooper == null || callbackLooper == Looper.getMainLooper() ? getMainHandler() : new Handler(callbackLooper); //初始化一个可以存储Params参数的callable实现，其实也是 //THREAD_POOL_EXECUTOR.execute()的执行回调 mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123; public Result call() throws Exception &#123; //里面的回调是不是很熟悉，和HandlerThread类似 mTaskInvoked.set(true); //添加线程标识,用于postResultIfNotInvoked方法的检查 Result result = null; //这就是onPostExecute()方法的result try &#123; Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked result = doInBackground(mParams); //doInBackground方法在这里执行了 Binder.flushPendingCommands(); &#125; catch (Throwable tr) &#123; mCancelled.set(true); //抛异常了取消任务 throw tr; &#125; finally &#123; postResult(result); //此方法的作用是将结果发送到主线程 &#125; return result; &#125; &#125;; //初始化一个Future回调，主要用于检查处理结果是否发送 mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123; //done()方法是在callable()方法之后的回调 @Override protected void done() &#123; try &#123; //执行检查 postResultIfNotInvoked(get()); &#125; catch (InterruptedException e) &#123; android.util.Log.w(LOG_TAG, e); &#125; catch (ExecutionException e) &#123; throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;, e.getCause()); &#125; catch (CancellationException e) &#123; postResultIfNotInvoked(null); &#125; &#125; &#125;; &#125;//mWorker 的实现 private static abstract class WorkerRunnable&lt;Params, Result&gt; implements Callable&lt;Result&gt; &#123; Params[] mParams; //保存传入的参数 &#125; 接下来看看以上检查的方法的实现：12345678910111213141516private void postResultIfNotInvoked(Result result) &#123; //执行了mWorker 里的call()回调的都会变为true,如果为false,说明任务没有被执行 final boolean wasTaskInvoked = mTaskInvoked.get(); if (!wasTaskInvoked) &#123; postResult(result); &#125; &#125; //将此AsyncTask对象作为message参数发送,接收到之后就会调用finish()方法结束 private Result postResult(Result result) &#123; @SuppressWarnings(&quot;unchecked&quot;) Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result)); message.sendToTarget(); return result; &#125; 其中的getHandler()中的Handler的实现类是InternalHandler，来看看它的实现：1234567891011121314151617181920212223242526272829303132333435363738 private static class InternalHandler extends Handler &#123; public InternalHandler(Looper looper) &#123; super(looper); &#125; @SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;&#125;) @Override public void handleMessage(Message msg) &#123; AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj; switch (msg.what) &#123; case MESSAGE_POST_RESULT: //result.mData[0]就是从postResult发送过来的AsyncTask对象 result.mTask.finish(result.mData[0]); //处理结果分发，回调对应的方法 break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); //这里处理进度更新 break; &#125; &#125; &#125;private void finish(Result result) &#123; // 先判断是否调用了Cancelled() // 1. 若调用了则执行我们复写的onCancelled（） // 即 取消任务时的操作 if (isCancelled()) &#123; onCancelled(result); &#125; else &#123; // 2. 若无调用Cancelled()，则执行我们复写的onPostExecute(result) // 即更新UI操作 onPostExecute(result); &#125; // 注：不管AsyncTask是否被取消，都会将AsyncTask的状态变更为：FINISHED mStatus = Status.FINISHED; &#125; 最后来看一下执行方法execute():1234567891011121314151617181920212223242526272829 @MainThread public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123; return executeOnExecutor(sDefaultExecutor, params); &#125;@MainThread public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) &#123; if (mStatus != Status.PENDING) &#123; switch (mStatus) &#123; case RUNNING: throw new IllegalStateException(&quot;Cannot execute task:&quot; + &quot; the task is already running.&quot;); case FINISHED: throw new IllegalStateException(&quot;Cannot execute task:&quot; + &quot; the task has already been executed &quot; + &quot;(a task can be executed only once)&quot;); &#125; &#125; mStatus = Status.RUNNING; onPreExecute(); mWorker.mParams = params; //mWorker中的参数是在这里保存的 exec.execute(mFuture); //将mFuture对象添加到THREAD_POOL_EXECUTOR 线程池中，mFuture在构造方法中做了初始化。 return this; &#125; 总结：1.初始化两个线程池，一个负责任务调度(SerialExecutor),一个负责任务处理THREAD_POOL_EXECUTOR2.构造方法中实例化了子线程中的callable接口方法，从WorkerRunnable中取出Params对象并赋值给dodoInBackground(mParams)方法执行耗时任务。3.执行execute()方法将任务提交到THREAD_POOL_EXECUTOR线程池中，并将Params参数赋值到了WorkerRunnable中。4.调用了postResult(result),通过InternalHandler 将消息回调到了主线程（执行了finish()方法，里面有onPostExecute方法),实现了UI的更新]]></content>
      <categories>
        <category>多线程编程</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android/java 多线程(五)-ThreadPoolExecutor线程池的使用]]></title>
    <url>%2FThreadsource5.html</url>
    <content type="text"><![CDATA[版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起. 多线程系列历史文章:Android/java 多线程(一)-Thread的使用以及源码分析Android/java 多线程(二)-Thread的好兄弟HandlerAndroid/java 多线程(三)-HandlerThread的使用场景及源码解析Android/java多线程(四)-IntentService 前面几篇文章主要都是介绍的单个线程的运用以及原理，这篇文章开始讲解多个线程的运用 简介线程池是一个能对多个线程进行统一管理的一套机制，它具有诸多的优点： 能对线程进行复用，当有空闲的线程，线程池会复用这些线程而不会去重新创建，节省了资源 能灵活创建各种线程使用场景，内部封装了常用线程池创建逻辑，并支持自定义线程池逻辑创建 能准确的对每一个线程进行管理，并能读取每个线程的一写基础信息，方便进行一些逻辑处理 缺点：线程中的数据传递没有Handler机制方便 使用场景：具有诸多耗时任务的情况，当系统为每一个任务创建一个线程，会占用系统的大量资源，容易引起界面的卡顿，线程池的复用机制就很好的解决了这个问题 常用的线程池的使用自定义线程池123456789101112131415161718192021public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler;&#125; 传入不同的参数，实现的效果也不同,下面说一下每个参数的作用: corePoolSize 核心线程数,，即使空闲时仍保留在池中的线程数,除非设置了allowCoreThreadTimeOut maximumPoolSize 线程池中允许的最大线程数 keepAliveTime 顾名思义，线程终止前的存活时间，即当线程数大于核心线程数(corePoolSize )时,多余的空闲线程在终止之前等待新任务的最大时间 TimeUnit keepAliveTime的单位 workQueue 在执行任务之前用于保存任务的队列。 该队列将仅保存execute方法提交的Runnable任务。 ThreadFactory 执行程序创建新线程时使用的工厂 RejectedExecutionHandler 执行被阻止时使用的处理程序 这里说一下各个参数的配置套路,当使用execute(Runnable)方法添加一个任务到队列中，如果corePoolSize比maximumPoolSize小，队列满了后就会去创建新的线程,当corePoolSize与maximumPoolSize相等时，就会创建一个固定大小的核心线程池。如果将maximumPoolSize设置为无限大(例如nteger.MAX_VALUE)，则是创建一个能容纳任意数量任务的线程池。ThreadFactory的作用是用来创建新的线程的，它是一个接口,实现它即可创建一个新的线程：123456789101112public interface ThreadFactory &#123; /** * Constructs a new &#123;@code Thread&#125;. Implementations may also initialize * priority, name, daemon status, &#123;@code ThreadGroup&#125;, etc. * * @param r a runnable to be executed by new thread instance * @return constructed thread, or &#123;@code null&#125; if the request to * create a thread is rejected */ Thread newThread(Runnable r);&#125; 通过它，你可以指定线程的名称，优先级，守护进程等，如果不设置，则会默认使用Executors.defaultThreadFactory()，它会创建一个与所有线程与所有相同的ThreadGroup并且具有相同的优先级和非守护进程状态NORM_PRIORITY。workQueue是一个排队策略,一般有三种: 直接切换：对应SynchronousQueue实现类，将任务直接交给线程处理，不需要另外的控制，通常需要配置一个无限制的maximumPoolSizes，以避免拒绝掉新提交的任务 无界队列:对应LinkedBlockingDeque实现类，它没有预定的容量，当有新的任务，会在队列中等待，直到加入到corePoolSize的线程中，如果corePoolSize线程一直很忙，也不会去创建新的线程，此时，最大值最小值对它没有任何的影响，每个任务与其他的任务都是独立的，不会互相影响 有边界的队列：例如ArrayBlockingQueue实现类,它有助于在使用有限的maxPoolSize时防止资源的耗尽，但它更难调整与控制。 一般情况下我们都可以通过java提供的工厂模式来构造我们的线程池策略，主要提供了以下几种方式: newFixedThreadPool特点: 线程重用，如果没有重用的线程，将会创建一个新的线程添加到池中 适合执行短期异步任务程序，默认为60秒的线程等待时间，超过就会终止与移除 闲置的线程不会消耗资源 源码配置：12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; 使用场景:它创建了一个无限扩大的线程池，但没有核心线程池，因此资源占用少，适合处理一些短期的异步任务 newFixedThreadPool特点: 创建一个固定数量的线程池，不能随时的新建线程，如果队列已满，提交了新任务，必须等待一个可用的线程 线程会一直存在，直到调用shutdown方法 源码配置:12345public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; 使用场景:它创建了一个核心线程数与最大线程数相同的线程池，适用于已知任务数量，对线程数量进行限制的场景 newWorkStealingPool特点: 创建使用所有给定并行级别的线程池，并且可以使用多个队列来减少占用123456public static ExecutorService newWorkStealingPool() &#123; return new ForkJoinPool (Runtime.getRuntime().availableProcessors(), ForkJoinPool.defaultForkJoinWorkerThreadFactory, null, true);&#125; 使用场景:它能创建一个拥有多个任务队列的线程池，可以减少链接数。并且它是默认创建当前可用cpu数量的线程来并行执行，因此适用于非常耗时的操作，并且可以并行执行 newSingleThreadExecutor特点： 有且只有一个任务处于活动状态 先提交的先执行，有任务顺序 当任务出现异常，会另创建一个新的线程替换123456public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125; 使用场景:它是一个单例线程，并且有执行顺序，所以适用于有执行顺序的任务，并且有且只有一个任务是执行中的 ScheduledThreadPoolExecutor特点： 能设置延迟时间，能定期执行 空闲的线程会保留 12345public ScheduledThreadPoolExecutor(int corePoolSize) &#123; super(corePoolSize, Integer.MAX_VALUE, DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS, new DelayedWorkQueue());&#125; 使用场景：它具有定时特性，因此可以用来执行周期行的任务 五大线程池介绍完毕，此外还有其他的常用方法: execute(Runnable command) 提交任务，在将来的某个时间点执行任务 afterExecute(Runnale r,Throwable t) 在指定的Runnale执行后调用此方法 beforeExecute(Thread t,Runnable r)在给定的线程中执行给定的Runnable之前调用方法 funalize 当执行器不再被引用并且没有线程时，调用shundown shundown 启动有序关闭，先前提交的任务会执行，执行完毕后关闭 shundownNow 主动停止执行中的任务，并返回正在执行等待的任务列表]]></content>
      <categories>
        <category>多线程编程</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android/java多线程(四)-IntentService]]></title>
    <url>%2FThreadsource4.html</url>
    <content type="text"><![CDATA[版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起. 往期文章:Android/java 多线程(一)-Thread的使用以及源码分析Android/java 多线程(二)-Thread的好兄弟HandlerAndroid/java 多线程(三)-HandlerThread的使用场景及源码解析 简介一个方便的能在子线程中运行的服务，一个IntentService对应一个线程，由于是四大组件，优先级比线程高，不易被系统回收，处理完任务还能主动回收，因此用来处理后台下载任务极为适合 简单使用先继承此类，重写必要的方法，我们的逻辑处理是在onHandleIntent()方法中12345678910111213141516171819202122232425262728293031323334/** * Created by hj on 2018/12/21. * 说明： */public class MyIntentService extends IntentService &#123; public MyIntentService() &#123; super(&quot;MyIntentService&quot;); &#125; @Override protected void onHandleIntent(@Nullable Intent intent) &#123; //核心方法，处理异步逻辑 Log.i(&quot;HJ&quot;,&quot;onHandleIntent&quot;); &#125; @Override public int onStartCommand(@Nullable Intent intent, int flags, int startId) &#123; Log.i(&quot;HJ&quot;,&quot;onStartCommand&quot;); return super.onStartCommand(intent, flags, startId); &#125; @Override public void onCreate() &#123; Log.i(&quot;HJ&quot;, &quot;onCreate&quot;); super.onCreate(); &#125; @Override public void onDestroy() &#123; Log.i(&quot;HJ&quot;,&quot;onDestroy&quot;); super.onDestroy(); &#125;&#125; 在清单文件中注册:12345&lt;service android:name=&quot;.MyIntentService&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;com.jay.thread&quot;/&gt; &lt;/intent-filter&gt;&lt;/service&gt; 在Activity中运行：123Intent intent = new Intent(&quot;com.jay.thread&quot;);intent.setPackage(getPackageName());startService(intent); 打印的结果如下：12342018-12-21 15:03:14.848 4241-4241/com.zj.example.customview.funnel I/HJ: onCreate2018-12-21 15:03:14.850 4241-4241/com.zj.example.customview.funnel I/HJ: onStartCommand2018-12-21 15:03:14.850 4241-4258/com.zj.example.customview.funnel I/HJ: onHandleIntent2018-12-21 15:03:16.225 4241-4241/com.zj.example.customview.funnel I/HJ: onDestroy 可以看到，它的生命周期是onCreate()-&gt;onStartCommand()-&gt;onHandleIntent()-&gt;onDestroy(),而且当它把onHandleIntent()方法里的逻辑处理完毕后会自动调用onDestroy来结束，所以我们不需要主动来关闭它。 而且说到隐式启动Service，这里要叨逼两句，如果我把上面的intent.setPackage(getPackageName())去掉那么在5.0以上机型会遇到这种异常：123456789101112131415161718Caused by: java.lang.IllegalArgumentException: Service Intent must be explicit: Intent &#123; act=com.jay.thread &#125; at android.app.ContextImpl.validateServiceIntent(ContextImpl.java:1448) at android.app.ContextImpl.startServiceCommon(ContextImpl.java:1489) at android.app.ContextImpl.startService(ContextImpl.java:1461) at android.content.ContextWrapper.startService(ContextWrapper.java:644) at com.zj.example.customview.funnel.MainActivity.onCreate(MainActivity.java:34) at android.app.Activity.performCreate(Activity.java:6975) at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1213) at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2770) at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2892) at android.app.ActivityThread.-wrap11(Unknown Source:0) at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1593) at android.os.Handler.dispatchMessage(Handler.java:105) at android.os.Looper.loop(Looper.java:164) at android.app.ActivityThread.main(ActivityThread.java:6541) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.Zygote$MethodAndArgsCaller.run(Zygote.java:240) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:767) 原因是在5.0源码中谷歌做了限制，如果component和package都为空，那么就会抛出这个异常，详见源码(源码位置：sdk/sources/android21/android/app/ContextImpl.java）:123456789101112private void validateServiceIntent(Intent service) &#123; if (service.getComponent() == null &amp;&amp; service.getPackage() == null) &#123; if (getApplicationInfo().targetSdkVersion &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; IllegalArgumentException ex = new IllegalArgumentException( &quot;Service Intent must be explicit: &quot; + service); throw ex; &#125; else &#123; Log.w(TAG, &quot;Implicit intents with startService are not safe: &quot; + service + &quot; &quot; + Debug.getCallers(2, 3)); &#125; &#125; &#125; So,我们只要保证其中一个不为空就可以啦. 源码解析源码还是比较简单，可以先从onCreate()方法看起，具体逻辑见注释：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596public abstract class IntentService extends Service &#123; private volatile Looper mServiceLooper; //HandlerThread中的Looper private volatile ServiceHandler mServiceHandler; //逻辑处理Handler private String mName; //线程名称 private boolean mRedelivery; //是否保证intent在服务被杀死后能被接收到 //子线程Handler的逻辑处理类 private final class ServiceHandler extends Handler &#123; public ServiceHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; onHandleIntent((Intent)msg.obj); //onHandleIntent方法回调 stopSelf(msg.arg1); //自动回收 &#125; &#125; public IntentService(String name) &#123; super(); mName = name; &#125; /** *此方法的作用：如果为true,则将Service StartResult状态置为START_REDELIVER_INTENT,这样当onHandleIntent方法还未回调的时候服务被回收，重启的时候onHandleIntent方法会被回调,发送上一次回收前的intent,如果有多个intent,将会发送最后一个意图 * **/ public void setIntentRedelivery(boolean enabled) &#123; mRedelivery = enabled; &#125; @Override public void onCreate()&#123; super.onCreate(); //创建HandlerThread 并将线程命名为IntentService+自定义名称的形式 HandlerThread thread = new HandlerThread(&quot;IntentService[&quot; + mName + &quot;]&quot;); thread.start(); mServiceLooper = thread.getLooper(); mServiceHandler = new ServiceHandler(mServiceLooper); //将HandlerThread里初始化的looper设置给子线程Handler &#125; @Override public void onStart(@Nullable Intent intent, int startId) &#123; Message msg = mServiceHandler.obtainMessage(); msg.arg1 = startId; msg.obj = intent; //我们在onHandleIntent方法里接收的intent是在这里赋值的 mServiceHandler.sendMessage(msg); &#125; /** * You should not override this method for your IntentService. Instead, * override &#123;@link #onHandleIntent&#125;, which the system calls when the IntentService * receives a start request. * @see android.app.Service#onStartCommand */ @Override public int onStartCommand(@Nullable Intent intent, int flags, int startId) &#123; onStart(intent, startId); //StartResult状态设置是在这里 return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY; &#125; @Override public void onDestroy() &#123; mServiceLooper.quit(); &#125; //这里将返回值置为了null，所以不建议使用bindService的形式来启动它，如果需要，建议直接使用Service @Override @Nullable public IBinder onBind(Intent intent) &#123; return null; &#125; /** * This method is invoked on the worker thread with a request to process. * Only one Intent is processed at a time, but the processing happens on a * worker thread that runs independently from other application logic. * So, if this code takes a long time, it will hold up other requests to * the same IntentService, but it will not hold up anything else. * When all requests have been handled, the IntentService stops itself, * so you should not call &#123;@link #stopSelf&#125;. * * @param intent The value passed to &#123;@link * android.content.Context#startService(Intent)&#125;. * This may be null if the service is being restarted after * its process has gone away; see * &#123;@link android.app.Service#onStartCommand&#125; * for details. */ @WorkerThread protected abstract void onHandleIntent(@Nullable Intent intent);&#125; 我们在源码中看到，内部实现其实还是HandlerThread+Handler的方式，onCreate()中做了一些初始化的操作，在onStart中将intent用obj的方式传递给了ServiceHandler,然后在handleMessage中拿到intent并调用了onHandleIntent回调出来，这样一个完整的线程有序循环就建立了，而且因为是四大组件，存活率有很大的提升，这是直接用线程实现所没有的优势 看完了源码，有没有对HandlerThread+Handler的应用进一步加深呢？]]></content>
      <categories>
        <category>多线程编程</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android/java多线程(三)-HandlerThread的使用场景及源码解析]]></title>
    <url>%2FThreadsource3.html</url>
    <content type="text"><![CDATA[版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起. HandlerThread是什么？点开类楸一眼，这货是这样介绍自己的：12* Handy class for starting a new thread that has a looper. The looper can then be * used to create handler classes. Note that start() must still be called. 大意是说它是用来启动具有一个内部循环的新线程的一个便利类。内部循环？同时名称又有Handler又有Thread，看过我这篇文章的同学估计猜到了，这货估计是Handler与Thread的亲儿子无疑了,但是两个好基友哪来的儿子呢，囧~~~~往期目录：Android/java 多线程(一)-Thread的使用以及源码分析Android/java 多线程(二)-Thread的好兄弟Handler 我在上篇文章介绍Handler的时候举了一个例子，在子线程中使用Handler：123456789101112131415161718class MyThread extends Thread &#123; @Override public void run() &#123; Looper.prepare(); @SuppressLint(&quot;HandlerLeak&quot;) Handler mHandler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; //处理逻辑 l(Thread.currentThread().getName()); &#125; &#125;; Message message = mHandler.obtainMessage(1); mHandler.sendMessage(message); Looper.loop(); &#125;&#125; 是不是显得巨麻烦，而且巨丑，HandlerThread就是为了防止我们写出如此丑陋的代码而生的，它的本质原理其实也就是以上那几行代码。不信？，我们来瞅瞅 HandlerThread源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102public class HandlerThread extends Thread &#123; int mPriority; //线程优先级 int mTid = -1; Looper mLooper; private @Nullable Handler mHandler;//指定线程的名称，默认线程优先级为DEFAULT,也是最低级的 public HandlerThread(String name) &#123; super(name); mPriority = Process.THREAD_PRIORITY_DEFAULT; &#125; //指定线程的名称，同时指定线程的优先级 public HandlerThread(String name, int priority) &#123; super(name); mPriority = priority; &#125; //这里主要处理一些数据的初始化啊一些子线程的逻辑操作啥的，在run()方法中回调 protected void onLooperPrepared() &#123; &#125; //熟悉的run()方法 @Override public void run() &#123; mTid = Process.myTid(); Looper.prepare(); //创建Looper() synchronized (this) &#123; mLooper = Looper.myLooper(); notifyAll(); //到这里Looper已经创建完毕，唤醒阻塞的线程 &#125; //设置线程优先级 Process.setThreadPriority(mPriority); onLooperPrepared(); //执行onLooperPrepared()方法 Looper.loop(); //开启循环 mTid = -1; &#125; /** * This method returns the Looper associated with this thread. If this thread not been started * or for any reason isAlive() returns false, this method will return null. If this thread * has been started, this method will block until the looper has been initialized. * @return The looper. */ public Looper getLooper() &#123; if (!isAlive()) &#123; return null; &#125; // If the thread has been started, wait until the looper has been created. synchronized (this) &#123; while (isAlive() &amp;&amp; mLooper == null) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125; return mLooper; &#125; /** * @return a shared &#123;@link Handler&#125; associated with this thread * @hide */ @NonNull public Handler getThreadHandler() &#123; if (mHandler == null) &#123; mHandler = new Handler(getLooper()); &#125; return mHandler; &#125; //非安全的结束循环 public boolean quit() &#123; Looper looper = getLooper(); if (looper != null) &#123; looper.quit(); return true; &#125; return false; &#125; ////安全的结束循环 public boolean quitSafely() &#123; Looper looper = getLooper(); if (looper != null) &#123; looper.quitSafely(); return true; &#125; return false; &#125; /** * Returns the identifier of this thread. See Process.myTid(). */ public int getThreadId() &#123; return mTid; &#125;&#125; 结合源码，这货其实也就是在run()中开启了Looper循环，并提供了一个onLooperPrepared ()方法供我们使用，做一些初始化的操作。需要注意的是quit()方法和quitSafely()的区别，quit()是立即停止Looper循环，此时可能有消息未处理就GG了，所以说它的不安全的，而quitSafely()是等待消息处理完毕后才停止Looper循环，所以说它是安全的，另外可以看到它指定线程优先级是使用的Process.setThreadPriority(mPriority)方法，所有它的可选值是从Process()里面获取 HandlerThread的使用场景HandlerThread小朋友的优点HandlerThread里面的本质实际上是子线程消息轮询机制，我们能够从中获取到一个在子线程中轮询的Looper，如果设置给Handler,那么这个Handler就能在子线程中处理消息。所以它特别适合处理大量需要排队等待或需要重复操作的又耗时的逻辑，它既能够方便的通知主线程更新UI，内部又能方便的做线程的队列处理，所以它的使用还是比较广泛滴。 举个栗子假设有这么个需求：需要批量下载文件，一次只能下载一个，下载完毕后自动下载下一个，或者这个下载失败或暂停自动下载下一个(是不是有点像某雷的下载场景)，伪实现如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/** * Created by hj on 2018/12/21. * 说明：模拟线程下载 */public class DownloadHandlerThread extends HandlerThread implements Handler.Callback &#123; private Handler workHandler; //处理下载逻辑的Handler private Handler uiHandler; //处理UI刷新的Handler public final static int READY = 0X110; public final static int STAR = 0X111; public final static int STOP = 0X112; public final static int ERROR = 0X113; private int max; private int index; public DownloadHandlerThread() &#123; super(&quot;download-thread&quot;); &#125; @Override protected void onLooperPrepared() &#123; //初始化 workHandler = new Handler(getLooper(), this); if (uiHandler == null) &#123; throw new NullPointerException(&quot;uiHandler is not null&quot;); &#125; uiHandler.sendEmptyMessage(READY); //通知主线程Looper已经准备完毕，可以开始下载了 &#125; @Override public boolean handleMessage(Message msg) &#123; switch (msg.what) &#123; case STAR: //开始下载 index++; //记录当前下载到了第几个 String url = msg.getData().getString(&quot;url&quot;); Log.i(&quot;HJ&quot;, &quot;准备下载：&quot; + url); try &#123; sleep(2000); //模拟下载 if (index == 2) &#123; //下载到第二个的时候模拟下载失败 Log.i(&quot;HJ&quot;, &quot;下载出错：&quot; + url); setErrorMessage(url); Log.i(&quot;HJ&quot;, &quot;开始下载下一个地址&quot;); &#125; else &#123; Log.i(&quot;HJ&quot;, &quot;当前地址下载完成：&quot; + url); &#125; &#125; catch (InterruptedException e) &#123; setErrorMessage(url); e.printStackTrace(); &#125; if (index == max) &#123; //全部下载完毕 workHandler.sendEmptyMessage(STOP); &#125; break; case STOP: //全部下载完成 //退出Looper循环 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR2) &#123; quitSafely(); &#125; else &#123; quit(); &#125; Log.i(&quot;HJ&quot;, &quot;全部下载完成&quot;); break; &#125; return false; &#125; //发送下载错误消息到主线程用于刷新UI private void setErrorMessage(String url) &#123; Message errorMsg = new Message(); errorMsg.what = ERROR; Bundle bundle = new Bundle(); bundle.putString(&quot;errorUrl&quot;, url); errorMsg.setData(bundle); uiHandler.sendMessage(errorMsg); &#125; public void setUiHandler(Handler uiHandler) &#123; this.uiHandler = uiHandler; &#125; public Handler getWorkHandler() &#123; return workHandler; &#125; public void setMax(int max) &#123; this.max = max; &#125;&#125; 在Activity中使用：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class MainActivity extends AppCompatActivity &#123; private Handler uiHandler; //模拟数据源 private String[] urls = new String[]&#123; &quot;url-1&quot;, &quot;url-2&quot;, &quot;url-3&quot;, &quot;url-4&quot;, &quot;url-5&quot; &#125;; private DownloadHandlerThread mThread; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initUiHandler(); initDownLoad(); &#125; @SuppressLint(&quot;HandlerLeak&quot;) private void initUiHandler() &#123; uiHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case DownloadHandlerThread.READY: //获取到workHandler已经初始化完毕，可以进行下载任务了 Handler workHandler = mThread.getWorkHandler(); mThread.setMax(urls.length); for (String url : urls) &#123; //循环将Message加入MessageQueue消息池中 Message message = new Message(); message.what = DownloadHandlerThread.STAR; Bundle bundle = new Bundle(); bundle.putString(&quot;url&quot;, url); message.setData(bundle); workHandler.sendMessage(message); &#125; break; case DownloadHandlerThread.ERROR: //处理下载失败UI逻辑 String url = msg.getData().getString(&quot;errorUrl&quot;); showShortToast(&quot;下载失败链接:&quot; + url); Log.i(&quot;HJ&quot;,&quot;展示下载失败UI&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;); break; &#125; &#125; &#125;; &#125; private void showShortToast(String string) &#123; Toast.makeText(this, string, Toast.LENGTH_SHORT).show(); &#125; private void initDownLoad() &#123; mThread = new DownloadHandlerThread(); mThread.setUiHandler(uiHandler); mThread.start(); &#125;&#125; 运行结果如下：123456789101112132018-12-21 11:51:02.775 2390-2432/com.zj.example.customview.funnel I/HJ: 准备下载：url-12018-12-21 11:51:04.775 2390-2432/com.zj.example.customview.funnel I/HJ: 当前地址下载完成：url-12018-12-21 11:51:04.775 2390-2432/com.zj.example.customview.funnel I/HJ: 准备下载：url-22018-12-21 11:51:06.777 2390-2432/com.zj.example.customview.funnel I/HJ: 下载出错：url-22018-12-21 11:51:06.777 2390-2432/com.zj.example.customview.funnel I/HJ: 开始下载下一个地址2018-12-21 11:51:06.778 2390-2432/com.zj.example.customview.funnel I/HJ: 准备下载：url-32018-12-21 11:51:06.779 2390-2390/com.zj.example.customview.funnel I/HJ: 展示下载失败UI&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;2018-12-21 11:51:08.778 2390-2432/com.zj.example.customview.funnel I/HJ: 当前地址下载完成：url-32018-12-21 11:51:08.778 2390-2432/com.zj.example.customview.funnel I/HJ: 准备下载：url-42018-12-21 11:51:10.779 2390-2432/com.zj.example.customview.funnel I/HJ: 当前地址下载完成：url-42018-12-21 11:51:10.779 2390-2432/com.zj.example.customview.funnel I/HJ: 准备下载：url-52018-12-21 11:51:12.783 2390-2432/com.zj.example.customview.funnel I/HJ: 当前地址下载完成：url-52018-12-21 11:51:12.783 2390-2432/com.zj.example.customview.funnel I/HJ: 全部下载完成 可以看到DownloadHandlerThread主要承载的功能如下: 初始化一个子线程Handler用于处理子线程的消息通信 执行下载任务以及与主线程的ui通信 这样的处理方式极大的方便了ui线程与子线程的通讯，只需要用不同的handler发送消息即可，来再多的handler都不怕。而且这只需要开启一个线程，极大的节省了内存空间，而且能让线程任务有序进行，方便管理。 建议将以上代码复制过去跑一跑，调试一下，这样能更快的理解HandlerThread的通信以及它的便捷通信机制。]]></content>
      <categories>
        <category>多线程编程</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android/java 多线程(二)-Thread的好兄弟Handler]]></title>
    <url>%2Fmultithreading2.html</url>
    <content type="text"><![CDATA[版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起. 上一篇带大家了解了Thread的使用以及基本的运行原理，这一篇就带大家了解下Thread的好兄弟Handler Android/java 多线程(一)-Thread的使用以及源码分析 简介Handler机制在安卓中应用非常广泛，像我们常见的用于在子线程中更新UI：123456789101112131415161718192021222324252627282930public class MainActivity extends AppCompatActivity &#123; @SuppressLint(&quot;HandlerLeak&quot;) private Handler mHandler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; //更新UI &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); MyThread thread = new MyThread(); thread.start(); &#125; class MyThread extends Thread &#123; @Override public void run() &#123; //处理子线程逻辑 //.... //发送消息更新UI Message message = mHandler.obtainMessage(1); mHandler.sendMessage(message); &#125; &#125;&#125; 由此引出一些问题，为什么sendMessage之后handleMessage方法会被执行?.为什么handleMessage是在主线程中?.它们的消息是如何传递的?.这些会在下面讲解 且看还有一种使用情况，在子线程中使用Handler:123456789101112131415161718192021222324252627282930313233public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); MyThread thread = new MyThread(); thread.start(); &#125; class MyThread extends Thread &#123; @Override public void run() &#123; Looper.prepare(); @SuppressLint(&quot;HandlerLeak&quot;) Handler mHandler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; //处理逻辑 l(Thread.currentThread().getName()); &#125; &#125;; Message message = mHandler.obtainMessage(1); mHandler.sendMessage(message); Looper.loop(); &#125; &#125; public void l(String s) &#123; Log.i(&quot;HJ&quot;, s); &#125;&#125; 打印结果如下：12018-12-20 10:48:21.682 1808-1824/? I/HJ: Thread-2 如果我们不使用Looper.prepare()和Looper.loop()方法，直接运行，那么会抛出以下异常：1234562018-12-20 11:00:49.654 2029-2045/com.zj.example.customview.funnel E/AndroidRuntime: FATAL EXCEPTION: Thread-2 Process: com.zj.example.customview.funnel, PID: 2029 java.lang.RuntimeException: Only one Looper may be created per thread at android.os.Looper.prepare(Looper.java:95) at android.os.Looper.prepare(Looper.java:90) at com.zj.example.customview.funnel.MainActivity$MyThread.run(MainActivity.java:48) 这是为什么呢？，为什么子线程不能直接创建Handler呢？使用了Looper.prepare()和Looper.loop()为什么又可以了呢？，这两个方法又是干什么用的呢？请看以下源码分析。 原理分析Handler机制的核心类主要有三个，Handler ,Message,Looper,而与Looper相关联的类还有ThreadLocal和MessageQueue,下面来一一介绍下它们的作用: Message消息的载体，内部主要存放一些消息类型，参数主要有：（1）public int what：变量，用于定义此Message属于何种操作（2）public Object obj：变量，用于定义此Message传递的信息数据，通过它传递信息（3）public int arg1：变量，传递一些整型数据时使用（4）public int arg2：变量，传递一些整型数据时使用（5）public Handler getTarget()：普通方法，取得操作此消息的Handler对象。在该类的使用上，尽量使用obtain()方法来获取，而非构造方法，这样可以节省内存。而在数据传递方面，如果是int类型的，建议使用arg1和arg2,其次再考虑使用Bundle Looper消息通道，消息机制的主要逻辑实现类，内部有使用ThreadLocal用来保存当前线程的Looper,使用MessageQueue用来维护Message池，而我们使用Looper.prepare()方法其实也就是将此线程的Looper对象加入到ThreadLocal中去：1234567891011public static void prepare() &#123; prepare(true);&#125;private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; //一个线程只能创建一个Looper throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125; 看源码就知道，当前线程中有且只有一个Looper，当我们再次创建，就会抛出异常，所以上面抛异常的原因就是在这里。 而我们的loop()方法就是消息机制的核心，原理是实现了一个无限循环，用于从MessageQueue中取出消息分发到各个Handler中去，以下是精简源码：1234567891011121314151617181920212223242526272829303132333435public static void loop() &#123; //从ThreadLocal中取出Looper final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;); &#125; //从Looper中获取到MessageQueue final MessageQueue queue = me.mQueue; ........ //创建循环 for (;;) &#123; //从MessageQueue中一个一个的取出Message Message msg = queue.next(); // might block if (msg == null) &#123; //没消息取了就退出 return; &#125; ........... final long start = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis(); final long end; try &#123; //dispatchMessage方法的调用在这 msg.target.dispatchMessage(msg); end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis(); &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; ......... //回收消息，同时将Message置为空消息对象，存储在消息池中，用于obtain()方法再次获取 msg.recycleUnchecked(); &#125; &#125; 综合要点就是使用loop()来开启消息分发，并且使用prepare来创建Looper。并且一个线程只能有一个Looper。 可以看到，dispatchMessage就是在这里回调的，那这个target是什么东西呢，其实就是我们的Handler对象。那这个Handler对象是在哪里赋值的呢，请看Handler源码 Handler首先看我们的构造方法最终会调用到这里：12345678910111213141516171819public Handler(Callback callback, boolean async) &#123; if (FIND_POTENTIAL_LEAKS) &#123; final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123; Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; + klass.getCanonicalName()); &#125; &#125; //这里就将Looper创建好了，主要这里是在主线程中 mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async;&#125; 这里主要起到从ThreadLocal中获取Looper对象的作用。看Looper.myLooper()方法：1234567/** * Return the Looper object associated with the current thread. Returns * null if the calling thread is not associated with a Looper. */public static @Nullable Looper myLooper() &#123; return sThreadLocal.get();&#125; 随后我们会调用sendMessage()类型的方法来发送消息，最终都会调用这个方法：1234567private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; //这里将Handler赋值了 if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; 注意看这里msg.target = this，这里实现了将当前Handler赋值到了Message中。随后调用了enqueueMessage方法就将此Message投入到了消息池MessageQueue中.到这里，一系列的初始化与调用都完成了。 所以，经过以上分析，我们之前的问题就迎刃而解了，但是还是有一个问题，我们在第一个实例中并没有使用Looper的prepare和loop方法，那我们的消息机制为什么会生效呢，其实在我们的app创建的时候系统已经默认为我们开启了，并且是在主程序的最后调用的，并没有在onCreate()方法中,而其他的生命周期方法，是通过AMS进行回调。这就保证了我们的循环不会造成主线程卡顿，具体的源码调用是在ActivityThread类中的main函数中:1234567891011121314151617181920212223242526272829303132333435363738394041public static void main(String[] args) &#123; SamplingProfilerIntegration.start(); // CloseGuard defaults to true and can be quite spammy. We // disable it here, but selectively enable it later (via // StrictMode) on debug builds, but using DropBox, not logs. CloseGuard.setEnabled(false); Environment.initForCurrentUser(); // Set the reporter for event logging in libcore EventLogger.setReporter(new EventLoggingReporter()); Security.addProvider(new AndroidKeyStoreProvider()); // Make sure TrustedCertificateStore looks in the right place for CA certificates final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId()); TrustedCertificateStore.setDefaultUserDirectory(configDir); Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;); Looper.prepareMainLooper(); // //为当前线程（主线程）创建一个Looper对象 ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); //为当前线程设置Handler &#125; AsyncTask.init(); if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;)); &#125; Looper.loop(); // 执行从消息队列中获取Message，并调用Handler进行处理的无限循环；所有和主线程相关的消息处理都在该方法中执行 throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);&#125; 分析到这，Handler流程其实也差不多了，最后做下总结: 1.在主线程中初始化了一个Handler,此时Looper.loop()已经开启，通过Handler构造方法创建了一个在主线程中的Looper，并保存到了ThreadLocal中，此时主线程不允许再创建第二个Looper. 2.在子线程中使用sendMessage方法，此时会调用enqueueMessage()方法并创建一个Message(或从池中取出空Message对象),然后我们将需要发送的消息保存在Message中，并将此Handler保存到Message的target对象中，然后压入到MessageQueue消息池中 3.Looper中会循环从MessageQueue中取出Message对象，并回调到target对象上的Handler的dispatchMessage()方法中去，由于Looper.loop()方法是在主线程中调用，所以dispatchMessage()方法也是运行在主线程中。Looper.loop()方法运行所在的线程决定dispatchMessage()方法回调的线程，并且需要与Looper.prepare()方法配套使用]]></content>
      <categories>
        <category>多线程编程</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android/java 多线程(一)-Thread的使用以及源码分析]]></title>
    <url>%2FThreadsourse.html</url>
    <content type="text"><![CDATA[版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起. 七牛云过期了，图片也存不了了，以后决定在简书上发布文章，此地只做保存记录我的简书地址,欢迎来逛逛哟~ 线程的概念以及状态在学习线程之前，我们需要普及一个概念，每一个程序运行都会有一个父进程，我们的线程就是在此父进程中运行，拿Android来说，默认情况下，启动一个程序，所有的组件程序都运行在同一个进程中，并且会创建一个执行线程在该进程中，俗称”主线程”,当我们在该线程中做了耗时的操作造成了程序卡顿，我们就叫“线程阻塞”了,此时就应该另起一个线程来执行耗时操作。 要了解线程中方法的使用，就得先了解线程的运行状态，线程从创建到执行完毕，一共有6个状态： NEW(线程创建未启动) RUNNABLE(正在执行中的线程) BLOCKED(被阻塞并且在等待监视器锁释放) WAITING(等待被唤醒) TIMED_WAITING(等待或睡眠一定时间被唤醒) TERMINATED（线程终止，消亡） 这些状态对应Thread源码中的State枚举，通过getState()方法可以获取该线程的运行状态 其中BLOCKED表示等待监视器锁的过程，那么什么是监视器锁呢，监视器锁是为了解决线程不安全而诞生的方法，当多个进程同时操作一个数据结构并修改时，这时数据结构是不确定的，我们称之为“线程不安全”,于是我们使用synchronized(同步锁)和lock锁等机制来解决这种线程不安全，套上此锁，当前有且只有一个线程能修改此数据结构，其他的线程则需要等待，这就保证了数据结构的一致性，而其他线程会进入等待的状态，也就是我们的BLOCKED状态。synchronized使用示例： 123456789class MyThread extends Thread &#123; @Override public void run() &#123; synchronized (this) &#123; //这里写修改数据源的代码 &#125; &#125;&#125; lock使用示例：12345678910class MyThread extends Thread &#123; private final ReentrantLock lock = new ReentrantLock (); @Override public void run() &#123; lock.lock(); //这里写修改数据源的代码 lock.unlock(); &#125;&#125; 当然这两者的应用不仅仅是在线程中，在必要的方法调用上也可使用 线程的源码以及方法使用Thread源码：1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Thread implements Runnable &#123; ........... /* Some of these are accessed directly by the VM; do not rename them. */ private volatile long nativePeer; volatile ThreadGroup group; volatile boolean daemon; volatile String name; volatile int priority; volatile long stackSize; Runnable target; private static int count = 0; private long threadInitNumber ; /** * Normal thread local values. */ ThreadLocal.Values localValues; /** * Inheritable thread local values. */ ThreadLocal.Values inheritableValues; /** Callbacks to run on interruption. */ private final List&lt;Runnable&gt; interruptActions = new ArrayList&lt;Runnable&gt;(); /** * Holds the class loader for this Thread, in case there is one. */ private ClassLoader contextClassLoader; /** * Holds the handler for uncaught exceptions in this Thread, * in case there is one. */ private UncaughtExceptionHandler uncaughtHandler; /** * Holds the default handler for uncaught exceptions, in case there is one. */ private static UncaughtExceptionHandler defaultUncaughtHandler; .....&#125; Thread实现了Runnable接口，并声明了一些线程常用的一些变量: group线程组，线程组包含其他的线程组，形成了一个树结构，除了初始的线程组外，其他的线程组都会有个父进程，其中线程能访问当前线程组的信息，但不能访问父线程组的信息 daemon是否是守护线程，啥是守护线程呢，守护线程是依赖于创建它的线程的一种线程，与普通线程的区别是当创建它的线程关闭了那它也会关闭，而普通线程不会，像我们的垃圾收集器线程就是一个守护线程 threadInitNumber 当前线程的标识符，它是按照线程的创建顺序来叠加的 name 线程的名称，未指定的话就以&quot;Thread-&quot; + threadInitNumber的逻辑命名 priority线程优先级，有三个状态MIN_PRIORITY,NORM_PRIORITY,MAX_PRIORITY,分别对应低，中，高 stackSize 堆栈大小 target 当前的目标线程 contextClassLoader 类加载器，用于保存该线程的信息，断点续传等功能可以用到 uncaughtHandler线程未捕获异常调用类，如果没有对其进行设置，将会默认使用defaultUncaughtHandler来处理异常，由于我们的主线程也是一个Thread,所以我们可以通过实现UncaughtExceptionHandler接口并调用Thread.setDefaultUncaughtExceptionHandler（）方法将我们自定义的异常捕获类设置给Thread,这样我们就可以捕获全局的异常 了解了一些常用变量后，我们再来看一下其中的一些常用方法: start()方法用于启动一个线程，只有调用此方法，系统才会新开启一个线程并分配给其必要的资源。我们看一下Thread的构造方法，发现最终都是调用了init方法，里面也只是对基本变量进行初始化，并没有分配到任何的资源：1234567891011121314151617181920private void init(ThreadGroup g, Runnable target, String name, long stackSize) &#123; Thread parent = currentThread(); if (g == null) &#123; g = parent.getThreadGroup(); &#125; g.addUnstarted(); this.group = g; this.target = target; this.priority = parent.getPriority(); this.daemon = parent.isDaemon(); setName(name); init2(parent); /* Stash the specified stack size in case the VM cares */ this.stackSize = stackSize; tid = nextThreadID();&#125; 所以，新建一个线程不会消耗资源，只有当star后才会去分配必要的资源，此时线程状态由NEW变为了RUNNABLE run()方法此方法用于处理线程中执行的逻辑，如果继承Thread类则必须重写该方法 sleep()方法12sleep(long millis) //参数为毫秒sleep(long millis,int nanoseconds) //第一参数为毫秒，第二个参数为纳秒 让线程休眠一段时间，相当于让线程进入阻塞状态。注意即使线程休眠了其锁机制依旧生效，其他的线程依旧不能访问其被锁的数据结构，直到其释放对象锁，此时线程状态由RUNNABLE进入TIMED_WAITING yield()方法让当前线程交出相应的权限，为其他线程让步，这是防止CPU过度使用的一种有效手段。效果与sleep差不多，但不能指定具体的时间，并且并不是让线程进入到阻塞状态，而是进入就绪状态.此时线程状态由RUNNABLE进入WAITING join()方法123join()join(long millis) //参数为毫秒join(long millis,int nanoseconds) //第一参数为毫秒，第二个参数为纳秒 此方法是让线程优先来执行，其余的线程会暂停，直到此线程执行完毕才会继续执行。你可以将线程看成一些正常行驶的车辆(在线程队列中)，当给其中一辆车使用了join(弯道超车),那其余的车会给其让行（线程进入暂停状态），优先让它行驶(join的线程运行)，直到它到达终点(运行完成)，才会继续行驶（继续执行）而join源码中是调用的wait()方法，而wait()方法能使线程进入阻塞状态并释放对象锁，所以join方法也是能释放对象锁的 interrupt（）方法中断线程，我们知道，线程执行完run方法里的逻辑就会进入终止状态。调用此方法会使一个阻塞的线程抛出InterruptedException异常，从而终止线程，可以调用isInterrupted()判断是否终止了线程，但非阻塞线程如何中断呢，请看：1234567891011121314class MyThread extends Thread&#123; private volatile boolean isStop = false; @Override public void run() &#123; int i = 0; while(!isStop)&#123; i++; &#125; &#125; public void setStop(boolean stop)&#123; this.isStop = stop; &#125; &#125; 我们可以设置一个变量来控制是否执行完毕，从而结束线程，此时线程状态进入TERMINATED状态]]></content>
      <categories>
        <category>多线程编程</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓小白之ndk编译打包成so供第三方调用]]></title>
    <url>%2Fndkbuildproject.html</url>
    <content type="text"><![CDATA[版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起. 本文接着上篇文章内容来,主要讲述如何生成so库以及将类编译成jar包供第三方调用安卓小白之ndk入门篇 配置在build.gradle中1234567externalNativeBuild &#123; cmake &#123; cppFlags &quot;&quot; //在这里指定需要生成什么类型的so abiFilters &quot;armeabi&quot;,&quot;armeabi-v7a&quot; &#125;&#125; 在CMakeList文件中可以指定生成的so库的名称12345678910111213141516add_library( # Sets the name of the library. native-lib #修改此处 # Sets the library as a shared library. SHARED # Provides a relative path to your source file(s). src/main/cpp/native-lib.cpp).....target_link_libraries( # Specifies the target library. native-lib #修改此处 # Links the target library to the log library # included in the NDK. $&#123;log-lib&#125;) 注意add_library的名称和target_link_libraries的名称必须相同还有另外一种配置12345678defaultConfig&#123; ndk&#123; //指定生成的so库名称 moduleName &quot;native&quot; //在这里指定需要生成什么类型的so abiFilters &quot;armeabi&quot;,&quot;armeabi-v7a&quot; &#125;&#125; 可以直接在gradle中都配置好，不需要更改CMakeList 配置好后，点击Build-&gt;Make Project等待编译完成,如果你是通过第一种方法配置的，那么生成的so库位于app-&gt;build-&gt;intermediates-&gt;cmake-&gt;debug-&gt;obj目录下，如果是第二种方法，那么so库位于app-&gt;build-&gt;intermediates-&gt;ndk-&gt;debug-&gt;obj目录下。 生成jar包看cpp文件里的方法就知道，方法声明都是与包名绑定的，那我要是给第三方app调用呢，总不能让它们用我们的包名吧，所以，我们就需要将我们的类都打成jar包供第三方间接调用，让第三方调用我们的类，我们的类来调用c代码，这样问题就解决啦。 1.要编译jar包，前提条件是你的这个项目必须是一个类库，也就是library,在app gradle的最上面查看是否为apply plugin: &#39;com.android.library&#39; 2.在build defaultConfig目录里加入以下代码:123456789101112131415task makeJar(type: Copy) &#123; //删除存在的 delete &apos;build/libs/jar.jar&apos; //设置拷贝的文件 from(&apos;build/intermediates/bundles/debug/&apos;) //打进jar包后的文件目录 into(&apos;build/libs/&apos;) //将classes.jar放入build/libs/目录下 //include ,exclude参数来设置过滤 //（我们只关心classes.jar这个文件） include(&apos;classes.jar&apos;) //重命名 rename (&apos;classes.jar&apos;, &apos;jar.jar&apos;) &#125; makeJar.dependsOn(build) 看注释，名字任意取，然后再Terminal中执行命令gradlew makeJar, Terminal在AndroidStudio的左下角。执行完，提示BUILD SUCCESSFUL后，在以下路径可以找到生成的jar包：app/build/intermediates/bundles/debug/ 调用jar包和so库都生成好后，就可以使用了，将jar包放入app-&gt;libs目录，将so库放入app-&gt;src-&gt;main-&gt;jinLibs根据你的需要在jinLibs中建立不同的cpu架构目录，一般创建一个armeabi和armeabi-v7a就可以了，注意不要写错，同时注意在gradle中申明你需要的架构类型1234ndk&#123; //在这里指定需要生成什么类型的so abiFilters &quot;armeabi&quot;,&quot;armeabi-v7a&quot; &#125; 都配置好后，重新Sync Project下项目，就能愉快的使用了。 在使用中，有同学经常会遇到so库文件找不到的问题，这时你就需要检查你的架构目录下的so的数量是不是相同的，千万不要出现单个目录没有的情况。这是因为so库都是向下兼容，假如一台v7架构的手机，你把两个需要使用的so库都放到armeabi目录中，没问题，因为系统在v7中找不到会去armeabi目录找。但是如果你将一个so放到armeabi和armeabi-v7a，另一个只放了到了armeabi，当一个v7架构的手机使用的时候，如果发现armeabi-v7中没有是不会去armeabi中找的，因为另一个so也放到了armeabi-v7目录下，代表你兼容了armeabi-v7的情况，此时是不会向下兼容的。所以，解决方案就是要么删除v7里的so,要么把缺少的so补齐。]]></content>
  </entry>
  <entry>
    <title><![CDATA[安卓小白之ndk入门篇]]></title>
    <url>%2Fandroidndkstudyfirst.html</url>
    <content type="text"><![CDATA[版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起. 本文是本人总结ndk的一个入门篇，希望对学习ndk的同学有所帮助哦 1.环境搭建开发工具：AndroidStudio打开AndroidStudio，进入settings,找到Android SDK目录，点击SDK tools，分别找到如图三个配置，勾上，下载。分别介绍一下： cmake类似于Android studio中的gradle,是对ndk的一个配置管理 LLDBc/c++的一个调试工具，安装后可以对c/c++代码进行debug NDKndk的开发工具包 安装完成后，新建一个工程，注意勾选下方的include c++ support,一路next，直到项目构建完成，这样，我们的整体的ndk项目开发环境就配置好了。 2.配置文件介绍项目构建完毕后，我们会发现多了配置和文件，如图： 先介绍一下这几个参数的作用：点开CMakeLists.txt，如下所示：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# For more information about using CMake with Android Studio, read the# documentation: https://d.android.com/studio/projects/add-native-code.html# Sets the minimum version of CMake required to build the native library.cmake_minimum_required(VERSION 3.4.1)# Creates and names a library, sets it as either STATIC# or SHARED, and provides the relative paths to its source code.# You can define multiple libraries, and CMake builds them for you.# Gradle automatically packages shared libraries with your APK.# 配置so库信息add_library( # Sets the name of the library. # 生成的so库名称，此处生成的so文件名称是libnative-lib.so native-lib # Sets the library as a shared library. # STATIC：静态库，是目标文件的归档文件，在链接其它目标的时候使用 # SHARED：动态库，会被动态链接，在运行时被加载 # MODULE：模块库，是不会被链接到其它目标中的插件，但是可能会在运行时使用dlopen-系列的函数动态链接 SHARED # Provides a relative path to your source file(s). # 资源文件，可以多个， # 资源路径是相对路径，相对于本CMakeLists.txt所在目录 src/main/cpp/native-lib.cpp )# Searches for a specified prebuilt library and stores the path as a# variable. Because CMake includes system libraries in the search path by# default, you only need to specify the name of the public NDK library# you want to add. CMake verifies that the library exists before# completing its build.# 从系统查找依赖库find_library( # Sets the name of the path variable. # android系统每个类型的库会存放一个特定的位置，而log库存放在log-lib中 log-lib # Specifies the name of the NDK library that # you want CMake to locate. # android系统在c环境下打log到logcat的库 log )# Specifies libraries CMake should link to your target library. You# can link multiple libraries, such as libraries you define in this# build script, prebuilt third-party libraries, or system libraries.# 配置库的链接（依赖关系）target_link_libraries( # Specifies the target library. # 目标库 native-lib # Links the target library to the log library # included in the NDK. # 依赖于 $&#123;log-lib&#125; ) 看注释就能明白每个方法参数代表什么意思了，如果你觉得里面注释太多，看起来不是很顺眼，可以下载CMake simple highligher插件来提高代码亮度关于cmake的配置还有许多，这里只是先简单介绍一个。我们再来看一下build.gradle中的配置方法的作用,在defultConfig中有个这个参数，123456externalNativeBuild &#123; cmake &#123; cppFlags &quot;&quot; abiFilters &apos;armeabi&apos;,&apos;arm64-v8a&apos;, &apos;armeabi-v7a&apos;, &apos;x86&apos;, &apos;x86_64&apos; &#125; &#125; 我们主要关注 abiFilters，它是用来设置编译生成什么类型的so的，我们的cup架构主要有以下几种: armeabi armeabi-v7a arm64-v8a x86 x86_64 mips mips_64其中，armeabi-v7a是目前大部分手机的主流架构，它是基于armeabi的一种升级架构，因此，它们是互相兼容的，但目前各手机厂商的旗舰级，都已经开始采用arm64-v8a的cpu,不过不要慌，它也是兼容armeabi的，所以，如果我们只需要开发普通应用的话，我们只需要关注armeabi和armeabi-v7a就可以了，而像x86等这种类型的架构多用于平板等设备，因此我们只需要了解即可。与此相同的还有一个配置：123ndk&#123; abiFilters &quot;armeabi&quot;,&quot;armeabi-v7a&quot; &#125; 它也是用来配置需要什么类型的so的，但它是负责打包到apk里有什么类型的so,而不是编译出什么so,两者还是有区别的。例如我在cmake里设置一个 “armeabi”,”armeabi-v7a”，在ndk里设置一个armeabi，我make project一下，它会生成两个cpu类型的so,但是我运行打包apk，在apk的lib目录里就只有一个armeabi的so了，所以：当我们不需要编译so库时，例如引用的第三方库，可以使用ndk来过滤，完全不需要cmake接下来说一下android下的方法：12345externalNativeBuild &#123; cmake &#123; path &quot;CMakeLists.txt&quot; &#125; &#125; 其实很显然，它就是指定我们的CMakeLists文件路径的，当然我们的这个路径是可以更改的。这里教大家一个小技巧，在cmd中执行：adb shell cat /proc/cpuinfo可以查看当前手机的cpu架构哦，效果图如下：CPU architecture: 8说明我的手机是arm64-v8a架构 接下来我们来看cpp文件，这个文件是干嘛的呢，它是c里.h文件的实现的源文件，你可以把它看作是与java交互的桥梁，里面包含了java层需要调用到的函数方法，点开可以看到以下函数：12345678910#include &lt;jni.h&gt;#include &lt;string&gt;extern &quot;C&quot; JNIEXPORT jstring JNICALLJava_com_jie_ndkdemo_MainActivity_stringFromJNI( JNIEnv *env, jobject /* this */) &#123; std::string hello = &quot;Hello from C++&quot;; return env-&gt;NewStringUTF(hello.c_str());&#125; 主要是看这个函数：Java_com_jie_ndkdemo_MainActivity_stringFromJNI,它是有格式要求的，由Java包名类名_函数名组成，定义的时候一定要按照这个格式来，其中，MainActivity是我声明native方法的类的类名。]]></content>
      <categories>
        <category>ndk</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin高阶函数使用(二)]]></title>
    <url>%2Fkotlin-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8.html</url>
    <content type="text"><![CDATA[版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起. 上一篇文章带大家认识到了什么是高阶函数，那这一章就带大家看看高阶函数的实际使用场景吧 提问我们想一想，高阶函数带给我们的是什么，我们为什么要使用它呢？因为他可以让我们的方法更简单高效，能去掉冗余的样板代码，让我们关注的逻辑更清晰的展现在我们的面前，所以高阶函数一定是用在我们的方法实现上，而官方api其实已经将我们常用的快捷操作用高阶函数给封装好了，比如with,apply等操作符，所以剩下的就是接口调用了。 不知道大家用Kotlin实现过OnClickListener接口没有，有3种写法： 青铜版:12345view.setOnClickListener(object :View.OnClickListener&#123; override fun onClick(v: View?) &#123; //啊！我被点击了 &#125; &#125;) 黄金版12345view.setOnClickListener &#123; v -&gt; &#123; //啊！我被点击了 &#125; &#125; 钻石版123view.setOnClickListener &#123; //啊！我被点击了 &#125; 我们一对比发现，代码是一步一步被省略的，首先是省略了接口声明(转化为了lambda)，其次是省略了lambda的花括号(Kotlin的特性，当参数只有一个lambda参数的时候，括号可以省略),所以我们要实现的是如何将接口声明转化为lambda,哈哈，这不正是我们高阶函数所擅长的吗 实现虽然我们不能直接看到kotlin内部的高阶函数的实现方式，但是我们按住ctrl键将鼠标移到方法上是可以看到高阶函数的声明方式的，如你所见是这样的：1public final fun setOnClickListener( l: ((v: View!) → Unit)! ): Unit 看过我上篇文章的一眼就能看明白，这是声明了一个以view为参数的无返回值的高阶函数，但他是如何实现的呢，请看以下代码：12345678public final fun setOnClickListener( l: ((v: View!) → Unit)! ): Unit&#123; //将接口实现并赋值给全局变量接口方便接口方法调用 mOnClickListener = object :View.OnClickListener&#123; override fun onClick(v: View?) &#123; l.invoke(v) //关键是这句 &#125; &#125;&#125; 原理就是内部将接口给实例化，然后将逻辑通过invoke方法代理出去，这样我们点击事件内部就会走invoke方法啦。而invoke实际是一个接口(翻译成java代码你就明白啦),所以我们在方法外面实现的其实是invoke的接口实现逻辑，注意，这种接口的实现方式只能在接口只有一个方法的时候哦，因为invoke只有一个，哈哈，怎么样，setOnClickListener的处理逻辑小伙伴们明白了吗，举一反三的事情就交给各位勤奋的小伙伴了.]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin高阶函数使用(一)]]></title>
    <url>%2FKotlin-Higher-order-function1.html</url>
    <content type="text"><![CDATA[版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起. 用过Kotlin的同学都知道，那些扩展方法用起来简直不要太爽，那么这些扩展方法是怎么定义实现的呢，本文介绍了Kotlin高阶函数的使用,带你实现自己的超溜扩展方法，并且能让你能看懂扩展方法源码，阅读本文需要有一定的Kotlin基础，请谨慎阅读. 1.定义:什么是高阶函数高阶函数就是以另一个函数作为参数或返回值的函数，Kotlin可以以lambda或参数引用作为参数或返回值，所以，任何以lambda或函数引用作为参数或返回值的都是高阶函数 2.函数类型要使用Kotlin的高阶函数就必须遵循它的函数类型先来看一个简单的例子，这是一个简单的函数类型申明1val sum = &#123; x: Int, y: Int -&gt; x + y &#125; 之所以能这么写得益于Kotlin的类型推导，它的显示写法是这样的：1var sum:(Int,Int)-&gt; Int = &#123;x , y-&gt; x + y&#125; (Int,Int)是参数类型，-&gt;后面的值Int是返回类型,组合在一起就构成了一个函数类型,以上属于有参有返回值类型，下面列举其他几种类型 12var action:() -&gt;Unit = &#123;&#125; //无参无返回值var a = &#123;&#125; //类型推导后的简化写法 1var action:(Int) -&gt;Unit = &#123;&#125; //有参无返回值 1var action:() -&gt; Int = &#123;&#125; //无参有返回值 3.使用高阶函数(将函数类型作为参数)直接看代码12345678910 fun getNumResult(result: (Int, Int) -&gt; Int): Int &#123; return result(1,2) &#125;//调用var value = getNumResult&#123; a, b -&gt; a + b &#125;==&gt; value = 3var value = getNumResult&#123; a, b -&gt; a * b &#125;==&gt; value = 2 依照函数类型所示，a和b对应两个Int类型的参数，这个名称可以任意定义，a+b为返回值，随后return 了一个lambda的返回值，看起来是不是很强大,而且依照Kotlin的特性，当参数只有一个lambda参数的时候，括号可以省略，因此就变成了实例中的那样简洁的调用 像Kotlin中的filter等操作符，都是这样定义实现的，感兴趣的可以研究下 看到这里，可能有同学会问了，Kotlin不是号称与JAVA兼容吗，那再Java中如何调用呢，这就要从Kotlin函数的生成原理说起了，Kotlin的这些函数类型其实会被申明成普通的接口，一个函数类型的参数就会变成Function1的实现，N个函数类型的参数就是FunctionN，这个接口定义了一个invoke方法，调用该方法就会执行函数，So,我们可以这么写: Java8: 因为支持lambda，所以依旧可以这样写1int value = getNumResult(a ,b - &gt;a + b); Java8以下版本1234567int value = getNumResult( new Function2&lt;Integer, Integer, Integer&gt;() &#123; @Override public Integer invoke(Integer a, Integer b) &#123; return a + b; &#125; &#125;); 注意，如果定义的返回值是Unit,例如forEach高阶函数，在Java中就必须显示返回一个Unit对象,因为Unit是一个单例对象，因此可以这样定义返回1return Unit.INSTANCE； 4.使用高阶函数(将函数类型作为返回值)顾名思义，相信同学们把作为参数的高阶函数理解透了这个很好理解，示例如下: 1234567891011121314151617181920212223242526//定义一个类用于装载参数class Num(var num: Int)//此方法的作用是如果type等于1，那么就从Num类中取出num进行乘法操作，如果不等于一，就进行相加操作 fun getNum(type: Int): (Num) -&gt; Int &#123; if (type == 1) &#123; //这是一种写法 return &#123; entity -&gt; entity.num * entity.num &#125; &#125; else &#123; //这是另一种简写，可以用it代替entity参数 return &#123; it.num + it.num &#125; &#125; &#125;使用:var ride = getNum(1) //传递一个1进去代表使用乘法var result = ride(Num(3)) //得到一个以Num作为参数的高阶函数==&gt; result = 9var sum = getNum(2)var result = sum(Num(3))==&gt; result = 6]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gitlab加jitpack搭建免费私有依赖库]]></title>
    <url>%2Fgitlabab-jitpack%E7%A7%81%E6%9C%89%E4%BE%9D%E8%B5%96%E5%BA%93%E6%90%AD%E5%BB%BA.html</url>
    <content type="text"><![CDATA[版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起. 一直想为公司项目搭建一个依赖库，可以直接像引入第三方开源项目一样去引用它，方便集成到其他的项目中去，趁着这个周末将几大依赖库平台都研究了一番，顺便做一个总结 选择托管平台 搭建公司依赖库的前提是项目非公开，必须能托管私有项目，同时需要免费，对比现在比较火的只有两个： gitlab GitLab 是一个用于仓库管理系统的开源项目，使用Git作为代码管理工具，并在此基础上搭建起来的web服务。安装方法是参考GitLab在GitHub上的Wiki页面。 Coding 有人说Coding就是中国的github,但从最近的产品演变方向看，coding更想做的是团队代码云端服务，通过它可以云端一键部署代码 两者相比较，虽然Coding是国内产品，上手程度上具有一定的优势，但是产品并没有gitlab发展的成熟，故笔者选择了gitlab来托管私有项目 选择构建工具目前已知有以下平台供选择： Bintray优点：响应快，结构清晰，当部署出错能迅速打印log，分析错误原因缺点: 需要翻墙，配置稍显复杂 配置可参考:发布 Android Library 到 JCenter 从入门到放弃 jitpack优点: 配置简单,支持度广泛缺点: 管理平台较简单 使用Nexus Repository Manager OSS 3.x来搭建私有maven服务优点:较为开放，完全本地服务器运行缺点：需要对gradle进行复杂的配置,需要本地服务器 综合考虑，决定用jitpack来搭建 准备工作 注册一个gitlab账号 注册一个jitpack账号 在gitlab中创建一个私有项目,并生成一个Access Tokens(Setting-&gt;Access Tokens),如果是管理者把权限全部勾上，Expires at不需要填，点击生成记下密钥(我比较懒就不放示例图了) 进入jitpack的设置界面（点击用户名可进入）,看到GitLab一栏，将此令牌输入 回到jitpack首页左边Repositories里应该就可以看到我们先前创建的私有项目了 上传library包 创建一个项目，添加一个library包 在此library的gradle里加入 12apply plugin: 'com.github.dcendents.android-maven'group='com.gitlab.UserName' 其中UserName是你的用户名 3 在根目录的gradle中加入123dependencies&#123; classpath 'com.github.dcendents:android-maven-gradle-plugin:2.0'&#125; 注意看你的gradle版本，如果是4.1+就使用2.0，如果是4.4+就使用2.1配置完毕，使用git提交到gitlab,怎么提交不需要我说了吧，就是平常提交代码到github上一样 4 版本控制 提交成功后可以在gitlab中生成一个tag，tag的名称就是你在项目中引用的名称 5 刷新jitpack, 项目结构如图: 点击Get it即可获取你的配置地址了，复制它 项目中使用直接在项目的build.gradle中贴上这个地址，build………… 咦，怎么失败了，别急，这是因为权限问题造成的。由于我们在gitlab上创建的是私有项目，所以我们需要在项目中配置一下令牌:打开项目的gradle.properties,加上authToken=你的令牌地址,随后在项目根目录加上12345678allprojects &#123; repositories &#123; ........ maven &#123; url 'https://jitpack.io' credentials &#123; username authToken &#125; &#125; &#125;&#125; 重新rebuild一下，编译成功，试试在项目中使用library中的代码，大功告成，怎么样，配置是不是超级简单]]></content>
      <categories>
        <category>安卓杂记</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin系列学习资料整理]]></title>
    <url>%2FKotlin%E7%B3%BB%E5%88%97-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95.html</url>
    <content type="text"><![CDATA[版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起. 时至今日,Kotlin在Android开发中越来越受欢迎,它的高效性，简介性,以及更高的容错率不禁让我感叹:一入Kotlin深似海，从此Java是路人，入了Kotlin的门，保证让你回不去,哈哈哈，还等什么,快来和我一起学习Kotlin把 前言网上Kotlin的资料很多，我也不重复造‘资料’了，跟着我的资料索引来，一步一步的学习，相信你很快就能熟练使用了 官网教程Kotlin开源地址 Kotlin中文文档此文档应仔细熟读三遍，确保每一章节都有一个大概的印象，方便以后翻阅，同时这也是最重要的资料,应保存到书签.读语法是应该联想一下使用java会如何实现，思考一下Kotlin的好处，下次遇见此场景就会联想到需要使用这个Api来编写代码了. 视频教程 练习熟悉了文档后就可以去Kotlin官网去在线练习一下语法啦，用来巩固你的知识点。地址:Hello,Kotlin可以点击Kotlin Koans来做上面的练习题，让你实践各种Api的使用 参考代码当你使用Kotlin得心应手之后,就可以参考一下别人是怎么使用Kotlin来编写代码的，这里列举几个可参考的开源项目 基于Kotlin+MVP+Retrofit+RxJava+Glide 等架构实现的短视频类的APP练手项目，UI 简约风格，代码详细注释 Kotlin for Android Developers (the book)国外某Kotlin书籍中的示例代码.. 仿开眼视频 使用干货集中营Api实现的App Kotlin的MVP示例 结束最后说下通过书籍的阅读可以让你的知识点更成体系,推荐Kotlin实战这本书，内容不错,推荐]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓高级布局-flexboxLayout：最聪明的布局]]></title>
    <url>%2F%E5%AE%89%E5%8D%93%E9%AB%98%E7%BA%A7%E5%B8%83%E5%B1%80-flexboxLayout-%E6%9C%80%E8%81%AA%E6%98%8E%E7%9A%84%E5%B8%83%E5%B1%80.html</url>
    <content type="text"><![CDATA[版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起. ps:最近由于连接外接硬盘的数据线落朋友家了，而我hexo文档都存在外接硬盘上了，导致许久都没写文章啦，还别说，手还有点痒，以后还是尽量保持每周一更 前言今天给大家介绍的是谷歌开源的新的一种布局，如果用css写过flexbox布局的朋友一定不会陌生,没错，FlexboxLayout可以说是Android版的flexbox布局，它的作用是可以让子布局轻松填充父布局，并且可以对子布局进行排序，设置可以让子布局自动‘换行’,它还能够指定子布局的排列方向,相当于一个加强版的LinearLayout，怎么样，你是不是迫不及待想试试了？ 使用FlexboxLayout开源地址：https://github.com/google/flexbox-layout 在build.gradle中添加：123dependencies &#123; implementation 'com.google.android:flexbox:0.3.2'&#125; 在xml中使用：12345678910111213141516171819202122232425262728293031323334&lt;com.google.android.flexbox.FlexboxLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;TextView android:layout_width="100dp" android:layout_height="20dp" android:background="#43eeff" android:gravity="center" android:text="1" /&gt; &lt;TextView android:layout_width="100dp" android:layout_height="20dp" android:background="#ef3344" android:gravity="center" android:text="2" /&gt; &lt;TextView android:layout_width="100dp" android:layout_height="20dp" android:background="#ee998f" android:gravity="center" android:text="3" /&gt; &lt;TextView android:layout_width="100dp" android:layout_height="50dp" android:background="#eeff22" android:gravity="center" android:text="4" /&gt;&lt;/com.google.android.flexbox.FlexboxLayout&gt; 我们什么属性都不加,可以看到效果是这样的： 咦，好像并没有换行，别急，这其实是flexboxLayout默认属性的一个效果，下面我们就来学习它的一些常用属性吧： flexDirectionflexDirection属性决定子布局的排列方向。类似LinearLayout 的 orientation属性，不过,flexboxLayout的属性更加强大,它除了决定子布局的排列方向,还可以决定子布局的起点位置： row（默认值）：子布局为水平方向，起点在左端 row_reverse：子布局为水平方向，起点在右端。 column：子布局为垂直方向，起点在上沿 column_reverse：子布局为垂直方向，起点在下沿 使用column_reverse效果如下所示： flexWrapflexWrap是一个非常有用的属性，它可以让控件自动换行, nowrap （默认）：不换行 wrap：按正方向换行 wrap_reverse：按反方向换行 使用wrap属性效果如下所示： justifyContentjustifyContent定义了子控件的对齐方式，把它看成gravity属性，子控件为一个整体就好理解了，属性如下： flex_start(默认):左对齐 flex_end：右对齐 center：居中 space_between：两端对齐，每个子控件之间的距离相等 space_around：每个子控件的两侧相等,项目之间的间隔比项目与边框的间隔大一倍。 如下是设置了space_around的效果： alignItemsalignltems用于设置子布局的对齐方式,属性如下： flex-start：顶端对齐。：第一行内容的的基线对齐。 flex_end：底部对齐。 stretch （默认）：如果item没有设置高度，则充满容器高度。 center：居中对齐 baseline：第一行内容的基线对齐。 这也是为什么我们一开始什么也不设置子布局会填充父布局的原因。这里还说下baseline属性，用过TextView一定对基线不会陌生,如果子控件有文字，基线对齐可以保证文字对齐而不必理会包裹它的控件是怎样的。观看下图可以有助于理解： alignContentalignContent可以控制多行的对齐方式，如果子布局只有一行则不起作用，属性如下： stretch （默认值）：充满交叉轴的高度（测试发现，需要alignItems 的值也为stretch 才有效）。 flex_start：与交叉轴的起点对齐。 flex_end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space_between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space_around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 子布局属性子布局也有非常给力的属性,父与子布局的结合使得排版非常灵活 layout_flexBasisPercentayout_flexBasisPercent的值为一个百分比，表示设置子元素的长度为它父容器长度的百分比,默认值是auto,即元素本来的大小。如图，我设置每个子布局的宽度一样，第一个子布局我设置50%的百分比，效果如图： layout_orderlayout_order属性用于给子布局排序，默认是按照从上到下依次排列的，如果加入该值，值越小位置就会越靠前 layout_flexGrowlayout_flexGrow用于定义子布局的放大比例，其实就是LinearLayout的weight属性，相信这个不用过多介绍吧 layout_flexShrinklayout_flexShrink定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。如果所有项目的 layout_flexShrink 属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。 layout_alignSelflayout_alignSelf属性允许单个子元素有与其他子元素不一样的对齐方式，可覆盖 alignItems 属性。默认值为auto，表示继承父元素的alignItems 属性，如果没有父元素，则等同于stretch。属性作用同alignItems一样。 flexboxLayout大部分常用的属性就介绍到这里，此布局可以轻松完成类似添加tag便签的布局样式，也可以把它当成百分比布局来用，甚至可以与RecyclerView搭配完成图片流效果，因此熟练掌握这个布局还是有必要的，跟着文章的讲解多敲敲代码，相信你很快就会上手的。]]></content>
      <categories>
        <category>Android基础进阶</category>
        <category>安卓控件</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[记一次重构项目心得]]></title>
    <url>%2Frefactoring-project-learned.html</url>
    <content type="text"><![CDATA[版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起. 这次花时间重构了下一年前的自定义键盘项目,收获了许多，忍不住想写出来分享一下,项目地址EasyKeyBoardView,该库旨在帮助开发者更快的实现自定义键盘，无需关注键盘自身的实现逻辑，详细用法见README.md 如何重构项目对于一个开源项目来说，首先要弄清楚它的意义在哪里，它的目的在哪里，俗话说，程序员都是懒惰的，为了偷懒，程序员创造了越来越方便的工具来帮自己偷懒，这就是一种进步。 基于此，我分析了下自定义键盘的使用场景，发现键盘的使用逻辑是差不多的，无非是UI及一些功能点上的不同，但终究是一个键盘，输入功能是刚需，所以简化输入功能就是这个库的意义所在了。 而这次我发现，一款优质的开源项目必须要有高度的扩展性，应此将功能模块化是我此次学习到的重要技能，每一个类都有着它自己的功能，然后再将这些类组装起来就变成了一台灵活运作的机器。而其中那些点可对外修改，那些不能，这都需要自己判断的。 学习到的技能更快的配置：上传项目到JitPack相比于jcenter,我发现JitPack可谓是神器，1分钟就可实现代码上传，强烈推荐，使用方法如下：首先进入它的github地址:jitpack.io,找到它的最新版插件版本，在要上传的项目的root build.gradle中添加插件，大概长这样：123456dependencies &#123; classpath 'com.android.tools.build:gradle:3.0.0' classpath 'com.github.dcendents:android-maven-gradle-plugin:2.0' // 这是截至目前最新版的插件 // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files &#125; 然后在你要上传的library包中的build.gradle文件中添加：12apply plugin: 'com.github.dcendents.android-maven'group='com.github.Jay-huangjie' //这里写你自己的github名字，别写我的啊 重新编译一下，然后将代码上传到github,上传成功后进入项目主页，点击releases创建一个版本，releases或tag都行，如图： 创建好后进入jitPack官网：https://jitpack.io/;在输入框中输入你的项目地址，例如我的项目地址就是https://github.com/Jay-huangjie/EasyKeyBoardView,得到如图所示的信息：点击Get it按钮即可获取你的地址啦，并且，通过此地址下载的是你的library包而不是整个项目，所以你可以将库的demo也一起上传到github上，是不是非常的方便简单呢]]></content>
      <categories>
        <category>安卓杂记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[okhttp3Wiki文档译文]]></title>
    <url>%2Fokhttp3-wiki-chinese.html</url>
    <content type="text"><![CDATA[版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起. 本文提供一些okhttp3的文档翻译,英文文档地址:https://github.com/square/okhttp/wiki Calls(调用)HTTP客户端的工作是接受你的请求并产生响应。这在理论上很简单，但在实践中会变得棘手。 Requests每个HTTP请求都包含一个URL，一个方法（如GET或POST）和一个头部列表(headers)。请求也可能包含一个请求体(body)：特定内容类型的数据流。 Responses每一个HTTP响应中都包含一个状态码（如200代表成功，404代表未找​​到），一个响应头列表（headers）和一个可选的响应体（body）。 重写请求当你的OkHttp发送一个HTTP请求，你在描述一个高层次的要求：“给我获取这个网址中的这些请求头。”对于正确性和效率，OkHttp发送前会重写你的请求。 OkHttp可以在原先的请求中添加请求头（headers），包括Content-Length, Transfer-Encoding, User-Agent, Host, Connection, 和 Content-Type。除非请求头已经存在压缩响应，否则它还将添加一个Accept-Encoding请求头。如果你有cookies，OkHttp还将添加一个Cookie请求头。 一些请求会有一个缓存的响应。当这个缓存的响应不是最新的时候，OkHttp会发送一个有条件的GET来下载更新的响应，如果它比缓存还新。它将会添加需要的请求头，如IF-Modified-Since和If-None-Match。 重写响应如果使用透明压缩，OkHttp将删除相应的响应头Content-Encoding，Content-Length因为它们不适用于解压缩的响应主体。 如果条件GET成功，则来自网络和缓存的响应将按照规范的指示进行合并。 后续请求当您请求的URL已经移动时，Web服务器将返回一个响应代码，302以指示文档的新URL。OkHttp将按照重定向来检索最终响应。如果响应发出授权质询，则OkHttp会询问Authenticator（如果已配置）以满足质询。如果认证者提供证书，则请求将会带着证书进行重试。 重试请求有时连接失败：要么是连接池已经过时和断开，或是Web服务器本身无法达成。如果有一个是可用的，OkHttp将会使用不同的路由进行请求重试。 呼叫随着重写，重定向，后续和重试，你简单的要求可能会产生很多请求和响应。OkHttp使用呼叫（Call）并通过许多必要的中间请求和响应来满足你请求的任务模型。通常情况，这是不是很多！如果您的网址被重定向，或者如果您故障转移到另一个IP地址，但它会欣慰的知道你的代码会继续工作。 通过以下两种方式进行呼叫： 同步：直到响应,你的线程块是可读的。 异步：你在任何线程进行排队请求，并且当响应是可读的时候，你会在另一个线程得到回调。 呼叫（Calls）可以在任何线程中取消。如果它尚未完成，它将作为失败的呼叫（Calls）！当呼叫（Call）被取消的时候，如果代码试图进行写请求体（request body）或读取响应体（response body）会遭受IOException异常。 调度对于同步呼叫，您需要自带线程，并负责管理多少个同时发出的请求。同时连接的垃圾资源过多; 太少的危害等待时间。 对于异步调用，Dispatcher实现最大同时请求的策略。您可以设置每个网络服务器的最大数量（默认值是5），总体（默认值是64）。 Connections(连接)虽然您只提供了URL，但是OkHttp计划使用三种类型连接到你的web服务器：URL, Address, 和 Route URLURL（如https://github.com/square/okhttp）是HTTP和Internet的基础。除了作为网络上所有内容的通用分散命名方案之外，他们还指定如何访问网络资源。 网址是抽象的： 他们指定的调用可能是明文（http）或加密（https），但不应该使用哪些加密算法。他们也没有指定如何验证对等方的证书（HostnameVerifier）或哪些证书可以信任（SSLSocketFactory）。他们也是具体的：每个URL标识一个特定的路径（如/square/okhttp）和查询（如?q=sharks&amp;lang=en）。每个网络服务器都有许多网址。 它们不指定是否应该使用特定的代理服务器，或者如何使用该代理服务器进行身份验证。 他们也是具体的：每个URL标识一个特定的路径（如/square/okhttp）和查询（如?q=sharks&amp;lang=en）。每个网络服务器都有许多网址。 Addresses地址指定一个网络服务器（如github.com）以及连接到该服务器所需的所有静态配置：端口号，HTTPS设置和首选网络协议（如HTTP / 2或SPDY）。 共享相同地址的URL也可能共享相同的底层TCP套接字连接。共享连接具有显着的性能优势：更低的延迟，更高的吞吐量（由于TCP启动缓慢）和保存的电池。OkHttp使用ConnectionPool自动重用HTTP / 1.x连接并复用HTTP / 2和SPDY连接。 在OkHttp地址的一些字段来自URL（方案，主机名，端口），其余来自OkHttpClient。 Routes路由提供实际连接到Web服务器所需的动态信息。这是要尝试的特定IP地址（通过DNS查询发现），要使用的确切代理服务器（如果正在使用ProxySelector）以及要协商哪个版本的TLS（用于HTTPS连接）。 单个地址可能有很多路线。例如，托管在多个数据中心中的Web服务器可能会在其DNS响应中产生多个IP地址。 Connections当你用OkHttp请求一个URL的时候，它的功能如下： 它使用URL并配置OkHttpClient来创建一个地址。该地址指定我们将如何连接到Web服务器。它尝试从连接池中检索具有该地址的连接。如果在池中找不到连接，则选择要尝试的路由。这通常意味着发出DNS请求来获取服务器的IP地址。然后根据需要选择TLS版本和代理服务器。如果是新路由，则通过构建直接套接字连接，TLS隧道（用于通过HTTP代理的HTTPS）或直接TLS连接进行连接。它根据需要进行TLS握手。它发送HTTP请求并读取响应。如果连接有问题，OkHttp会选择另外一个路径，然后重试。这允许OkHttp在服务器地址的子集无法访问时恢复。当池连接失效或尝试的TLS版本不受支持时，这也很有用。 一旦接收到响应，连接将被返回到池中，以便将来可以重复使用。经过一段时间的不活动之后，连接被从池中逐出。 Recipes(方法)我们已经写了一些方法，演示了如何解决OkHttp常见问题。通过阅读他们了解一切是如何正常工作的。可以自由剪切和粘贴这些例子。 同步获取(Synchronous Get)下载文件，打印其头部，并以字符串形式打印其响应体。 该string()方法在响应体中是方便快捷的小型文件。但是，如果响应体较大（大于1 MIB以上），它会将整个较大文件加载到内存中，所以应该避免string() 。在这种情况下，更倾向于将响应体作为流进行处理。 123456789101112131415161718private final OkHttpClient client = new OkHttpClient();public void run() throws Exception &#123; Request request = new Request.Builder() .url("https://publicobject.com/helloworld.txt") .build(); try (Response response = client.newCall(request).execute()) &#123; if (!response.isSuccessful()) throw new IOException("Unexpected code " + response); Headers responseHeaders = response.headers(); for (int i = 0; i &lt; responseHeaders.size(); i++) &#123; System.out.println(responseHeaders.name(i) + ": " + responseHeaders.value(i)); &#125; System.out.println(response.body().string()); &#125;&#125; 异步获取(Asynchronous Get)下载一个工作线程的文件，当响应是可读的时候，获取回调（Callback）。当响应头已经准备好后，将产生回调（Callback）。读取响应体可能一直阻塞。目前OkHttp不提供异步API来接收响应体的部位。1234567891011121314151617181920212223242526private final OkHttpClient client = new OkHttpClient(); public void run() throws Exception &#123; Request request = new Request.Builder() .url("http://publicobject.com/helloworld.txt") .build(); client.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; e.printStackTrace(); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; try (ResponseBody responseBody = response.body()) &#123; if (!response.isSuccessful()) throw new IOException("Unexpected code " + response); Headers responseHeaders = response.headers(); for (int i = 0, size = responseHeaders.size(); i &lt; size; i++) &#123; System.out.println(responseHeaders.name(i) + ": " + responseHeaders.value(i)); &#125; System.out.println(responseBody.string()); &#125; &#125; &#125;); &#125; 访问头典型的HTTP头工作就像一个Map ：每个字段都有一个值或无值。但是，一些头部(headers)允许多个值，比如Guava的Multimap。例如，它共同为一个HTTP响应提供多个Vary头。OkHttp的API，试图使这两种情况下都能舒适使用。 当写请求头，用header(name, value)来为唯一出现的name设置value。如果它本身存在值，在添加新的value之前，他们会被移除。使用addHeader(name, value)来添加头部不需要移除当前存在的headers。 当读取响应头，用header(name)返回最后设置name的value。如果没有value，header(name)将返回null。可以使用headers(name)来读取所有列表字段的值，。 要访问所有的头部，用Headers类，它支持索引访问。123456789101112131415161718private final OkHttpClient client = new OkHttpClient();public void run() throws Exception &#123; Request request = new Request.Builder() .url("https://api.github.com/repos/square/okhttp/issues") .header("User-Agent", "OkHttp Headers.java") .addHeader("Accept", "application/json; q=0.5") .addHeader("Accept", "application/vnd.github.v3+json") .build(); try (Response response = client.newCall(request).execute()) &#123; if (!response.isSuccessful()) throw new IOException("Unexpected code " + response); System.out.println("Server: " + response.header("Server")); System.out.println("Date: " + response.header("Date")); System.out.println("Vary: " + response.headers("Vary")); &#125;&#125; 提交一个文本(Posting a String)使用HTTP POST的请求体发送到服务。下面例子post了一个markdown文档到一个的Web服务（将markdown作为HTML）。由于整个请求体是同时在内存中，应避免使用此API发送较大（大于1 MIB）的文件。12345678910111213141516171819202122232425public static final MediaType MEDIA_TYPE_MARKDOWN = MediaType.parse("text/x-markdown; charset=utf-8");private final OkHttpClient client = new OkHttpClient();public void run() throws Exception &#123; String postBody = "" + "Releases\n" + "--------\n" + "\n" + " * _1.0_ May 6, 2013\n" + " * _1.1_ June 15, 2013\n" + " * _1.2_ August 11, 2013\n"; Request request = new Request.Builder() .url("https://api.github.com/markdown/raw") .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, postBody)) .build(); try (Response response = client.newCall(request).execute()) &#123; if (!response.isSuccessful()) throw new IOException("Unexpected code " + response); System.out.println(response.body().string()); &#125;&#125; 发布一个流(Post Streaming)在这里，我们POST请求体作为stream。将正在生成请求体的内容写入到stream中。下面例子streams直接进入Okio缓冲水槽。你的程序可能更喜欢使用OutputStream，你可以通过BufferedSink.outputStream（）获得 OutputStream。123456789101112131415161718192021222324252627282930313233343536373839public static final MediaType MEDIA_TYPE_MARKDOWN = MediaType.parse("text/x-markdown; charset=utf-8");private final OkHttpClient client = new OkHttpClient();public void run() throws Exception &#123; RequestBody requestBody = new RequestBody() &#123; @Override public MediaType contentType() &#123; return MEDIA_TYPE_MARKDOWN; &#125; @Override public void writeTo(BufferedSink sink) throws IOException &#123; sink.writeUtf8("Numbers\n"); sink.writeUtf8("-------\n"); for (int i = 2; i &lt;= 997; i++) &#123; sink.writeUtf8(String.format(" * %s = %s\n", i, factor(i))); &#125; &#125; private String factor(int n) &#123; for (int i = 2; i &lt; n; i++) &#123; int x = n / i; if (x * i == n) return factor(x) + " × " + i; &#125; return Integer.toString(n); &#125; &#125;; Request request = new Request.Builder() .url("https://api.github.com/markdown/raw") .post(requestBody) .build(); try (Response response = client.newCall(request).execute()) &#123; if (!response.isSuccessful()) throw new IOException("Unexpected code " + response); System.out.println(response.body().string()); &#125;&#125; 发布文件(Posting a File)将文件作为请求体是很容易的。12345678910111213141516171819public static final MediaType MEDIA_TYPE_MARKDOWN = MediaType.parse("text/x-markdown; charset=utf-8");private final OkHttpClient client = new OkHttpClient();public void run() throws Exception &#123; File file = new File("README.md"); Request request = new Request.Builder() .url("https://api.github.com/markdown/raw") .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, file)) .build(); try (Response response = client.newCall(request).execute()) &#123; if (!response.isSuccessful()) throw new IOException("Unexpected code " + response); System.out.println(response.body().string()); &#125;&#125; 发布表单(Posting form parameters)使用FormBody.Builder建立一个请求体，它就像一个HTML的&lt;form&gt;标记。Names和values将使用HTML兼容的表单URL编码进行编码。1234567891011121314151617private final OkHttpClient client = new OkHttpClient();public void run() throws Exception &#123; RequestBody formBody = new FormBody.Builder() .add("search", "Jurassic Park") .build(); Request request = new Request.Builder() .url("https://en.wikipedia.org/w/index.php") .post(formBody) .build(); try (Response response = client.newCall(request).execute()) &#123; if (!response.isSuccessful()) throw new IOException("Unexpected code " + response); System.out.println(response.body().string()); &#125;&#125; 发布multipart请求(Posting a multipart request)MultipartBody.Builder可以构建与HTML文件上传表单兼容的复杂请求主体。multipart请求体的每一部分本身就是请求体，并且可以定义自己的头部。如果存在，这些头应该描述的部分请求体，如它的Content-Disposition。如果Content-Length和 Content-Type头部可以使用，则他们会自动添加。123456789101112131415161718192021222324252627282930/** * The imgur client ID for OkHttp recipes. If you're using imgur for anything other than running * these examples, please request your own client ID! https://api.imgur.com/oauth2 */private static final String IMGUR_CLIENT_ID = "...";private static final MediaType MEDIA_TYPE_PNG = MediaType.parse("image/png");private final OkHttpClient client = new OkHttpClient();public void run() throws Exception &#123; // Use the imgur image upload API as documented at https://api.imgur.com/endpoints/image RequestBody requestBody = new MultipartBody.Builder() .setType(MultipartBody.FORM) .addFormDataPart("title", "Square Logo") .addFormDataPart("image", "logo-square.png", RequestBody.create(MEDIA_TYPE_PNG, new File("website/static/logo-square.png"))) .build(); Request request = new Request.Builder() .header("Authorization", "Client-ID " + IMGUR_CLIENT_ID) .url("https://api.imgur.com/3/image") .post(requestBody) .build(); try (Response response = client.newCall(request).execute()) &#123; if (!response.isSuccessful()) throw new IOException("Unexpected code " + response); System.out.println(response.body().string()); &#125;&#125; 用Moshi解析JSON响应Moshi是一个便捷的API，用于在JSON和Java对象之间进行转换。这里我们使用它来解码来自GitHub API的JSON响应。 请注意，ResponseBody.charStream()使用Content-Type响应头来选择解码响应主体时使用哪个字符集。如果没有指定字符集，它默认为UTF-8。123456789101112131415161718192021222324252627private final OkHttpClient client = new OkHttpClient();private final Moshi moshi = new Moshi.Builder().build();private final JsonAdapter&lt;Gist&gt; gistJsonAdapter = moshi.adapter(Gist.class);public void run() throws Exception &#123; Request request = new Request.Builder() .url("https://api.github.com/gists/c2a7c39532239ff261be") .build(); try (Response response = client.newCall(request).execute()) &#123; if (!response.isSuccessful()) throw new IOException("Unexpected code " + response); Gist gist = gistJsonAdapter.fromJson(response.body().source()); for (Map.Entry&lt;String, GistFile&gt; entry : gist.files.entrySet()) &#123; System.out.println(entry.getKey()); System.out.println(entry.getValue().content); &#125; &#125;&#125;static class Gist &#123; Map&lt;String, GistFile&gt; files;&#125;static class GistFile &#123; String content;&#125; 响应缓存要缓存响应，你需要有一个缓存目录来进行读取和写入，并限制缓存的大小。缓存目录应该是私有的，不被信任的应用程序不能够阅读其内容！ 多个缓存同时访问相同的缓存目录，这是错误的。大多数应用程序应该调用一次new OkHttpClient()，在任何地方都使用相同的实例和自己的缓存配置。否则，这两个缓存实例将踩到对方，破坏响应缓存，这可能使你的程序崩溃。 响应缓存使用HTTP头进行配置。您可以添加请求头Cache-Control: max-stale=3600，这样OkHttp的缓存就会遵循他们。你的网络服务器可以通过自己的响应头配置缓存多长时间的响应，如Cache-Control: max-age=9600。有缓存头强制缓存的响应，强制网络响应，或强制使用条件GET验证的网络响应。 1234567891011121314151617181920212223242526272829303132333435363738private final OkHttpClient client;public CacheResponse(File cacheDirectory) throws Exception &#123; int cacheSize = 10 * 1024 * 1024; // 10 MiB Cache cache = new Cache(cacheDirectory, cacheSize); client = new OkHttpClient.Builder() .cache(cache) .build();&#125;public void run() throws Exception &#123; Request request = new Request.Builder() .url("http://publicobject.com/helloworld.txt") .build(); String response1Body; try (Response response1 = client.newCall(request).execute()) &#123; if (!response1.isSuccessful()) throw new IOException("Unexpected code " + response1); response1Body = response1.body().string(); System.out.println("Response 1 response: " + response1); System.out.println("Response 1 cache response: " + response1.cacheResponse()); System.out.println("Response 1 network response: " + response1.networkResponse()); &#125; String response2Body; try (Response response2 = client.newCall(request).execute()) &#123; if (!response2.isSuccessful()) throw new IOException("Unexpected code " + response2); response2Body = response2.body().string(); System.out.println("Response 2 response: " + response2); System.out.println("Response 2 cache response: " + response2.cacheResponse()); System.out.println("Response 2 network response: " + response2.networkResponse()); &#125; System.out.println("Response 2 equals Response 1? " + response1Body.equals(response2Body));&#125; 使用CacheControl.FORCE_NETWORK可以禁止使用缓存的响应。使用CacheControl.FORCE_CACHE可以禁止使用网络。警告：如果您使用FORCE_CACHE和响应来自网络，OkHttp将会返回一个504不可满足请求的响应。 取消Call通过Call.cancel()来立即停止正在进行的Call。如果一个线程目前正在写请求或读响应，它还将收到一个IOException异常。当一个Call不需要时，使用取消Call来保护网络; 例如，当用户从应用程序导航离开。同步和异步调用可以被取消。1234567891011121314151617181920212223242526272829private final ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);private final OkHttpClient client = new OkHttpClient();public void run() throws Exception &#123; Request request = new Request.Builder() .url("http://httpbin.org/delay/2") // This URL is served with a 2 second delay. .build(); final long startNanos = System.nanoTime(); final Call call = client.newCall(request); // Schedule a job to cancel the call in 1 second. executor.schedule(new Runnable() &#123; @Override public void run() &#123; System.out.printf("%.2f Canceling call.%n", (System.nanoTime() - startNanos) / 1e9f); call.cancel(); System.out.printf("%.2f Canceled call.%n", (System.nanoTime() - startNanos) / 1e9f); &#125; &#125;, 1, TimeUnit.SECONDS); System.out.printf("%.2f Executing call.%n", (System.nanoTime() - startNanos) / 1e9f); try (Response response = call.execute()) &#123; System.out.printf("%.2f Call was expected to fail, but completed: %s%n", (System.nanoTime() - startNanos) / 1e9f, response); &#125; catch (IOException e) &#123; System.out.printf("%.2f Call failed as expected: %s%n", (System.nanoTime() - startNanos) / 1e9f, e); &#125;&#125; 超时当无法访问查询时，将调用超时失败。超时在网络划分中可以是由于客户端连接问题，服务器可用性的问题，或两者之间的任何东西。OkHttp支持连接，读取和写入超时。12345678910111213141516171819private final OkHttpClient client;public ConfigureTimeouts() throws Exception &#123; client = new OkHttpClient.Builder() .connectTimeout(10, TimeUnit.SECONDS) .writeTimeout(10, TimeUnit.SECONDS) .readTimeout(30, TimeUnit.SECONDS) .build();&#125;public void run() throws Exception &#123; Request request = new Request.Builder() .url("http://httpbin.org/delay/2") // This URL is served with a 2 second delay. .build(); try (Response response = client.newCall(request).execute()) &#123; System.out.println("Response completed: " + response); &#125;&#125; 每个呼叫配置所有的HTTP客户端都在OkHttpClient中配置，这包括代理设置，超时和缓存。当你需要改变单一Call的配置时，调用OkHttpClient.newBuilder()。这将返回共享相同的连接池，调度和配置的原客户端的建造器。在下面的例子中，我们做了500毫秒超时，另外一个3000毫秒超时请求。 123456789101112131415161718192021222324252627private final OkHttpClient client = new OkHttpClient();public void run() throws Exception &#123; Request request = new Request.Builder() .url("http://httpbin.org/delay/1") // This URL is served with a 1 second delay. .build(); // Copy to customize OkHttp for this request. OkHttpClient client1 = client.newBuilder() .readTimeout(500, TimeUnit.MILLISECONDS) .build(); try (Response response = client1.newCall(request).execute()) &#123; System.out.println("Response 1 succeeded: " + response); &#125; catch (IOException e) &#123; System.out.println("Response 1 failed: " + e); &#125; // Copy to customize OkHttp for this request. OkHttpClient client2 = client.newBuilder() .readTimeout(3000, TimeUnit.MILLISECONDS) .build(); try (Response response = client2.newCall(request).execute()) &#123; System.out.println("Response 2 succeeded: " + response); &#125; catch (IOException e) &#123; System.out.println("Response 2 failed: " + e); &#125;&#125; 认证处理OkHttp能够自动重试未经授权的请求。当响应是401 Not Authorized，一个Authenticator被要求提供凭据。应该建立一个包含缺少凭据的新要求。如果没有凭证可用，则返回null跳过重试。 使用Response.challenges（）获得任何认证挑战方案和领域。当完成一个基本的挑战，用Credentials.basic(username, password)编码请求头。1234567891011121314151617181920212223242526272829303132private final OkHttpClient client;public Authenticate() &#123; client = new OkHttpClient.Builder() .authenticator(new Authenticator() &#123; @Override public Request authenticate(Route route, Response response) throws IOException &#123; if (response.request().header("Authorization") != null) &#123; return null; // Give up, we've already attempted to authenticate. &#125; System.out.println("Authenticating for response: " + response); System.out.println("Challenges: " + response.challenges()); String credential = Credentials.basic("jesse", "password1"); return response.request().newBuilder() .header("Authorization", credential) .build(); &#125; &#125;) .build();&#125;public void run() throws Exception &#123; Request request = new Request.Builder() .url("http://publicobject.com/secrets/hellosecret.txt") .build(); try (Response response = client.newCall(request).execute()) &#123; if (!response.isSuccessful()) throw new IOException("Unexpected code " + response); System.out.println(response.body().string()); &#125;&#125; 为了避免验证时不工作的重试，你可以返回null放弃。例如，当这些确切的凭据已经尝试,您可以跳过重试：123if (credential.equals(response.request().header("Authorization"))) &#123; return null; // 如果我们已经使用这些凭据失败，不重试 &#125; 当你的应用尝试的次数超过了限制的次数时，你可以跳过重试：123if (responseCount(response) &gt;= 3) &#123; return null; //如果我们已经失败了3次，放弃。 . &#125; 这上面的代码依赖于下面的responseCount()方法：1234567private int responseCount(Response response) &#123; int result = 1; while ((response = response.priorResponse()) != null) &#123; result++; &#125; return result; &#125; Interceptors(拦截器)拦截器是一个强大的机制，它可以监控，重写和重试Calls。下面是一个简单记录传出请求和响应传入的拦截器。1234567891011121314151617class LoggingInterceptor implements Interceptor &#123; @Override public Response intercept(Interceptor.Chain chain) throws IOException &#123; Request request = chain.request(); long t1 = System.nanoTime(); logger.info(String.format("Sending request %s on %s%n%s", request.url(), chain.connection(), request.headers())); Response response = chain.proceed(request); long t2 = System.nanoTime(); logger.info(String.format("Received response for %s in %.1fms%n%s", response.request().url(), (t2 - t1) / 1e6d, response.headers())); return response; &#125;&#125; 调用chain.proceed(request)是每个拦截器实现的关键部分。这个看起来很简单的方法就是所有HTTP工作发生的地方，产生满足请求的响应。 拦截器可以被链接。假设你有一个压缩拦截器和一个校验和拦截器：你需要决定数据是压缩的，然后进行校验和，或者校验和压缩。OkHttp使用列表来跟踪拦截器，拦截器是按顺序调用的。 应用程序拦截器拦截器可以注册为应用拦截器或网络拦截器。我们将使用LoggingInterceptor来区别。 通过在OkHttpClient.Builder上调用addInterceptor（）来注册应用程序拦截器：1234567891011OkHttpClient client = new OkHttpClient.Builder() .addInterceptor(new LoggingInterceptor()) .build();Request request = new Request.Builder() .url("http://www.publicobject.com/helloworld.txt") .header("User-Agent", "OkHttp Example") .build();Response response = client.newCall(request).execute();response.body().close(); 该URL：http://www.publicobject.com/helloworld.txt 重定向到https://publicobject.com/helloworld.txt, OkHttp自动重定向。我们的应用程序拦截器被调用一次，返回的响应chain.proceed()具有重定向的响应：12345678INFO: Sending request http://www.publicobject.com/helloworld.txt on nullUser-Agent: OkHttp ExampleINFO: Received response for https://publicobject.com/helloworld.txt in 1179.7msServer: nginx/1.4.6 (Ubuntu)Content-Type: text/plainContent-Length: 1759Connection: keep-alive 我们可以看到，我们被重定向了，因为response.request().url()不同于request.url()。这两个日志语句记录两个不同的URL。 网络拦截器注册网络拦截器很类似。调用addNetworkInterceptor()代替addInterceptor()：1234567891011OkHttpClient client = new OkHttpClient.Builder() .addNetworkInterceptor(new LoggingInterceptor()) .build();Request request = new Request.Builder() .url("http://www.publicobject.com/helloworld.txt") .header("User-Agent", "OkHttp Example") .build();Response response = client.newCall(request).execute();response.body().close(); 当我们运行这个代码时，拦截器运行两次。一次为最初的请求http://www.publicobject.com/helloworld.txt，另一个为重定向https://publicobject.com/helloworld.txt。123456789101112131415161718192021222324INFO: Sending request http://www.publicobject.com/helloworld.txt on Connection&#123;www.publicobject.com:80, proxy=DIRECT hostAddress=54.187.32.157 cipherSuite=none protocol=http/1.1&#125;User-Agent: OkHttp ExampleHost: www.publicobject.comConnection: Keep-AliveAccept-Encoding: gzipINFO: Received response for http://www.publicobject.com/helloworld.txt in 115.6msServer: nginx/1.4.6 (Ubuntu)Content-Type: text/htmlContent-Length: 193Connection: keep-aliveLocation: https://publicobject.com/helloworld.txtINFO: Sending request https://publicobject.com/helloworld.txt on Connection&#123;publicobject.com:443, proxy=DIRECT hostAddress=54.187.32.157 cipherSuite=TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA protocol=http/1.1&#125;User-Agent: OkHttp ExampleHost: publicobject.comConnection: Keep-AliveAccept-Encoding: gzipINFO: Received response for https://publicobject.com/helloworld.txt in 80.9msServer: nginx/1.4.6 (Ubuntu)Content-Type: text/plainContent-Length: 1759Connection: keep-alive 网络请求还包含很多数据，如OkHttp加入Accept-Encoding: gzip头部通知支持压缩响应。网络拦截器的链具有非空的连接，它可用于询问IP地址和连接到网络服务器的TLS配置。 应用程序和网络拦截之间进行选择每个拦截器链(interceptor chain)都具有相对优势。 应用拦截器 不必担心像重定向和重试的中间响应。 总是被调用一次，即使HTTP响应来自缓存服务。 观察应用程序的原意。不关心OkHttp注入的头文件，如 If-None-Match。 允许短路和不调用Chain.proceed（） 。 允许重试，并多次调用Chain.proceed（） 。 网络拦截器 能够操作像重定向和重试的中间响应。 在短路网络上不调用缓存的响应。 观察在网络上传输的数据。 访问Connection承载请求。 重写请求拦截器可以添加，删除或替换请求头。他们还可以转换请求体。例如，如果你连接到已知支持它的网络服务器，你可以使用应用程序拦截器添加请求体的压缩。123456789101112131415161718192021222324252627282930313233/** This interceptor compresses the HTTP request body. Many webservers can't handle this! */final class GzipRequestInterceptor implements Interceptor &#123; @Override public Response intercept(Interceptor.Chain chain) throws IOException &#123; Request originalRequest = chain.request(); if (originalRequest.body() == null || originalRequest.header("Content-Encoding") != null) &#123; return chain.proceed(originalRequest); &#125; Request compressedRequest = originalRequest.newBuilder() .header("Content-Encoding", "gzip") .method(originalRequest.method(), gzip(originalRequest.body())) .build(); return chain.proceed(compressedRequest); &#125; private RequestBody gzip(final RequestBody body) &#123; return new RequestBody() &#123; @Override public MediaType contentType() &#123; return body.contentType(); &#125; @Override public long contentLength() &#123; return -1; // We don't know the compressed length in advance! &#125; @Override public void writeTo(BufferedSink sink) throws IOException &#123; BufferedSink gzipSink = Okio.buffer(new GzipSink(sink)); body.writeTo(gzipSink); gzipSink.close(); &#125; &#125;; &#125;&#125; 重写响应相对应的，拦截器也可以重写响应头和转换响应体。通常不要重写请求头，因为它可能违反了Web服务器的期望导致更危险！ 在一个棘手的情况下，如果已经做好应对的后果，重写响应头是解决问题的有效方式。例如，您可以修复服务器的配置错误的Cache-Control响应头以便更好地响应缓存：123456789/** Dangerous interceptor that rewrites the server's cache-control header. */private static final Interceptor REWRITE_CACHE_CONTROL_INTERCEPTOR = new Interceptor() &#123; @Override public Response intercept(Interceptor.Chain chain) throws IOException &#123; Response originalResponse = chain.proceed(chain.request()); return originalResponse.newBuilder() .header("Cache-Control", "max-age=60") .build(); &#125;&#125;; 通常此方法效果最好，它补充了在Web服务器上相应的修复！ 可用性OkHttp的拦截器需要OkHttp 2.2或更高版本。不幸的是，拦截器不适OkUrlFactory用于构建它的库，包括Retrofit≤1.8和Picasso≤2.4。 HTTPSOkHttp试图平衡两个相互竞争的担忧： 连接到尽可能多的主机。这包括运行最新版本的boringssl的高级主机，以及运行旧版本OpenSSL的过时主机。 连接的安全性。这包括验证具有证书的远程网络服务器以及与强密码交换的数据的私密性。协商连接到HTTPS服务器时，OkHttp需要知道提供哪些TLS版本和密码套件。希望最大化连接的客户端将包括过时的TLS版本和弱设计密码套件。一个想要最大限度地提高安全性的严格的客户端将仅限于最新的TLS版本和最强的密码套件。 ConnectionSpec实现特定的安全性和连接性决定。OkHttp包含三个内置的连接规范： MODERN_TLS是连接到现代HTTPS服务器的安全配置。 COMPATIBLE_TLS是一种连接到安全但不是当前HTTPS服务器的安全配置。 CLEARTEXT是用于http://URL 的不安全配置。 默认情况下，OkHttp将尝试MODERN_TLS连接，COMPATIBLE_TLS如果现代配置失败，则回退连接。 每个规范中的TLS版本和密码套件可随每个版本而改变。例如，在OkHttp 2.2中，我们放弃了对SSL 3.0的支持来响应POODLE攻击。而在OkHttp 2.3我们放弃了对RC4的支持。与您的桌面网络浏览器一样，保持OkHttp的最新状态是保持安全的最佳方式。 您可以使用自定义的TLS版本和密码套件来构建自己的连接规范。例如，这种配置仅限于三个备受好评的密码套件。它的缺点是它需要Android 5.0+和一个类似的当前网络服务器。 1234567891011ConnectionSpec spec = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS) .tlsVersions(TlsVersion.TLS_1_2) .cipherSuites( CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256, CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256, CipherSuite.TLS_DHE_RSA_WITH_AES_128_GCM_SHA256) .build();OkHttpClient client = new OkHttpClient.Builder() .connectionSpecs(Collections.singletonList(spec)) .build(); 证书锁定默认情况下，OkHttp信任主机平台的证书权限。这一战略最大限度地提高了连接性，但是它受到证书颁发机构的攻击，例如[2011年DigiNotar攻击。它还假定您的HTTPS服务器的证书由证书颁发机构签名。 使用CertificatePinner来限制哪些证书和证书颁发机构是可信的。证书固定增加了安全性，但是限制了您的服务器团队更新其TLS证书的能力。如果没有服务器的TLS管理员的同意，请勿使用证书锁定！ 1234567891011121314151617181920public CertificatePinning() &#123; client = new OkHttpClient.Builder() .certificatePinner(new CertificatePinner.Builder() .add("publicobject.com", "sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=") .build()) .build();&#125;public void run() throws Exception &#123; Request request = new Request.Builder() .url("https://publicobject.com/robots.txt") .build(); Response response = client.newCall(request).execute(); if (!response.isSuccessful()) throw new IOException("Unexpected code " + response); for (Certificate certificate : response.handshake().peerCertificates()) &#123; System.out.println(CertificatePinner.pin(certificate)); &#125;&#125; 自定义可信证书完整的代码示例显示了如何用自己的集合替换主机平台的证书颁发机构。如上所述，请勿在没有服务器的TLS管理员同意的情况下使用自定义证书！12345678910111213141516171819202122232425private final OkHttpClient client;public CustomTrust() &#123; SSLContext sslContext = sslContextForTrustedCertificates(trustedCertificatesInputStream()); client = new OkHttpClient.Builder() .sslSocketFactory(sslContext.getSocketFactory()) .build();&#125;public void run() throws Exception &#123; Request request = new Request.Builder() .url("https://publicobject.com/helloworld.txt") .build(); Response response = client.newCall(request).execute(); System.out.println(response.body().string());&#125;private InputStream trustedCertificatesInputStream() &#123; ... // Full source omitted. See sample.&#125;public SSLContext sslContextForTrustedCertificates(InputStream in) &#123; ... // Full source omitted. See sample.&#125; Events(事件监听)事件允许您在应用程序的HTTP调用中捕获度量值。使用事件进行监视： HTTP调用您的应用程序的大小和频率。如果你声明了太多的calls，或者你的calls太大，你应该知道它的一切 这些调用在底层网络上的性能。如果网络性能不足，则需要改善网络或少用网络。 警告：这是一个非最终的API。从OkHttp 3.9开始，此功能是一个不稳定的预览：API可能会更改，并且实现不完整。我们预计OkHttp 3.10或3.11将完成这个API。在此之前，当您更新您的OkHttp依赖关系时，请准备API和行为更改。 事件监听子类 EventListener,覆盖您感兴趣的事件的方法。在没有重定向或重试的成功HTTP调用中，事件序列由此流程描述。以下是一个示例事件侦听器，它使用时间戳打印每个事件。123456789101112131415161718192021222324252627282930class PrintingEventListener extends EventListener &#123; private long callStartNanos; private void printEvent(String name) &#123; long nowNanos = System.nanoTime(); if (name.equals("callStart")) &#123; callStartNanos = nowNanos; &#125; long elapsedNanos = nowNanos - callStartNanos; System.out.printf("%.3f %s%n", elapsedNanos / 1000000000d, name); &#125; @Override public void callStart(Call call) &#123; printEvent("callStart"); &#125; @Override public void callEnd(Call call) &#123; printEvent("callEnd"); &#125; @Override public void dnsStart(Call call, String domainName) &#123; printEvent("dnsStart"); &#125; @Override public void dnsEnd(Call call, String domainName, List&lt;InetAddress&gt; inetAddressList) &#123; printEvent("dnsEnd"); &#125; ...&#125; 我们做几个calls：123456789101112131415Request request = new Request.Builder() .url("https://publicobject.com/helloworld.txt") .build();System.out.println("REQUEST 1 (new connection)");try (Response response = client.newCall(request).execute()) &#123; // Consume and discard the response body. response.body().source().readByteString();&#125;System.out.println("REQUEST 2 (pooled connection)");try (Response response = client.newCall(request).execute()) &#123; // Consume and discard the response body. response.body().source().readByteString();&#125; 监听器打印相应的事件：12345678910111213141516171819202122232425262728REQUEST 1 (new connection)0.000 callStart0.010 dnsStart0.017 dnsEnd0.025 connectStart0.117 secureConnectStart0.586 secureConnectEnd0.586 connectEnd0.587 connectionAcquired0.588 requestHeadersStart0.590 requestHeadersEnd0.591 responseHeadersStart0.675 responseHeadersEnd0.676 responseBodyStart0.679 responseBodyEnd0.679 connectionReleased0.680 callEndREQUEST 2 (pooled connection)0.000 callStart0.001 connectionAcquired0.001 requestHeadersStart0.001 requestHeadersEnd0.002 responseHeadersStart0.082 responseHeadersEnd0.082 responseBodyStart0.082 responseBodyEnd0.083 connectionReleased0.083 callEnd 注意第二次调用没有连接事件。它重用了第一个请求的连接，以显着提高性能。 EventListener.Factory在前面的例子中，我们使用了一个字段callStartNanos来跟踪每个事件的经过时间。这很方便，但是如果多个调用同时执行，它将不起作用。为了适应这个，使用一个Factory创建一个新的EventListener为每个Call。这允许每个监听者保持特定于呼叫的状态。 此示例工厂为每个呼叫创建一个唯一的ID，并使用该ID区分日志消息中的呼叫。12345678910111213141516171819202122232425262728293031323334class PrintingEventListener extends EventListener &#123; public static final Factory FACTORY = new Factory() &#123; final AtomicLong nextCallId = new AtomicLong(1L); @Override public EventListener create(Call call) &#123; long callId = nextCallId.getAndIncrement(); System.out.printf("%04d %s%n", callId, call.request().url()); return new PrintingEventListener(callId, System.nanoTime()); &#125; &#125;; final long callId; final long callStartNanos; public PrintingEventListener(long callId, long callStartNanos) &#123; this.callId = callId; this.callStartNanos = callStartNanos; &#125; private void printEvent(String name) &#123; long elapsedNanos = System.nanoTime() - callStartNanos; System.out.printf("%04d %.3f %s%n", callId, elapsedNanos / 1000000000d, name); &#125; @Override public void callStart(Call call) &#123; printEvent("callStart"); &#125; @Override public void callEnd(Call call) &#123; printEvent("callEnd"); &#125; ...&#125; 我们可以使用这个侦听器来竞争一对并发的HTTP请求：12345678910111213Request washingtonPostRequest = new Request.Builder() .url("https://www.washingtonpost.com/") .build();client.newCall(washingtonPostRequest).enqueue(new Callback() &#123; ...&#125;);Request newYorkTimesRequest = new Request.Builder() .url("https://www.nytimes.com/") .build();client.newCall(newYorkTimesRequest).enqueue(new Callback() &#123; ...&#125;); 运行这场比赛的家庭无线网络显示，Times（0002）比Post（0001）略快一点：123456789101112131415161718192021222324252627282930313233340001 https://www.washingtonpost.com/0001 0.000 callStart0002 https://www.nytimes.com/0002 0.000 callStart0002 0.010 dnsStart0001 0.013 dnsStart0001 0.022 dnsEnd0002 0.019 dnsEnd0001 0.028 connectStart0002 0.025 connectStart0002 0.072 secureConnectStart0001 0.075 secureConnectStart0001 0.386 secureConnectEnd0002 0.390 secureConnectEnd0002 0.400 connectEnd0001 0.403 connectEnd0002 0.401 connectionAcquired0001 0.404 connectionAcquired0001 0.406 requestHeadersStart0002 0.403 requestHeadersStart0001 0.414 requestHeadersEnd0002 0.411 requestHeadersEnd0002 0.412 responseHeadersStart0001 0.415 responseHeadersStart0002 0.474 responseHeadersEnd0002 0.475 responseBodyStart0001 0.554 responseHeadersEnd0001 0.555 responseBodyStart0002 0.554 responseBodyEnd0002 0.554 connectionReleased0002 0.554 callEnd0001 0.624 responseBodyEnd0001 0.624 connectionReleased0001 0.624 callEnd 该EventListener.Factory还能够指标限制呼叫的子集。这一个随机捕获指标为10％：12345678910111213class MetricsEventListener extends EventListener &#123; private static final Factory FACTORY = new Factory() &#123; @Override public EventListener create(Call call) &#123; if (Math.random() &lt; 0.10) &#123; return new MetricsEventListener(call); &#125; else &#123; return EventListener.NONE; &#125; &#125; &#125;; ...&#125; 事件与失败当操作失败时，调用失败方法。这是connectFailed()在建立到服务器的连接callFailed()时，以及HTTP调用永久失败时的失败。发生故障时，start事件可能没有相应的end事件。 事件与重试和跟进OkHttp具有弹性，可以自动从一些连接失败中恢复。在这种情况下，connectFailed()事件不是终端，也不是随之而来的callFailed()。当尝试重试时，事件监听器将收到多个相同类型的事件。 单个HTTP调用可能需要后续请求来处理认证挑战，重定向和HTTP层超时。在这种情况下，可能会尝试多个连接，请求和响应。跟进是单个电话可能触发多个相同类型事件的另一个原因。 可用性OkHttp 3.9中的预览版本提供了事件。我们预计OkHttp 3.10或3.11将完成这个API。未来版本可能会引入新的事件类型; 您将需要覆盖相应的方法来处理它们。 FAQs(常见问题解答))如何修复dalvikvm中的验证警告？OkHttp支持一些需要Java 7+或Android API 20+的API。如果你在早期的Android版本上运行OkHttp，dalvikvm的验证器会警告你缺少的方法。这不是一个问题，你可以忽略警告。12345678910111213141516I/dalvikvm﹕ Could not find method okhttp3.internal.huc.HttpURLConnectionImpl.getContentLengthLong, referenced from method okhttp3.internal.huc.HttpsURLConnectionImpl.getContentLengthLongW/dalvikvm﹕ VFY: unable to resolve virtual method 21498: Lokhttp3/internal/huc/HttpURLConnectionImpl;.getContentLengthLong ()JD/dalvikvm﹕ VFY: replacing opcode 0x6e at 0x0002I/dalvikvm﹕ Could not find method okhttp3.internal.huc.HttpURLConnectionImpl.getHeaderFieldLong, referenced from method okhttp3.internal.huc.HttpsURLConnectionImpl.getHeaderFieldLongW/dalvikvm﹕ VFY: unable to resolve virtual method 21503: Lokhttp3/internal/huc/HttpURLConnectionImpl;.getHeaderFieldLong (Ljava/lang/String;J)JD/dalvikvm﹕ VFY: replacing opcode 0x6e at 0x0002W/dalvikvm﹕ VFY: unable to find class referenced in signature (Ljava/nio/file/Path;)W/dalvikvm﹕ VFY: unable to find class referenced in signature ([Ljava/nio/file/OpenOption;)I/dalvikvm﹕ Could not find method java.nio.file.Files.newOutputStream, referenced from method okio.Okio.sinkW/dalvikvm﹕ VFY: unable to resolve static method 24080: Ljava/nio/file/Files;.newOutputStream (Ljava/nio/file/Path;[Ljava/nio/file/OpenOption;)Ljava/io/OutputStream;D/dalvikvm﹕ VFY: replacing opcode 0x71 at 0x000aW/dalvikvm﹕ VFY: unable to find class referenced in signature (Ljava/nio/file/Path;)W/dalvikvm﹕ VFY: unable to find class referenced in signature ([Ljava/nio/file/OpenOption;)I/dalvikvm﹕ Could not find method java.nio.file.Files.newInputStream, referenced from method okio.Okio.sourceW/dalvikvm﹕ VFY: unable to resolve static method 24079: Ljava/nio/file/Files;.newInputStream (Ljava/nio/file/Path;[Ljava/nio/file/OpenOption;)Ljava/io/InputStream;D/dalvikvm﹕ VFY: replacing opcode 0x71 at 0x000a]]></content>
      <categories>
        <category>安卓开源库使用教程</category>
      </categories>
      <tags>
        <tag>okhttp3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio使用技巧和资源]]></title>
    <url>%2FAndroidStudio_uses_skills_and_resources.html</url>
    <content type="text"><![CDATA[版权声明：本文转载自:http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/1116/6776.html.版权归原作者所有 对于AndroidStudio的使用，日常使用没问题，但依旧有些快捷技巧没有习惯使用,因此转载本篇文章常读，希望对文章的技巧有些记忆，做到以后的熟练使用 本文列举出一些可以提高整体效率的Android Studio技巧和资源。 显然有太多太多这方面的东西，但是为了文章的简洁性，我把它限制在50个以内，希望你能喜欢！ 视觉效果1.Android Logcat的Material颜色主题。要改变Android Studio的Logcat你需要这样做：进入Preferences (Windows上是Settings / Linux machines) → Editor → Colors &amp; Fonts → Android Logcat，然后为每种类型的log设置前景颜色（foreground）。 我使用的material颜色： Assert #BA68C8Debug #2196F3Error #F44336Info #4CAF50Verbose #BBBBBBWarning #FF9800注意里面有几个现有的主题，可以直接修改现有主题（不建议），或者点击save as按钮拷贝一个主题并改名为Material theme Color然后再改变每种类型log的颜色。 2.防止当前应用崩溃时Logcat清除log。 在Android Monitor面板的右上方点击下拉菜单中的Edit filter configuration：注意是在工程界面的底部Android Monitor面板，而不是单独的Android Monitor工具中。 3.使用一个适合自己的代码主题 (IntelliJ / Android Studio). 找到Preferences → Code Style → Java，在Scheme下拉菜单中你可以选择一个代码风格（或者设置一个新的）。 有两个风格值得专门提一下： Square Java Code Styles with Android Google Java Code Style 你可以按照下面gif图中的做法导入主题： .使用分屏提高效率 要打开这个功能，右键主屏幕的选项卡（tab）选择 Split Vertically / Horizontally。但是为了尽量提高效率我们需要设置一个自定义的快捷方式。为此找到到Preferences → Keymap，搜索Split Vertically。然后打开一个上下文菜单，点击Add Keyboard Shortcut。 我的分屏（vertical）快捷键设置的是control + alt + v。做法如下面的gif图所示。同样的你还可以为 horizontal split设置快捷键。 5.无干扰模式你可以到View → Enter Distraction Free Mode里启用它 在无干扰模式下，编辑器占据了整个IntelliJIDEA窗口，没有任何tab或者工具按钮。代码居中显示 6.使用Live Templates 你可以使用快捷键：cmd + j (Windows / Linux: ctrl + j)。 可以使用已经定义好了的Live Templates，比如Toasts 或者if语句。 可以使用自定义的templates。这里是Reto Meier的一篇不错的参考文章。你也可以参考IntelliJ IDEA的文档. 快捷键以及有用的命令1.最有用的命令是搜索命令的命令：cmd + shift + a (Windows / Linux: ctrl + shift + a)。 假设你想关闭当前tab却不知道怎么做，你只需输入close你就可以得到一个正确的快捷键/命令。 2.选择最近的复制粘贴（管理剪切版）：cmd + shift + v (Windows / Linux: ctrl + shift + v)。默认有5个最近的复制/粘贴元素。 3.启用多光标功能：control + g (alt + j for Windows / Linux)。 4.打开一个类： cmd + o (Windows / Linux: ctrl + n)。 5.打开任意文件： cmd + shift + o (Windows / Linux: ctrl + shift + n)。 6.打开symbol：cmd + option + o (Windows / Linux: alt + shift + n)。 7.跳到实现：cmd + option + b (Windows / Linux:ctrl + alt + b)。 假如你有一个interface。通过点击接口的名字，然后按下快捷键就可以跳转到这个接口的实现。如果有多个实现会出现下拉选择。 8.跳转到定义：cmd + b (Windows / Linux: ctrl + b)。 可以让你快速跳转到一个类，方法或者变量被定义的地方。 9.跳转到类型定义处：control + shift + b (Windows / Linux:ctrl + shift + b)。 假设你定义了： Employee employee = new Employee(“Michal”); 当你的插入符号在employee上，这时你按下快捷键，你将跳转到Employee类中。 10.跳转到super： cmd + u (Windows / Linux: ctrl + u)。 比如，你重写了一些方法,当你的插入符号在方法名上，按下这个快捷键你将跳转到parent的这个方法。 11.Move between tabs: cmd + shift + (move left) or cmd + shift + (Windows / Linux: alt + ← / →). 12 Move between Design / Text tabs in layout’s view:control + shift + ← / → (Windows / Linux: alt + shift + ← / →). 13.关闭当前的tab：cmd + w (Windows / Linux: ctrl + shift + a)。 14.隐藏所有窗口：cmd + shift + F12 (Windows / Linux:ctrl + shift + F12)。 15.最小化 Android Studio instance: cmd + m (Windows / Linux:ctrl + m)。 16.格式化代码: cmd + option + l (Windows / Linux:ctrl + alt + l)。 17.Auto-indent lines: control + option + i (Windows / Linux:ctrl + alt + i). 18.实现接口的方法: control + i (Windows / Linux: ctrl + i)。 假设你要实现一个接口。这个快捷键可以让你快速导入这个接口的所有方法。 19.Smart code completion (filters the list of methods and variables by expected type): control + shift + space (Windows / Linux: ctrl + shift + space). 20.查找: cmd + f (Windows / Linux: ctrl + f)。 21.查找并替换: cmd + r (Windows / Linux: ctrl + r)。 22.把一个硬编码的字符串放到资源文件中：option + return (Windows / Linux: alt + enter)。光标必须在这个文字之上时才能使用这个快捷键。看下面的gif图： 插件1.Key promoter - 快捷键提示插件 当你点击鼠标一个功能的时候,可以提示 你这个功能快捷键是什么 ,和这个按钮你的使用频率 2.String Manipulation - a plugin which provides actions for text manipulation (e.g. toggling styles like camelCase, hyphen-lowercase etc., capitalize text and many more). 3.Android Material Design Icon Generator -这个插件帮助你为工程添加Material Design图标。安装之后使用快捷键cmd + shift + m生成一个图标。 4.ButterKnifeZelezny - 一键从 布局文件中 生成对于的 View 声明和 ButterKnife 注解： 5.IntelliJ/Android Studio Plugin for Android Parcelable boilerplate code generation - 一个根据类的成员生成Parcelable的插件。 6.ADB Idea - 一个帮助你使用adb命令的插件：卸载，杀死，启动，重启，清除数据等命令。 7.Genymotion plugin - 一个让你可以在Android Studio中创建和开启Genymotion虚拟设备的插件。 8.Android Methods Count - a plugin that parses your Android library dependencies and shows the methods count as an handy hint. 9.Git Flow Integration - a plugin for introducing a Git Flow branching model. 10.Builder plugin - a plugin (from Square) that generates a static nested Builder for a class. 资源1.Android Studio Tips of the Day by Philippe Breault2.快捷键参考3.(About) 10 Things You (Probably) Didn’t Know You Could do in Android Studio by Reto Meier。中文版：10个你可能不知道的 Android Studio技巧。 4.无鼠标开发 by Hadi Hariri6.Android Studio for Experts (Android Dev Summit 2015)7.Android Studio Tips and Tricks by Michael Evans8.认识 Android Studio9.Android Studio - Tips and Tricks by Donn Felker10.Debug Your App with Android Studio11.What are some of your must-have plugins for - Reddit discussion]]></content>
      <categories>
        <category>AndroidStudio</category>
      </categories>
      <tags>
        <tag>AndroidStudio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android5.0新控件学习]]></title>
    <url>%2FAndroid5-0-control-study-AppBarLayout-Toolbar-CoordinateLayout-cardView.html</url>
    <content type="text"><![CDATA[版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起. 本文记录一些Androd5.0的新控件的一些学习总结，由于网上的博文总结的比较全面，我就不写博文总结了，这里主要是列举一些控件的学习资料 CoordinateLayout简介：协调布局,配合Behavior使用，特点是能根据一个View的动作协调另一个View的动作。参考文章:CoordinatorLayout的使用如此简单 ToolBar简介：代替ActionBar，比它更加的灵活，实质是一个ViewGroup 参考资料:Android 5.x Theme 与 ToolBar 实战xamarin android toolbar(踩坑完全入门详解) AppBarLayout简介：继承自LinearLayout,它可以让你定制当某个可滚动View手势发生变化时，其内部子View会实现何种动作. CollapsingToolbarLayout简介：用来对ToolBar进行再次包装的ViewGroup，可以实现一些折叠的效果（更像是缩放），比如向上滑动标题文字逐渐缩小至左上角，它需要作为AppBarLayout布局里面并作为它的直接子View. NestedScrollView简介：为了配合AppBarLayout的滚动效果而编写的滚动控件，继承自FrameLayout,随后使用appbar_scrolling_view_behavior即可实现相应的效果 参考文章:玩转AppBarLayout，更酷炫的顶部栏 CardView简介：卡片布局，继承自FrameLayout，可实现阴影效果,通常与RecycleView或ListView配合使用作为item的容器参考资料:CardView的基本用法 RecyclerView简介：比ListView更加灵活，更低耦合的列表展示控件，可轻易实现ListView,GridView,和瀑布流的效果 参考资料: Android RecyclerView 使用完全解析 体验艺术般的控件 FloatingActionButton简介：用来在界面上显示一个悬浮的按钮参考资料：FloatingActionButton 完全解析[Design Support Library(2)] TextInputLayout简介：通常与EditText配合使用，能在EditText输入时将hint放入到上方，还具有空校验的功能 参考资料：TextInputlayout入门讲解Android Design TextInputLayout 解析,带你深入TextInputLayout TabLayout简介：提供一个水平的布局来展示TAB 参考资料：Design库-TabLayout属性详解TabLayout的高端用法 NavigationView简介:在Material Design中，Navigation drawer导航抽屉，被设计用于应用导航，提供了一种通用的导航方式，体现了设计的一致性。而NavigationView的典型用途就是配合之前v4包的DrawerLayout，作为其中的Drawer部分，即导航菜单的本体部分。NavigationView是一个导航菜单框架，使用menu资源填充数据，使我们可以更简单高效的实现导航菜单。它提供了不错的默认样式、选中项高亮、分组单选、分组子标题、以及可选的Header。 参考资料： Android5.0之NavigationView的使用 Snackbar简介：与Toast相似,弹出一个提示框 参考资料：没时间解释了，快使用Snackbar!——Android Snackbar花式使用指南 Palette简介：取色器，从图片中提取关键的颜色，并将该颜色设置到别的控件上,可以和ToolBar配合使用动态改变颜色参考资料:安卓5.x的Palette之你不知道的事 Android Material Design之Toolbar与Palette实践 RippleDrawable简介：5.0以上的涟漪效果,需要兼容5.0以下需要使用开源库RippleEffect.参考资料：Material Design之RippleDrawable详解]]></content>
      <categories>
        <category>Android基础进阶</category>
        <category>安卓控件</category>
      </categories>
      <tags>
        <tag>Android5.0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些关于安卓非编码问题的解决方案记录]]></title>
    <url>%2F%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8E%E5%AE%89%E5%8D%93%E9%9D%9E%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E8%AE%B0%E5%BD%95.html</url>
    <content type="text"><![CDATA[版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起. 安卓的一些非编码问题的一些解决方案记录，如打包，加密等.. 安卓自动化打包发布工作流,签名加密解决方案：可使用Travis CI项目框架 未自动化前安卓开发的工作流程： 开发一些新功能，提交代码 完成一部分功能后，打包一个测试版APK 将测试版APK上传到QQ群 / 网盘 / Fir.im / 蒲公英等 在QQ群或发布平台解释当前版本所完成的功能 通知测试人员测试 实现了这套自动化发布后，工作流程被简化成： 开发新功能，提交代码 通过git tag对代码打一个内测版的tag，在tag的描述中对写当前完成的功能 此外还支持签名加密：加密前:1234567891011121314151617android &#123; signingConfigs &#123; releaseConfig &#123; storeFile file(&quot;../keys/evandroid.jks&quot;) storePassword &quot;123456&quot; keyAlias &quot;evandroid_alias&quot; keyPassword &quot;654321&quot; &#125; &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; signingConfig signingConfigs.releaseConfig &#125; &#125;&#125; 加密后：123456releaseConfig &#123; storeFile file(&quot;../keys/evandroid.jks&quot;) storePassword project.hasProperty(&quot;KEYSTORE_PASS&quot;) ? KEYSTORE_PASS : System.getenv(&quot;KEYSTORE_PASS&quot;) keyAlias project.hasProperty(&quot;ALIAS_NAME&quot;) ? ALIAS_NAME : System.getenv(&quot;ALIAS_NAME&quot;) keyPassword project.hasProperty(&quot;ALIAS_PASS&quot;) ? ALIAS_PASS : System.getenv(&quot;ALIAS_PASS&quot;)&#125; 密钥完全从后台获取 关于Travis CI的资料: 基于Travis CI搭建Android自动打包发布工作流（支持Github Release及fir.im) 安卓多渠道打包(同时打900个渠道包怎么办？？？)解决方案：V1签名下的快速打包工具：AndroidMultiChannelBuildTool 不管多少渠道包，分分钟打完。 V2签名打包:如果公司需要升级到V2签名,那么上面那个就不在适用，请移步到这个:walle,美团针对V2签名设计的打包工具，不过使用方式与上面的那个不同，需要在项目中添加插件并用Gradle构建打包.]]></content>
      <categories>
        <category>安卓杂记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[objectBox数据库使用教程]]></title>
    <url>%2FobjectBox%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B-objectbox-java.html</url>
    <content type="text"><![CDATA[版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起. 数据库简介objectbox数据库是greenrobot团队开发的全新非关系型数据库框架，该团队还开发过greenDao,EventBus等热门框架，可谓实力雄厚。按照官方介绍，该库有如下特点: 超快速:号称胜过测试过的所有嵌入式数据库 面向对象的 API: 没有 rows、columns 和 SQL，完全从0开始的对象（没有ORM，没有SQLite） 反应性:对数据变化的反应简单而强大,使用ObjectBox中的反应数据观察器或与RxJava集成。 多平台:已经支持安卓和java,ios和MacOs正在集成 简单的线程:ObjectBox返回的对象可以在所以线程中运行 没有手动模式迁移:ObjectBox负责添加，删除和重命名属性的新对象版本，意味着数据库的升级不再需要我们自己管理版本号，ObjectBox内部会自动帮我们管理 安装注意，本教程是基于截至于目前最新版1.4.0编写 根目录build.gradle中添加：12345678910111213141516buildscript &#123; ext.objectboxVersion = &apos;1.4.0&apos; repositories &#123; maven &#123; url &quot;http://objectbox.net/beta-repo/&quot; &#125; &#125; dependencies &#123; classpath &quot;io.objectbox:objectbox-gradle-plugin:$objectboxVersion&quot; &#125; &#125; allprojects &#123; repositories &#123; maven &#123; url &quot;http://objectbox.net/beta-repo/&quot; &#125; &#125;&#125; app build.gradle中添加1apply plugin: &apos;io.objectbox&apos; // after applying Android plugin 使用初始化在Application中的onCreate()中初始化1boxStore = MyObjectBox.builder().androidContext(this).build(); 初始化后得到一个BoxStore对象,该对象可以简单理解为获取查询对象的入口,因此，我们可以申明一个get()方法，像这样：12345678910111213141516171819202122public class BaseApp extends Application &#123; private static BaseApp baseApp; private BoxStore boxStore; //数据库表的管理者 @Override public void onCreate() &#123; super.onCreate(); baseApp = this; boxStore = MyObjectBox.builder().androidContext(this).build(); if (BuildConfig.DEBUG) &#123; new AndroidObjectBrowser(boxStore).start(this); &#125; &#125; public BoxStore getBoxStore()&#123; return boxStore; &#125; public static BaseApp getInstence()&#123; return baseApp; &#125;&#125; 实体类的建立objectbox是通过注解来标明哪个类是实体，常用的注解如下：123456789101112131415161718@Entity //表示这是一个需要持久化的实体public class Student &#123; @Id public long id; @Index public String name; @Transient public int tempUsageCount; @NameInDb(&quot;USERNAME&quot;) public String name; public ToOne&lt;Class&gt; classToOne; public int age;&#125; @Entity：这个对象需要持久化。 @Id：这个对象的主键,默认情况下，id是会被objectbox管理的，也就是自增id，如果你想手动管理id需要在注解的时候加上@Id(assignable = true)即可。当你在自己管理id的时候如果超过long的最大值，objectbox 会报错.id的值不能为负数。当id等于0时objectbox会认为这是一个新的实体对象,因此会新增到数据库表中 @Index：这个对象中的索引。对经常大量进行查询的字段创建索引，会提高你的查询性能。 @Transient:如果你有某个字段不想被持久化，可以使用此注解,那么该字段将不会保存到数据库 @NameInDb：有的时候数据库中的字段跟你的对象字段不匹配的时候，可以使用此注解。 @ToOne:做一对一的关联注解，例如示例中表示一张学生表（Student）关联一张班级表（Class）,此外还有一对多，多对多的关联，例如Class的示例：12345678@Entitypublic class Class&#123; @Id long id; @Backlink(to = &quot;classToOne&quot;) public ToMany&lt;Student&gt; studentEntitys;&#125; @ToMany:做一对多的关联注解，如示例中表示一张班级表(Class)关联多张学生表(Student) @Backlink:表示反向关联 增删改查实体类建立完后，在Android Studio中使用Build&gt; Make project编译一次，objectbox会自动帮你生成相应的操作实体,例如·Student则会生成一个Student_的类，该类通常作为Params传递。 增加一条数据首先我们获取该实体的Box对象，随后调用该对象的put()方法即可完成新增操作1234Box&lt;Student&gt; StudentBox = BaseApp.getInstence().getBoxStore().boxFor(Student.class);Student student = new Student();student.name = &quot;Jay&quot;;StudentBox.put(student); 删除数据1StudentBox.remove(student); //该参数可以传要删除的实体，也可以传入要删除的实体的id,可以批量传入 查询通过Box的query()方法可以得到一个QueryBuilder对象，该对象可以实现各种查询操作，里面包含contains(),equal()等各种便捷的查询方法，示例如下：12//查询一个名叫Jay的学生信息的表Student jayStudent = StudentBox.query().equal(Student_.name, &quot;Jay&quot;).build().find(); 里面的Property对象其实就是传入我们自动生成的Student_对象的参数。 修改objectBox修改数据非常简单，首先得到要修改的实体类，直接修改数据，随后调用put()方法即可，示例如下：1234//查询一个名叫Jay的学生信息的表Student jayStudent = StudentBox.query().equal(Student_.name, &quot;Jay&quot;).build().find();jayStudent.name = &quot;www.huangjie.name&quot;;StudentBox.put(jayStudent); 这样就把Jay改成了我的博客地址,haha~ 数据库的其他操作数据库的数据升级当我们需要新增和删除字段时，直接操作实体类即可，不需要做特殊的更改，如果需要重命名字段名或实体类名，可以按照如下步骤操作：第一步：给需要修改的类名加上@UID注解123@Entity@Uidpublic class MyName &#123; ... &#125; 第二步：编译项目，编译将失败，并且会给你一个UIDerror: [ObjectBox] UID operations for entity &quot;MyName&quot;: [Rename] apply the current UID using @Uid(6645479796472661392L) - [Change/reset] apply a new UID using @Uid(4385203238808477712L)第三步：将Rename后面的UID放入到要修改的类中：123@Entity@Uid(6645479796472661392L)public class MyName &#123; ... &#125; 第四步：进行数据的修改123@Entity@Uid(6645479796472661392L)public class MyNewName &#123; ... &#125; 更改数据属性或重命名字段名同理操作。 表关系@ToOne和@ToMany可以看作JAVA中的T和List的关系,拿班级和学生举例，设置相关的学生对象如下：12345Class class = new Class(); //先创建一个班级Student student = new Student();student.name = &quot;Jay&quot;;student.classToOne.setTarget(class); //设置一对一的target对象，字段参见以上示例long studentId = StudentBox.put(student); 获取该学生的班级信息：12Student student = StudentBox.get(studentId);Class class = student.classToOne.getTarget(); 而一对多的关系更为简单，你可以像List集合一样去操作它：1234567891011Class class_ = new Class(); //先创建一个班级Student s1 = new Student(); //添加一个学生student.name = &quot;Jay&quot;;Student s2 = new Student();s2.name = &quot;Android&quot;;class_ .studentEntitys.add(s1);class_ .studentEntitys.add(s2);Box classBox = BaseApp.getInstence().getBoxStore().boxFor(Class.class);classBox.put(class); 这样的话一张Class表中就有两个学生表的数据了，查询的话可以获取该Class的实体，随后像遍历List集合一样去遍历studentEntitys字段,objectBox提供的方法和List集合几乎一样，这里就不做示例了。 求和等操作使用Query对象即可进行求和等操作,通过QueryBuilder的build()方法即可得到。随后调用sumDouble()等方法传入求和条件即可。我们获取实体类或实体类集合也是使用的该对象获取。 另外，objectBox还支持事务，Rxjava查询，Kotlin的支持，更多详情可以通过官方文档了解http://objectbox.io. Endemmmmmm…写了这么多，个人觉得objectBox挺好用的，目前没发现啥坑，唯一的坑是编译的时候提示找不到MyObjectBox这个类，这个不用担心，先确认一下配置是否有误，无误的话将项目Make Project一下或者重新编译一下就OK了，另外，推荐下我写的ObjectBox数据库的练手项目仿支付宝记账本,仿的支付宝中的记账本功能，结合它看你的objectBox上手更快哦。]]></content>
      <categories>
        <category>安卓开源库使用教程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android开发常见问题与技巧汇总]]></title>
    <url>%2FAndroid%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB.html</url>
    <content type="text"><![CDATA[版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起. 此为开发中遇到的一些常见问题的整理，方便下次遇到问题能快速找到解决方案，此外还收集了一些常见的开发技巧，持续更新中~~ 1 编译出现：1All com.android.support libraries must use the exact same version specification (mixing versions can lead to runtime crashes)...... 如果引用的第三方库的支持库版本低于（或者不一致）app build.gradle中的支持库版本，就会出现这种问题,修改第三方的依赖的话工作量太大,因此考虑所有模块强制使用相同的版本号的支持库，代码如下： 在app build.gradle中添加： 12345678910configurations.all &#123; resolutionStrategy.eachDependency &#123; DependencyResolveDetails details -&gt; def requested = details.requested if (requested.group == 'com.android.support') &#123; if (!requested.name.startsWith("multidex")) &#123; details.useVersion '26.1.0' &#125; &#125; &#125;&#125; 此代码声明了除multdex外全部使用26.1.0的版本库 2 SVG图片兼容问题(主要针对5.0以下机型)参考博客：Android Vector曲折的兼容之路 基本适配方法：在app build.gradle 的defaultConfig中添加defaultvectorDrawables.useSupportLibrary = true xml中使用：ImageView原本是使用src加载,改为app:srcCompat. java中使用：ImageView iv = (ImageView) findViewById(R.id.iv); iv.setImageResource(R.drawable.vector_image); 3.自定义View中在4.X版本上通过getContext()方法强转成Activity失效参考博客： 记一次View.getContext()遇到的大坑 原因：兼容v7包将Context包裹成了TintContextWrapper,所以强转成Activity会出错 解决方法：使用构造方法中的Context来强转。 4.引入的第三方库与自己的support包冲突解决方法：将冲突的库改成以下写法：123implementation ('此处是你引入的库')&#123; exclude group: 'com.android.support' //什么包冲突了这里就声明什么,注意名称要写对写全 &#125; 另外，在这里普及一下implementation的概念,现在升级了AS后引入三方库有多种方式，如implementation,compile,api ..其中，implementation主要是引用本模块的库，其他模块是调用不到该模块引用的库的,类似java中的private属性,而compile类似java中的public属性,只要模块之间相互依赖,引用的库都能相互调用,而api的作用与compile一样,使用这些不同的调用方式是为了加快编译速度，如果你的库不需要在其他模块之中使用,请使用implementation方式，这样当外部调用改变不会编译整个model而只会编译改变的那个model. 5.在java代码中获取xml中设置的behavior在开发项目的时候需要获取behavior的实例做一些事情，发现CoordinatorLayout没有提供获取behavior的方法，后来查看源码发现是使用CoordinatorLayout.LayoutParams来设置behavior的，所以behavior自然是从这里来获取,示例代码如下： 123//子类获取上级的CoordinatorLayout.LayoutParamsCoordinatorLayout.LayoutParams cl = (CoordinatorLayout.LayoutParams) mRecyclerView.getLayoutParams(); MyBehavior behavior = (MyBehavior) cl.getBehavior(); //调用getBehavior方法 6.设置状态栏透明并使父布局移动到状态栏上去(适用于5.0以上)项目中需要用到状态栏颜色随着标题栏颜色改变,甚至还有渐变效果,如果单纯设置状态栏颜色非常不方便，并且实现颜色渐变也不简单，所有将采用将父布局上移的方法,这样状态栏的颜色就是标题栏的颜色啦,实现方法如下： step1:定义主题文件1234&lt;style name="TransTheme" parent="Theme.AppCompat.Light.NoActionBar"&gt; &lt;item name="android:windowTranslucentStatus"&gt;true&lt;/item&gt; &lt;item name="android:statusBarColor"&gt;@android:color/transparent&lt;/item&gt; //设置状态栏透明 &lt;/style&gt; step2:在清单文件的Activity中使用它123&lt;activity android:name=".module.ScheduleActivity" android:theme="@style/TransTheme" /&gt; step3:让你的父布局的控件向下偏移一个状态栏的高度:获取状态栏的高度:1234567891011/** * 获取状态栏高度 * * @param context context * @return 状态栏高度 */ public static int getStatusBarHeight(Context context) &#123; // 获得状态栏高度 int resourceId = context.getResources().getIdentifier("status_bar_height", "dimen", "android"); return context.getResources().getDimensionPixelSize(resourceId); &#125; 然后需要偏移的控件就需要根据项目实际情况了，一般是自定义一个标题布局,然后在所有的Activity中使用这个标题布局,我的标题布局的父布局是一个FragmeLayout，因此做如下设置： 12345if (Build.VERSION.SDK_INT&gt;Build.VERSION_CODES.KITKAT)&#123; FrameLayout.LayoutParams fl = (LayoutParams) mFrameLayout.getLayoutParams(); fl.topMargin = getStatusBarHeight(getContext()); mFrameLayout.setLayoutParams(fl); &#125; 然后给mFrameLayout设置背景色,这样状态栏就和标题栏一个颜色啦。]]></content>
      <categories>
        <category>Android基础进阶</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2017年终总结]]></title>
    <url>%2F2017%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起. 前言从自己开始坚持写博客也有1个月了，感觉非常的充实，博客就是注重总结归纳嘛，既然2017都已经过去，那么也有必要总结归纳一下啦。其实我认为我的2017总结起来就是：行动起来，不再等待，重在参与！ 回首一眨眼2017就过去了，想想自己今年，的确是成长最快的一年，也是忙碌而又平淡的一年，收获了许多。 依稀记得年初，就有了技术进阶的想法，因为感觉自己在许多功能点上‘会做’，但‘不懂’，无法深入的解决问题。于是，我就寻求进阶的方法，我在帅张的公众号上读了他写的一遍文章，文章指出，习惯很重要，我结合自身的行为揣摩这句话，总结发现，学习并不需要强迫自己去学，而应该把它当成一种自然习惯，就像渴了会喝水一样的生活习惯，这种习惯的培养需要的是坚持，以及自律！为此我尝试慢慢去培养自己的学习习惯： 因为公司搬家，我从家到公司需要30-40分钟，在地铁上，以前是都是看一下新闻啊，刷一下微博啊，现在我都是看掘金有没有什么新鲜的框架，看看简书有没有好看的技术文章，看看github有没有火热的技术排名，那些微博什么的我再也没打开过，我已经坚持有大半年的，甚至现在但凡座地铁我也会习惯性打开这些app 以前的我工作回到家都是刷电视剧，现在都是有目的性的去学习一个知识点或者一门语言，这样时间过得非常的快，每天感觉时间不够用，果然当投入到某一件事时时间的流逝是非常快速的。 先前都是自己写demo,自己总结知识点，然后写到印象笔记中，但是我发现里面的知识点太散乱，无法成为一个体系。于是我就试着写博客，为此，我发现了一个新大陆，写博客对于知识的梳理简直太有用了，前提是你想写好一篇博客。 学习知识就要善于总结归纳，书本是最好的老师，为此2017我阅读了一些的书籍： 郭神的《第一行代码》第二版，这是一本基础书籍，它让我对安卓的基础有了更加完善的了解和夯实。 任玉刚的《安卓开发艺术探索》，这是一本进阶类的书籍，它让我突破了瓶颈，对安卓的了解更加的深入了。 我对这两位都非常的钦佩，正是他们让我们这些开发者的进阶至少能提前0.5-1年的时间，《开发艺术探索》我来回读了好几遍，每一次都会有新的收获，再次感谢~ 晚上，我也会偶尔看下慕课网上的视频，我觉得里面的老师讲的还是比较好的，为此我也推荐给大家。 回首2017的技术有如下的总结： 学习了自定义View,对自定义的流程有了较为完善的了解 学习了View体系，view的确是一个非常有魅力的控件，它可以带来无穷的创造力 对数据库框架都有所了解：如公司项目正在使用的ActiveAndroid(作者貌似不维护了？),使用greenDAO做过一些简单的demo,后来发现了greenDao的作者正在开发一个全新的数据库，号称最快的数据库，于是就没有继续深入greenDao的研究，转而研究新的数据库，它就是我现在正在研究的object-box,不过现在资料还较少，届时我会出一个教程。 学习了ExoPlayer视频播放框架，Rxjava,okhttp,mvp等等的一些热门框架和架构 学习了一些kotlin的基本语法 学习了html5的一些基本语法，能制作一些静态页面 基于hexo和coding搭建的博客平台.先前本来是上传到github的，由于百度被墙的关系，就移到coding了。 展望对于2018，我坚信我的坚持会带给我更多的收获。我依旧会努力坚持2017正在做的事情： 坚持写博客，至少1周一篇 坚持技术学习 2018要刷的书有《kotlin实战》，《Android神兵利器》，《安卓群英传》。 2018需要进阶的技术有： kotlin的熟练使用 自定义View的总结，动画系列 直播，视频播放技术要点总结 设计模式 内存优化 gradle精通 简单了解下逆向，反编译等技术 2018，让我们一起加油~]]></content>
      <categories>
        <category>感悟</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ExoPlayer视频框架：自定义UI界面及源码解析]]></title>
    <url>%2FExoPlayer%E8%A7%86%E9%A2%91%E6%A1%86%E6%9E%B6%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89UI%E7%95%8C%E9%9D%A2%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.html</url>
    <content type="text"><![CDATA[版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起. 本文主要讲述使用ExoPlayer框架时如何自定义自己的视频播放界面，来达到满意的效果，以及SimpleExoPlayerView的源码解析 SimpleExoPlayerView 类介绍SimpleExoPlayerView是一个自定义FrameLayout,内部封装了视频，字幕，播放封面，播放控制器的View逻辑 简单使用在xml中声明该控件：123456&lt;com.google.android.exoplayer2.ui.SimpleExoPlayerView android:layout_width="match_parent" android:layout_height="wrap_content" android:id="@+id/simpleExoPlayerView" app:resize_mode="fixed_width" /&gt; SimpleExoPlayerView内部的AspectRatioFrameLayout封装了视频宽高比的计算，它根据视频流的宽高比来动态设置控件的宽高来达到适应屏幕的目的，resize_mode可以指定这种视频的宽高比计算模式，共有四种模式，fixed_width代表根据宽度来动态计算高度，宽度不会变化，fixed_height与之相反，fill模式会忽略宽高比，不进行动态计算，fit为默认模式，如果高度变形就动态计算高度来适配，宽度变形就动态计算宽度来适配。activity中：1simpleExoPlayerView.setPlayer(player); 通过setPlayer方法来与ExoPlayer绑定 源码分析要随心所欲的使用该View，来定制自己理想的UI，就得先了解其中的原理，方能全面掌控，下面我们就来撸一遍源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161@TargetApi(16)public final class SimpleExoPlayerView extends FrameLayout &#123; private static final int SURFACE_TYPE_NONE = 0; private static final int SURFACE_TYPE_SURFACE_VIEW = 1; private static final int SURFACE_TYPE_TEXTURE_VIEW = 2; private final AspectRatioFrameLayout contentFrame; private final View shutterView; private final View surfaceView; private final ImageView artworkView; private final SubtitleView subtitleView; private final PlaybackControlView controller; private final ComponentListener componentListener; private final FrameLayout overlayFrameLayout; private SimpleExoPlayer player; private boolean useController; private boolean useArtwork; private Bitmap defaultArtwork; private int controllerShowTimeoutMs; private boolean controllerAutoShow; private boolean controllerHideOnTouch; public SimpleExoPlayerView(Context context) &#123; this(context, null); &#125; public SimpleExoPlayerView(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public SimpleExoPlayerView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); if (isInEditMode()) &#123; contentFrame = null; shutterView = null; surfaceView = null; artworkView = null; subtitleView = null; controller = null; componentListener = null; overlayFrameLayout = null; ImageView logo = new ImageView(context); if (Util.SDK_INT &gt;= 23) &#123; configureEditModeLogoV23(getResources(), logo); &#125; else &#123; configureEditModeLogo(getResources(), logo); &#125; addView(logo); return; &#125; boolean shutterColorSet = false; int shutterColor = 0; int playerLayoutId = R.layout.exo_simple_player_view; boolean useArtwork = true; int defaultArtworkId = 0; boolean useController = true; int surfaceType = SURFACE_TYPE_SURFACE_VIEW; int resizeMode = AspectRatioFrameLayout.RESIZE_MODE_FIT; int controllerShowTimeoutMs = PlaybackControlView.DEFAULT_SHOW_TIMEOUT_MS; boolean controllerHideOnTouch = true; boolean controllerAutoShow = true; if (attrs != null) &#123; TypedArray a = context.getTheme().obtainStyledAttributes(attrs, R.styleable.SimpleExoPlayerView, 0, 0); try &#123; shutterColorSet = a.hasValue(R.styleable.SimpleExoPlayerView_shutter_background_color); shutterColor = a.getColor(R.styleable.SimpleExoPlayerView_shutter_background_color, shutterColor); playerLayoutId = a.getResourceId(R.styleable.SimpleExoPlayerView_player_layout_id, playerLayoutId); useArtwork = a.getBoolean(R.styleable.SimpleExoPlayerView_use_artwork, useArtwork); defaultArtworkId = a.getResourceId(R.styleable.SimpleExoPlayerView_default_artwork, defaultArtworkId); useController = a.getBoolean(R.styleable.SimpleExoPlayerView_use_controller, useController); surfaceType = a.getInt(R.styleable.SimpleExoPlayerView_surface_type, surfaceType); resizeMode = a.getInt(R.styleable.SimpleExoPlayerView_resize_mode, resizeMode); controllerShowTimeoutMs = a.getInt(R.styleable.SimpleExoPlayerView_show_timeout, controllerShowTimeoutMs); controllerHideOnTouch = a.getBoolean(R.styleable.SimpleExoPlayerView_hide_on_touch, controllerHideOnTouch); controllerAutoShow = a.getBoolean(R.styleable.SimpleExoPlayerView_auto_show, controllerAutoShow); &#125; finally &#123; a.recycle(); &#125; &#125; LayoutInflater.from(context).inflate(playerLayoutId, this); componentListener = new ComponentListener(); setDescendantFocusability(FOCUS_AFTER_DESCENDANTS); // Content frame. contentFrame = findViewById(R.id.exo_content_frame); if (contentFrame != null) &#123; setResizeModeRaw(contentFrame, resizeMode); &#125; // Shutter view. shutterView = findViewById(R.id.exo_shutter); if (shutterView != null &amp;&amp; shutterColorSet) &#123; shutterView.setBackgroundColor(shutterColor); &#125; // Create a surface view and insert it into the content frame, if there is one. if (contentFrame != null &amp;&amp; surfaceType != SURFACE_TYPE_NONE) &#123; ViewGroup.LayoutParams params = new ViewGroup.LayoutParams( ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT); surfaceView = surfaceType == SURFACE_TYPE_TEXTURE_VIEW ? new TextureView(context) : new SurfaceView(context); surfaceView.setLayoutParams(params); contentFrame.addView(surfaceView, 0); &#125; else &#123; surfaceView = null; &#125; // Overlay frame layout. overlayFrameLayout = findViewById(R.id.exo_overlay); // Artwork view. artworkView = findViewById(R.id.exo_artwork); this.useArtwork = useArtwork &amp;&amp; artworkView != null; if (defaultArtworkId != 0) &#123; defaultArtwork = BitmapFactory.decodeResource(context.getResources(), defaultArtworkId); &#125; // Subtitle view. subtitleView = findViewById(R.id.exo_subtitles); if (subtitleView != null) &#123; subtitleView.setUserDefaultStyle(); subtitleView.setUserDefaultTextSize(); &#125; // Playback control view. PlaybackControlView customController = findViewById(R.id.exo_controller); View controllerPlaceholder = findViewById(R.id.exo_controller_placeholder); if (customController != null) &#123; this.controller = customController; &#125; else if (controllerPlaceholder != null) &#123; // Propagate attrs as playbackAttrs so that PlaybackControlView's custom attributes are // transferred, but standard FrameLayout attributes (e.g. background) are not. this.controller = new PlaybackControlView(context, null, 0, attrs); controller.setLayoutParams(controllerPlaceholder.getLayoutParams()); ViewGroup parent = ((ViewGroup) controllerPlaceholder.getParent()); int controllerIndex = parent.indexOfChild(controllerPlaceholder); parent.removeView(controllerPlaceholder); parent.addView(controller, controllerIndex); &#125; else &#123; this.controller = null; &#125; this.controllerShowTimeoutMs = controller != null ? controllerShowTimeoutMs : 0; this.controllerHideOnTouch = controllerHideOnTouch; this.controllerAutoShow = controllerAutoShow; this.useController = useController &amp;&amp; controller != null; hideController(); &#125; 以下是一些暴露的方法 ....... &#125; 我们看下它的构造方法，首先通过isInEditMode()方法判断了是否是在可视化编辑器中加载的，是的话就return。 接下来声明了一些默认的变量，并赋予了一些默认的值，我们看到有一个playerLayoutId声明了一个默认的布局文件exo_simple_player_view，跟踪去看下：1234567891011121314151617181920212223242526272829303132333435&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;merge xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;com.google.android.exoplayer2.ui.AspectRatioFrameLayout android:id="@id/exo_content_frame" android:layout_width="match_parent" android:layout_height="match_parent" android:layout_gravity="center"&gt; &lt;!-- Video surface will be inserted as the first child of the content frame. --&gt; &lt;View android:id="@id/exo_shutter" android:layout_width="match_parent" android:layout_height="match_parent" android:background="@android:color/black"/&gt; &lt;ImageView android:id="@id/exo_artwork" android:layout_width="match_parent" android:layout_height="match_parent" android:scaleType="fitXY"/&gt; &lt;com.google.android.exoplayer2.ui.SubtitleView android:id="@id/exo_subtitles" android:layout_width="match_parent" android:layout_height="match_parent"/&gt; &lt;/com.google.android.exoplayer2.ui.AspectRatioFrameLayout&gt; &lt;FrameLayout android:id="@id/exo_overlay" android:layout_width="match_parent" android:layout_height="match_parent"/&gt; &lt;View android:id="@id/exo_controller_placeholder" android:layout_width="match_parent" android:layout_height="match_parent"/&gt;&lt;/merge&gt; 这个布局文件就是我们的ExoPlayer ui包中的默认ui布局。AspectRatioFrameLayout是继承自FragmeLayout,也就是源码中的contentFrame，它的作用是根据视频的宽高比和屏幕的宽高比来动态计算视频View的宽高比例。而SimpleExoPlayerView会将surfaceView动态插入到AspectRatioFrameLayout的第一个子View中来，来作为播放的View. exo_shutter也就是源码中的shutterView，它的背景可以通过代码动态设置，可以作为视频的一个蒙层. exo_artwork为源码中的artworkView，是一个ImageView,可以放一些图片上去. SubtitleView是一个字幕显示器，为源码中的subtitleView，可以定制字幕文件。 exo_overlay为源码中的overlayFrameLayout，在源码中没有定制任何东西，可以根据需求放入一些逻辑。 exo_controller_placeholder为源码中的controllerPlaceholder，定义了PlaybackControlView的布局属性，在代码中SimpleExoPlayer会将controllerPlaceholder的Param属性添加到PlaybackControlView上。PlaybackControlView是一个播放控制器View.内部封装了播放器控制逻辑，也可以定制自定义ui和实现自己的控制逻辑。 介绍了这么多，接下来继续分析源码LayoutInflater.from(context).inflate(playerLayoutId, this);可以看到，SimpleExoPlayerView将playerLayoutId添加进了该视图，因此，我们可以通过xml的属性来指定该View的视图id，接着声明了该焦点模式为只有当子View不需要焦点时才获取焦点。setDescendantFocusability(FOCUS_AFTER_DESCENDANTS);接下来通过findViewById的模式得到视图的控件来进行不同的设置，因此，如果我们自定义的ui中想用到里面的功能，就必须申明一样的id.也可以通过findViewById的方式得到该控件。接下来继续走： 1234567891011// Create a surface view and insert it into the content frame, if there is one. if (contentFrame != null &amp;&amp; surfaceType != SURFACE_TYPE_NONE) &#123; ViewGroup.LayoutParams params = new ViewGroup.LayoutParams( ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT); surfaceView = surfaceType == SURFACE_TYPE_TEXTURE_VIEW ? new TextureView(context) : new SurfaceView(context); surfaceView.setLayoutParams(params); contentFrame.addView(surfaceView, 0); &#125; else &#123; surfaceView = null; &#125; 可以看到，SimpleExoPlayerView根据sufaceType自动创建一个SufaceView或TextureView,并将其添加到AspectRatioFrameLayout的第一个子View上，用来播放视频。因此如果自定义UI，一定要定义一个AspectRatioFrameLayout来包裹该View.接着我们看一下控制器的逻辑：1234567891011121314151617// Playback control view. PlaybackControlView customController = findViewById(R.id.exo_controller); View controllerPlaceholder = findViewById(R.id.exo_controller_placeholder); if (customController != null) &#123; this.controller = customController; &#125; else if (controllerPlaceholder != null) &#123; // Propagate attrs as playbackAttrs so that PlaybackControlView's custom attributes are // transferred, but standard FrameLayout attributes (e.g. background) are not. this.controller = new PlaybackControlView(context, null, 0, attrs); controller.setLayoutParams(controllerPlaceholder.getLayoutParams()); ViewGroup parent = ((ViewGroup) controllerPlaceholder.getParent()); int controllerIndex = parent.indexOfChild(controllerPlaceholder); parent.removeView(controllerPlaceholder); parent.addView(controller, controllerIndex); &#125; else &#123; this.controller = null; &#125; 可以看到PlaybackControlView也是通过找id的方式获取，因此我们需要定制控制器ui的话可以通过继承PlaybackControlView的方式来定制我们自己的控制UI。如果我们没有定义PlaybackControlView，那么会先创建一个PlaybackControlView，然后去取exo_controller_placeholder的param属性赋给PlaybackControlView，如果没有的话，那么不会申明一个控制器。 UI定制以上通过源码分析，相信对该控件也有个大概的了解了，接下来看看如何定制我们的UI：首先，在xml中我们可以通过controller_layout_id属性申明我们自己的Layout id:1234567&lt;com.google.android.exoplayer2.ui.SimpleExoPlayerView android:layout_width="match_parent" android:layout_height="wrap_content" android:id="@+id/simpleExoPlayerView" app:resize_mode="fixed_width" app:controller_layout_id="@layout/simple_player_view" /&gt; simple_player_view为我自定义布局文件，看一下simple_player_view的代码：12345678910111213&lt;com.google.android.exoplayer2.ui.AspectRatioFrameLayout android:id="@id/exo_content_frame" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_gravity="top"&gt; &lt;com.jie.exoplayerdemo.PlayControlView android:layout_width="match_parent" android:layout_height="wrap_content" android:id="@id/exo_controller" android:layout_gravity="bottom" app:controller_layout_id="@layout/exo_playback_control_view" /&gt;&lt;/com.google.android.exoplayer2.ui.AspectRatioFrameLayout&gt; 该布局只要id与源码中对应即可随意定制，我在里面只是申明了一个AspectRatioFrameLayout和一个自定义的控制器，如果我们不想用该框架的默认控制器PlaybackControlView，可以自定义该控制器，控制器的自定义逻辑和SimpleExoPlayerView一样，也是通过申明id的方式来控制View的逻辑，并且该View不是final类，因此可以继承PlaybackControlView来实现自己的逻辑。PlayControlView就是继承PlaybackControlView来实现的自定义逻辑，我们可以直接通过找id的方式来获取PlaybackControlView里的控件，因此，里面的所有控件是可定制的。可是，我们的SimpleExoPlayerView是一个final类，如果需要实现SimpleExoPlayerView没有的功能，我们需要将SimpleExoPlayerView的代码复制一份出来来达到修改的目的。]]></content>
      <categories>
        <category>Android视频播放</category>
      </categories>
      <tags>
        <tag>ExoPlayer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高效资源搜罗合集，不看保证后悔(持续更新)]]></title>
    <url>%2FEfficientresourcessearchtogethernoguaranteeofregret.html</url>
    <content type="text"><![CDATA[版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起. 恭喜你发现了这篇博文，看了这篇博文，jay帮你打开新世界的大门，多年老司机开车，请系好安全带。 搜索篇(什么？说起搜索你只知道baidu?那你就out了) 快搜：http://search.chongbuluo.com/ 看图就知道，各种资源应有尽有，只有你想不到，没有你搜不到，强烈推荐 西林街搜索：http://www.xilinjie.com/ 各种电影资源,考试资料，都有，搜索比较精准，推荐 WolframAlpha :http://www.wolframalpha.com/国外网站，就不放图了，可以在线解答问题，不管是数学，历史，生活，等等，都能帮你回答 StackExchange： https://stackexchange.com/国外的’知乎’,里面的问题和回答的质量很高，英语好的可以经常逛逛 Github：http://www.github.com/全球最大代码托管平台，没有程序员不知道的吧，在这里你可以找到各种开源项目和共享资源，比如谷歌镜像，host地址分享等 种子搜索类(实在太多，随便列几个) BTZO :http://www.btzo.net/电影资源挺丰富的，各种vip电影都有 胖次搜索 ：http://www.panc.cc/ 界面相当可爱有木有，当然资源也是相当多的 网盘搜索 网盘搜 ：http://www.wangpansou.com/你是不是经常遇到想要的资源百度链接又失效了，不要害怕，使用了网盘搜，全网资源一网打尽，再也不需要等待别人分享资源了。 图片类（设计师福利）Everypixel : https://everypixel.com/国外图片搜索类网站 图虫网 https://tuchong.com/ 摄影爱好者必备 Pixabay : https://pixabay.com/ 嗯，免费高清图片！！！！ Pexels : https://www.pexels.com/国外网站，素材很多而且免费。 500PX：https://500px.com/ 号称最出色的摄影专区，嗯，值得一试 还有几个找icon的网站：iconFont http://www.iconfont.cn/阿里矢量图库，里面有许多app的图片资源和icon，并且提供svg和图标颜色转换，我平时仿写app就是用的它来找icon的 easyicon :http://www.easyicon.net/iconsearch/See/一个icon图标搜索网站 此外，还有百度的百度识图也不错，有时候找到了一张非高清的图可以通过它找到高清的图：http://image.baidu.com/?fr=shitu 影视类（高清电影在线观看）推荐几个在线观看电影的网站，没有广告哦,当然，这种网站现在很多，毕竟流量很大yy6080 ：http://www.yy6080.org/,类似还有80s(老牌电影网站),人人影视，天天美剧,1905电影网，BT天堂，童话村，这里就不贴地址了，百度就能找到 音乐类（high到停不下来）强烈安利一款听歌神器：listen1 :http://listen1.github.io/listen1/这是一款谷歌浏览器插件，当你想听某一首有版权的歌，QQ音乐有这首歌的版权，而网易云没有，而你使用的是网易云，而你又想听这首歌，这个时候你就不得不使用QQ音乐播放器，是不是很闹心，这个插件的作用就是集结了三大主流平台的音乐，让你免去切播放器的烦恼，从此一次性可以听3个音乐平台的歌了。 5Sing : http://5sing.kugou.com/index.html它是一个原创音乐基地，有许多的原创和翻唱伴奏歌曲。 软件工具类（谁用谁知道）手机app:藏书库 : http://www.geeboo.com/ 藏书馆，是读书爱好者在移动互联网空间里的专属私人图书馆，它通过共享借阅的模式，实现了书友间海量书籍的线上互借。 网易蜗牛读书：http://du.163.com/全网每天有1小时的免费读书时间，比较有特色 网站：TinyPNG:https://tinypng.com/这是一款可以在线压缩图片的网站，压缩后图片质量还挺好的，本人一直在用 135编辑器：http://www.135editor.com/如果你正在运营一个公众号，那么在公众号里写文章就可以使用这个网站，里面的公众号模板和排版个人一直很喜欢 另外，安利一个淘软件的神器网站：52破解论坛:https://www.52pojie.cn/里面汇聚360，腾讯，阿里等安全大牛，每天都有原创破解软件发布，惊喜多多哦~~ 资源暂时分享到这，后期还会持续更新，码字不易，如果觉得对你有帮助，不如点击下方赞赏按钮请我喝杯咖啡，另外，你可以按下Ctrl+D收藏该网址或者分享给好友，防止下次找不到了哦~~]]></content>
      <categories>
        <category>资源整合</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一看就懂的自定义顶部粘性下拉控件TouchPullView全面剖析]]></title>
    <url>%2F%E4%B8%80%E7%9C%8B%E5%B0%B1%E6%87%82%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E9%A1%B6%E9%83%A8%E7%B2%98%E6%80%A7%E4%B8%8B%E6%8B%89%E6%8E%A7%E4%BB%B6TouchPullView%E5%85%A8%E9%9D%A2%E5%89%96%E6%9E%90.html</url>
    <content type="text"><![CDATA[版权声明：本文为博主原创文章，转载请注明出处(www.huangjie.name)，保护原创，从我做起. 昨天在慕课上看到了一个自定义粘性头部的实现，发现现在有许多的app都有这个效果，于是跟着慕课上得视频敲了一遍。因为慕课上的老师对于后半部分的坐标运算讲的并不是很细致，因此我自己分析了一下源代码，总结了这篇博客，希望对同学们有所帮助。 慕课视频地址：https://www.imooc.com/learn/830源码下载地址：https://github.com/Jay-huangjie/TouchPullView建议大家先下载源码再来观看 用到的知识点我们先来复习一下需要用到的数学知识点 三角函数： sin = a/c; cos = b/c; tan = a/b; 贝塞尔曲线： 阅读本文需要了解自定义View的基本流程和贝塞尔曲线的绘制。 好，进入正题，我们先看一下它的运行效果： emmmmm,效果感觉还不错~ 实现原理既然是拖动，肯定是基于Touch事件来实现的，通过Touch的Y坐标获取到拖动进度progress,然后通过requestLayout方法不断重绘界面，在onSizeChanged方法中通过计算不断移动圆心坐标，圆的左右两边是经典的贝塞尔曲线，只要获取到控制点和结束点的坐标就能绘制出来，通过控制点的不断移动和onDraw方法中的画布的不断移动来达到弹性和顶部两个起始点向中心靠拢的效果，中间的圆心与旁边的间距部分则是使用的drawable的Bounds效果,回弹则是利用的属性动画的addUpdateListener接口将progress数值由大到小执行回去从而达到的回弹效果 具体分析光看原理肯定是四脸蒙蔽，还是结合代码分析才能达到事半功倍的效果。我们先看OnTouch部分的代码：123456789101112131415161718192021222324252627findViewById(R.id.ll_mainLayout).setOnTouchListener(new View.OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; int actionMasked = event.getActionMasked(); switch (actionMasked) &#123; case MotionEvent.ACTION_DOWN: mTouchStartY = event.getY(); return true; case MotionEvent.ACTION_MOVE: float y = event.getY(); if (y &gt;= mTouchStartY) &#123; //表示向下移动 float moveSize = y - mTouchStartY; float progress = moveSize &gt; TOUCH_MOVE_MAX_Y ? 1 : moveSize / TOUCH_MOVE_MAX_Y; //计算进度值 touchView.setProgress(progress); return true; &#125; break; case MotionEvent.ACTION_UP: touchView.release(); return true; default: break; &#125; return false; &#125; &#125;); 这里还是比较简单，通过getY获取滑动的距离，按下去有一个点，滑动后有一个点，两点之间的距离就是我们的moveSize了，由于progress是指当前滑动的进度值，取值肯定是在0~1之间，因此，当moveSize大于我们预设的最大值时，progress就返回1，否则就返回具体的进度值，最后在设置给touchView，touchView就会进行重绘。 再来看下TouchPullView里面的代码：我们先看一下变量：1234567891011121314private Paint mCirclePaint = new Paint(Paint.ANTI_ALIAS_FLAG); private float mCircleRadius = 50; //圆的半径 private float mCirclePointX, mCirclePointY; //圆心坐标 private int mDargHeight = 400; //最大可下拉的高度 private float mProgress; //下拉进度值 private int mTargetWidth = 400; //目标宽度 private Path mPath = new Path(); //贝塞尔路径 private Paint mPathPaint = new Paint(Paint.ANTI_ALIAS_FLAG); //贝塞尔画笔 private int mTargetGravityHeight = 10; //重心点最终高度，决定控制点的Y坐标 private int mTargetAngle = 105; //角度变换 0~135 private Interpolator mProgessInterpolator = new DecelerateInterpolator(); //一个由快到慢的插值器 private Interpolator mTanentAngleInterpolator; private Drawable content = null; //中心圆drawable private int mContentDrawableMargin = 0; //中心圆Drawable边距 大部分变量都简洁明了，mTargetGravityHeight规定了控制点上下浮动的最大距离，该值越大，控制点越往下移，mTargetAngle规定了结束点与圆心连线的那个角度的最大变幻值，因为不规定可以看到结束点会围绕圆心做圆环运动，最终导致变形，这不是我们希望看到的。mTargetWidth则规定了该控件能缩小的最小宽度。 接下来看onDraw()方法的实现：12345678910111213141516171819202122@Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); //基础坐标系改变 int count = canvas.save(); //获取平移画布的X的值,随着下滑起始点的坐标移动 final float transX = (getWidth() - getValueByLine(getWidth(), mTargetWidth, mProgress)) / 2; canvas.translate(transX, 0); //绘制贝塞尔 canvas.drawPath(mPath, mPathPaint); //画圆 canvas.drawCircle(mCirclePointX, mCirclePointY, mCircleRadius, mCirclePaint); //绘制Drawable Drawable drawable = content; if (drawable != null) &#123; canvas.save(); canvas.clipRect(drawable.getBounds()); drawable.draw(canvas); canvas.restore(); &#125; canvas.restoreToCount(count); &#125; getValueByLine方法的作用是获取某一时刻贝塞尔曲线上的点的坐标，看一下它的方法实现：1234567891011/** * 获取某一时刻的值 * * @param star 起始点 * @param end 结束点 * @param mProgress 当前进度值 * @return */ private float getValueByLine(float star, float end, float mProgress) &#123; return star + (end - star) * mProgress; &#125; 它就是一个贝塞尔曲线公式Bt = P0+(P1-P0)*t，传入初始坐标P0和结束坐标P1和时间t，就能获取到Bt了。接着它得到了一个transX,它等于起始点与屏幕左右的距离，通过画布的移动来实现起始点不断靠拢的效果，接下来是绘制贝塞尔曲线，画圆，根据Bounds大小添加Drawable到画布上。 接下来分析我们的重点：onSizeChanged中的实现,关键是这个方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** * 更新路径 */ private void updatePathLayout() &#123; final float progress = mProgessInterpolator.getInterpolation(mProgress); //获取所有的可绘制的宽/高 此值会根据progress不断的变化 final float w = getValueByLine(getWidth(), mTargetWidth, mProgress); final float h = getValueByLine(0, mDargHeight, mProgress); //圆心X坐标 final float cPointX = w / 2; //半径 final float cRadius = mCircleRadius; //圆心Y坐标 final float cPaintY = h - cRadius; //控制点结束Y的值 final float endPointY = mTargetGravityHeight; //更新圆心坐标 mCirclePointX = cPointX; mCirclePointY = cPaintY; final Path path = mPath; path.reset(); //重置 path.moveTo(0, 0); //坐标系是以最左边的起始点为原点 float lEndPointX, lEndPointY; //结束点的X,Y坐标 float lControlPointX, lControlPointY; //控制点的X，Y坐标 //获取当前切线的弧度 double angle = mTanentAngleInterpolator.getInterpolation(progress) * mTargetAngle;//获取当前的角度 double radian = Math.toRadians(angle); //获取当前弧度 float x = (float) (Math.sin(radian) * cRadius); //求出“股”的长度（长的那条直角边） float y = (float) (Math.cos(radian) * cRadius); //求出“勾”的长度（短的那条直角边） lEndPointX = cPointX - x; //以起始点为原点，x坐标就等于圆的X坐标减去股的长度 lEndPointY = cPaintY + y; //以起始点为原点，y坐标就等于圆的y坐标加上勾的长度 lControlPointY = getValueByLine(0, endPointY, progress);//获取控制点的Y坐标 float tHeight = lEndPointY - lControlPointY; //结束点与控制点的Y坐标差值 float tWidth = (float) (tHeight / Math.tan(radian)); //通过计算两个角度是相等的，因此弧度依旧适用 lControlPointX = lEndPointX - tWidth; //结束点的x - ‘勾’ 的长度求出了控制点的X坐标 path.quadTo(lControlPointX, lControlPointY, lEndPointX, lEndPointY); //画左边贝塞尔曲线 path.lineTo(cPointX + (cPointX - lEndPointX), lEndPointY); //左右两个结束点相连 path.quadTo(cPointX + (cPointX - lControlPointX), lControlPointY, w, 0); //画右边贝塞尔曲线 updateContentLayout(cPointX, cPaintY, cRadius); &#125; /** * 测量并设置中心Drawable * * @param cx * @param cy * @param radius */ private void updateContentLayout(float cx, float cy, float radius) &#123; Drawable drawable = content; if (drawable != null) &#123; int margin = mContentDrawableMargin; int l = (int) (cx - radius + margin); int r = (int) (cx + radius - margin); int t = (int) (cy - radius + margin); int b = (int) (cy + radius - margin); drawable.setBounds(l, t, r, b); &#125; &#125; 其中每一行我都备注了注释，要理解其中的计算，就得先上个图： 我们脑海中要有一个清晰的定义，整个坐标系是基于起始点为原点，向右下延伸X，Y轴，左右的贝塞尔曲线是由一支画笔完成,通过lineTo相连接，因此整个曲线呈V字形。接下来看代码：首先求得了progress，这个无需解释，使用加速器只是为了更好的效果。接下来是w和h,这是控件的某一进度下的宽和高，为什么通过getValueByLine方法就能得到呢？请看输入的参数，起始点是getWidth，也就是整个屏幕的宽度，终点是mTargetWidth也就是我们规定的最小宽度，而getValueByLine正好是求得某一时刻的贝塞尔值，因此将progress输入正好求得从整个屏幕运动到最小宽度之间的某一个宽度，高度同理。宽高求出来了那个圆心的坐标也就相应出来了，注意整个圆的大小包含margin值，也就是圆与左右两边的边距也是包含的。因为mTargetGravityHeight是我们设定的控制点下移的高度，因此也就是控制点Y的坐标。因为quadTo方法需要控制点的坐标和结束点的坐标，因此求出这两个点的坐标就大功告成了，接下来就是数学知识了。首先，通过插值器的方法获得了某一时刻的角度，最后通过Math方法得到了弧度,也就是图中b的角度，半径我们是知道的，所以通过sin可以得出图中x的长度，然后通过半径的x坐标减去x的长度就得到了结束点的x坐标。通过cos我们可以得到y的长度,圆心Y的坐标加上y的坐标就得到了结束点y的坐标，lEndPointX，lEndPointY的值也就得到了。因为我们已知控制点上下运行的起始值和最大值，因此我们可以使用getValueByLine获取到当前的y坐标，接下来只需要求出控制点的x坐标就行了,tHeight表示左边这条直角的长直角边，结束点的y坐标已知，控制点的y坐标已知，因此可以求出tHeight。因为平行线间的角度相等，因此a = c，又因为c+d = e+d = 90; 所以c = e；所以a = e;tHeight已知，e已知，所以tWidth的值就能求出来了。所以控制点的x坐标就等于结束点的x坐标减去tWidth。至此所有的坐标都已经求出来了，所以贝塞尔曲线也就能绘制出来了。 接下来还有个测量的过程，逻辑比较简单：12345678910111213141516171819202122232425262728293031323334@Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; int MIN_W = (int) (mCircleRadius * 2 + getPaddingLeft() + getPaddingRight()); //需要的最小宽度 int MIN_H = (int) ((mDargHeight * mProgress + 0.5f) //mDargHeight * mProgress = moveSize(即actionMove.getY - actionDown.getY),+0.5f为四舍五入 + getPaddingBottom() + getPaddingTop()); int widthMeasure = getMeasureSize(widthMeasureSpec, MIN_W); int heightMeasure = getMeasureSize(heightMeasureSpec, MIN_H); setMeasuredDimension(widthMeasure, heightMeasure); &#125; /** * 获取所需要的宽/高的测量结果 * * @param Spec 测量模式 * @param minValue 规定的最小值 * @return 测量结果 */ private int getMeasureSize(int Spec, int minValue) &#123; int result; int mode = MeasureSpec.getMode(Spec); int size = MeasureSpec.getSize(Spec); switch (mode) &#123; case MeasureSpec.AT_MOST: //wrap_content result = Math.min(size, minValue); //取测量值和规定的最小宽度中的最小值 break; case MeasureSpec.EXACTLY: //match_parent or exactly num result = size; break; default: //其余情况取最小值 result = minValue; break; &#125; return result; &#125; 我将视频中的代码做了一下简单的封装，代码中有详细的注释，我这里就不做分析了。 整个分析流程就到这，如果有错误的地方，欢迎指正，Thanks~]]></content>
      <categories>
        <category>Android基础进阶</category>
        <category>安卓特效合集解析</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓View体系-View的工作流程]]></title>
    <url>%2F%E5%AE%89%E5%8D%93View%E4%BD%93%E7%B3%BB-View%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.html</url>
    <content type="text"><![CDATA[自定义View三部曲：onMeasure –&gt; onLayout –&gt;onDraw,本文着重解析前两个方法 onMeasure1234@Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); &#125; 提到这个方法，就必须先了解MeasureSpec这个类，它有一个getMode和getSize方法，用于获取SpecMode和SpecSize,那么这两个参数又是何物呢？请看以下一般自定义View的完整实现：1234567891011121314151617181920@Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(),widthMeasureSpec),getDefaultSize(getSuggestedMinimumHeight(),heightMeasureSpec)); &#125; public static int getDefaultSize(int size,int measureSpec)&#123; int result = size; int SpecMode = MeasureSpec.getMode(measureSpec); int SpecSize = MeasureSpec.getSize(measureSpec); switch (SpecMode)&#123; case MeasureSpec.UNSPECIFIED: result = size; break; case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: result = SpecSize; break; &#125; return result; &#125; 可以看到，SpecMode是指测量的模式，它有三种模式： UNSPECIFIED代表父容器不对View有任何的大小限制，一般用于系统的内部，很少用到 AT_MOST代表父容器指定了一个大小即SpecSize,View的大小不能大于这个值，它对应于LayoutParams中的wrap_content，结合它你就很好理解了 EXACTLY父容器已经检测到了view所需的精确大小，这时的view的最终大小就是SpecSize中的值，它对应于LayoutParam中的match_parent或者具体的数值 而SpecSize是指某种模式下的规格大小。 因此，结合此方法，当view的大小是wrap_content或者是match_parent或者是具体的数值时，都是使用的父容器给子view测量的specsize的值，当父容器对子view没有任何约束时，给view一个所规定的最小值（getSuggestedMinimum…方法获取）,setMeasuredDimension就是用来设置view的测量大小的。MeasureSpec类的值的获取是由父容器的MeasureSpec和自身的LayoutParams来共同确定的，MeasureSpec一旦确定，onMeasure中就可以确定view的测量宽高了。 这里再来讲解一下getSuggestedMinimumWidth这类方法，它的逻辑是这样的：如果View没有设置背景，那么它会返回minWidth设置的值，可以为0，如果view设置了背景，那么它会返回minWidth和背景最小宽度的两者之间的最大值。 一般的自定义View我们主要是着重处理AT_MOST模式的值，需要根据实际的情况来，没有固定的依据，有兴趣的可以看下TextView等控件的源码是怎么处理的。 Activity中View的宽/高获取通过以上分析读者已经知道View的宽高是需要父容器去测量的，因此我们如果在onCreate或者onStar方法中去获取View的宽高发现并不能保证百分百获取到，那么有什么方法能解决这个问题呢，以下有4个方法能解决这个问题： 1.onWindowFocusChanged当Activity的窗口得到焦点或失去焦点都会被调用一次,并且此时View已经初始化完毕，因此此时去获取View的宽高是没问题的1234567@Override public void onWindowFocusChanged(boolean hasFocus) &#123; super.onWindowFocusChanged(hasFocus); if (hasFocus)&#123; int width = view.getMeasuredWidth(); &#125; &#125; 2.view.post(runnable)通过post可以将一个runnable投递到消息队列的尾部，然后等待Looper调用此runnable的时候，view此时也已经初始化好了。123456view.post(new Runnable() &#123; @Override public void run() &#123; int width = view.getMeasuredWidth(); &#125; &#125;); 3.ViewTreeObserver使用ViewTreeObserver这个类的回调可以完成，比如OnGlobalLayoutListener，当View树的状态改变或者内部view的可见性发生改变时，该接口会被回调，注意，此接口会回调多次。12345678final ViewTreeObserver viewTreeObserver = view.getViewTreeObserver(); viewTreeObserver.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() &#123; @Override public void onGlobalLayout() &#123; view.getViewTreeObserver().removeOnGlobalLayoutListener(this); int width = view.getMeasuredWidth(); &#125; &#125;); 4.view.measure(int widthMeasureSpec, int heightMeasureSpec)手动对view进行测量来得出view的宽高，这种实现比较的复杂，需要看view的LayoutParam： match_parent无法得出View的宽/高，因为此种情况需要获取到父容器的剩余空间，而此时我们是获取不到的 具体的数值比如宽/高都是50px,那么我们可以这样写来获取：123int widthMeasureSpec = View.MeasureSpec.makeMeasureSpec(100, View.MeasureSpec.EXACTLY);int heightMeasureSpec = View.MeasureSpec.makeMeasureSpec(100,View.MeasureSpec.EXACTLY);view.measure(widthMeasureSpec,heightMeasureSpec); wrap_content123 int widthMeasureSpec = View.MeasureSpec.makeMeasureSpec((1&lt;&lt;30)-1, View.MeasureSpec.AT_MOST);int heightMeasureSpec = View.MeasureSpec.makeMeasureSpec((1&lt;&lt;30)-1,View.MeasureSpec.AT_MOST); view.measure(widthMeasureSpec,heightMeasureSpec); 注意(1&lt;&lt;30)-1这个值，通过查看源码可以知道View的尺寸是使用的30位二进制表示，所以最大值是30个1（2^30-1），也就等于（1&lt;&lt;30）-1，所以给出这个数值是合理的。 onLayoutonLayout方法是ViewGroup用来给子元素确定位置的，相比如onMeasure方法，onLayout则简单多了：1234@Override protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; super.onLayout(changed, left, top, right, bottom); &#125; 后四个参数分别代表左，上，右，下，只需返回不同的坐标即可确定View的位置。]]></content>
      <categories>
        <category>Android基础进阶</category>
        <category>安卓View体系</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓View体系:View的一些基本知识点]]></title>
    <url>%2F%E5%AE%89%E5%8D%93View%E4%BD%93%E7%B3%BB-View%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E7%82%B9.html</url>
    <content type="text"><![CDATA[安卓开发中熟练使用自定义View是开发者必备的技能，因为安卓原生控件很多时候是不能满足需求的，而自定义控件能做出各种绚丽的效果,用于满足产品各种奇怪的需求(我为什么要用奇怪呢，哈哈哈哈)。 自定义View要掌握的内容自定义View主要是掌握以下五个内容： 绘制原理: 掌握onMeasure,onLayout,onDraw及相关类的使用。 事件传递：掌握dispathTouchEvent(),onInterceptEvent(),onTouchEvent()三者的传递逻辑. 动画：属性动画，用于对View进行动画操作 相关手势：GestureDetector，VelocityTracker等类的应用 滑动：滑动的三种实现方法，Scroller的运用 自定义View的基本知识自定义View的分类1. 直接继承View主要用于实现一些不规则的效果，不能通过现有控件扩展的一些效果 2. 继承自viewGroup主要是为了实现自定义的布局，这个布局里包含了一些特定的控件，很像几个view组合在一起 3.继承特定的view主要是为了扩展已有view的功能，比如TextView等 4.继承特定的ViewGroup为了扩展特定的布局，比如LinearLayout 自定义控件的构造函数建立一个class类继承自View,实现它的所有的构造方法，那么这个类就是一个可以在xml中使用的自定义View，以下是关于它的构造方法的代码：123456789101112131415161718192021222324252627package com.jie.demo_01.View;import android.content.Context;import android.support.annotation.Nullable;import android.util.AttributeSet;import android.view.View;public class mView extends View &#123; public mView(Context context) &#123; //在代码中直接new出这个实例会调用这个方法 super(context); &#125; public mView(Context context, @Nullable AttributeSet attrs) &#123; //在xml中实现会调用这个方法（未指定style） super(context, attrs); &#125; public mView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; //为view指定了一个style super(context, attrs, defStyleAttr); &#125; public mView(Context context, @Nullable AttributeSet attrs, int defStyleAttr, int defStyleRes) &#123; //api&gt;21时调用，一般不用实现 super(context, attrs, defStyleAttr, defStyleRes); &#125;&#125; 关于构造函数中参数的含义： AttributeSet set: 属性值的集合. int[] attrs: 我们自定义属性集合在R类中生成的int型数组.这个数组中包含了自定义属性的资源ID. int defStyleAttr: 这是当前Theme中的包含的一个指向style的引用.当我们没有给自定义View设置declare-styleable资源集合时,默认从这个集合里面查找布局文件中配置属性值.传入0表示不向该defStyleAttr中查找默认值. int defStyleRes: 这个也是一个指向Style的资源ID,但是仅在defStyleAttr为0或者defStyleAttr不为0但Theme中没有为defStyleAttr属性赋值时起作用. 属性赋值优先级次序表:在布局xml中直接定义 &gt; 在布局xml中通过style定义 &gt; 自定义View所在的Activity的Theme中指定style引用 &gt; 构造函数中defStyleRes指定的默认值 自定义view的xml赋值我们经常可以看到使用xml的属性可以为view进行各种赋值,那么是怎么做到的呢，如图，在values目录下新建一个attrs.xml的文件，文件内容如下：12345&lt;resources&gt; &lt;declare-styleable name="mView"&gt; &lt;attr name="mview_color" format="color"/&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 我在这里声明了一个mview_color属性，用于定义颜色值，format代表属性的格式，有许多，读者查阅文档即可了解。 接下来,我在View中做如下处理：123456789101112131415161718public class mView extends View &#123; int defultColor = 0xFFFFFF6; int mColor; public mView(Context context) &#123; this(context,null); &#125; public mView(Context context, @Nullable AttributeSet attrs) &#123; this(context, attrs,0); &#125; public mView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); TypedArray t = context.obtainStyledAttributes(attrs, R.styleable.mView); mColor = t.getColor(R.styleable.mView_mview_color,defultColor); t.recycle(); //记得回收 &#125;&#125; 使用TypedArray来解析我们定义的属性,接着就赋值给我们的变量，最后回收，这样解析工作就完成了 接下来我们在xml中使用我们的View:123456789101112131415&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" //为了使用自定义属性，必须作此声明，app可以换成其他的名字 xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context="com.jie.demo_01.MainActivity"&gt; &lt;com.jie.demo_01.View.mView android:layout_width="match_parent" android:layout_height="100dp" app:mview_color="@color/colorAccent" //声明我们的自定义属性 /&gt;&lt;/LinearLayout&gt; 自定义view的绘制属性已经定义好了，接下来就是如何使用了，在这里我们重写它的onDraw方法：123456789101112131415161718192021222324252627282930public class mView extends View &#123; int defultColor = 0xFFFFFF6; int mColor; private Paint mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); public mView(Context context) &#123; this(context,null); &#125; public mView(Context context, @Nullable AttributeSet attrs) &#123; this(context, attrs,0); &#125; public mView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); TypedArray t = context.obtainStyledAttributes(attrs, R.styleable.mView); mColor = t.getColor(R.styleable.mView_mview_color,defultColor); t.recycle(); //记得回收 init(); &#125; private void init() &#123; mPaint.setColor(mColor); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawCircle(200,200,100,mPaint); //绘制一个位于200，200处的半径为100的圆 &#125;&#125; onDraw方法是view绘制图形图像的地方，通过画布（canvas）和画笔（paint）来灵活的绘制各种图形，这两个类所包含的方法多而全，读者可以多阅读文档来练习绘制各种图形,代码运行如图所示： 自定义View的注意事项上面的自定义view并不是一个标准的自定义view,标准的自定义view还应该包含onMeasure和onLayout的处理，让其支持wrap_content。 这里要注意了： 直接继承view或者viewgroup的控件不支持wrap_content,需要在onMeasure中进行特殊的处理才能达到预期的效果 如果有必要的话，需要在draw方法中处理padding，使view控件的padding生效，否则padding是无效的 尽量不在view中使用handler,因为view本身自带了post方法 如果在view中有线程或者动画，要及时关闭，关闭的时机是onDetachedFromWindow方法，当包含此view的Activity退出或者view被remove掉时，此方法会被调用 不要再onDraw方法中作初始化操作，因为这个方法会绘制多次，会产生很多不必要的开销 当View有滑动嵌套的情况，要处理好滑动冲突]]></content>
      <categories>
        <category>Android基础进阶</category>
        <category>安卓View体系</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓IPC机制:AIDL通信的使用和理解]]></title>
    <url>%2F%E5%AE%89%E5%8D%93IPC%E6%9C%BA%E5%88%B6-AIDL%E9%80%9A%E4%BF%A1%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E7%90%86%E8%A7%A3.html</url>
    <content type="text"><![CDATA[使用情景虽然Messenger对AIDL做了封装使其变得更易用，但Messenger只能一个一个的处理接收的数据,当有大量并发的数据涌入时，Messenger就显得不那么合适了,并且Messenger只能用来传递消息，如果需要调用跨进程的方法怎么办呢，这是，AIDL就派上用场了。 使用方法首先创建一个AIDL文件,在里面声明一些需要用到的方法接口，注意，并不是所有的数据类型在AIDL中都能使用，AIDL能够使用的数据类型如下: 基本数据类型 String,CharSequence ArrayList,里面包含的元素必须支持AIDL HashMap,里面包含的key和value必须被AIDL支持 Parcelable,所有实现了Parcelable接口的对象 AIDL接口本身也支持 123456789// IBookManager.aidlpackage com.jie.demo_01;import com.jie.demo_01.Book;// Declare any non-default types here with import statementsinterface IBookManager &#123; List&lt;Book&gt; getBookList(); void addBook(in Book book);&#125; 可以看到，我在里面引入了Book实体类，按照AIDL的规则，是需要再创建一个Book.aidl文件的，并且需要手动将引入路径导入123// Book.aidl.aidlpackage com.jie.demo_01;parcelable Book; 需要注意的是，AIDL中每个实现了Parcelable接口的类都需要按照这种方式创建相应的文件并且申明该类为Parcelable，并且，AIDL中除了基本数据类型，其他的参数都必须标上方向： in 表示输入型的参数 out 表示输出型的参数 inout 表示输入输出型参数并且AIDL不支持声明静态变量。 下面是远程服务端的实现:123456789101112131415161718192021222324252627282930313233343536373839404142package com.jie.demo_01;import android.app.Service;import android.content.Intent;import android.os.Binder;import android.os.IBinder;import android.os.RemoteException;import android.support.annotation.Nullable;import java.util.List;import java.util.concurrent.CopyOnWriteArrayList;public class mService extends Service &#123; private CopyOnWriteArrayList&lt;Book&gt; mBookList = new CopyOnWriteArrayList&lt;&gt;(); //支持并发读写的一个类，非Arraylist private Binder mbinder = new IBookManager.Stub() &#123; @Override public List&lt;Book&gt; getBookList() throws RemoteException &#123; return mBookList; &#125; @Override public void addBook(Book book) throws RemoteException &#123; mBookList.add(book); &#125; &#125;; @Nullable @Override public IBinder onBind(Intent intent) &#123; return mbinder; &#125; @Override public void onCreate() &#123; super.onCreate(); mBookList.add(new Book(1,"Kotlin实战")); mBookList.add(new Book(2,"编程珠玑")); mBookList.add(new Book(3,"Java数据与结构算法解析")); &#125;&#125; 服务端的实现比较简单，主要是通过IBookManager.Stub来获取Binder对象并实现定义的方法,最后在onBind中绑定`Binder对象,其中，IBookManager这个类是自动生成的，位于gen目录的aidl文件夹中,关于该类稍后再做分析。 以下是客户端的实现,也比较简单:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.jie.demo_01;import android.content.ComponentName;import android.content.Intent;import android.content.ServiceConnection;import android.os.Bundle;import android.os.IBinder;import android.os.RemoteException;import android.support.v7.app.AppCompatActivity;import android.util.Log;import java.util.List;public class MainActivity extends AppCompatActivity &#123; private ServiceConnection mConnection = new ServiceConnection() &#123; //Ibind监听，注意绑定是异步的 @Override public void onServiceConnected(ComponentName componentName, IBinder iBinder) &#123; //当与Service建立连接时调用 IBookManager manager = IBookManager.Stub.asInterface(iBinder); //获取AIDL管理类 //得到数据 try &#123; List&lt;Book&gt; bookList = manager.getBookList(); //这里实际上就是调用了Binder中的方法 Log.i("hj","从服务端获取的集合大小:"+bookList.size()); if (bookList.size()&gt;0)&#123; Log.i("hj","第一个书名是:"+bookList.get(0).bookName); &#125; &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onServiceDisconnected(ComponentName componentName) &#123; //与Service意外中断时调用 &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Intent intent = new Intent(MainActivity.this,mService.class); bindService(intent,mConnection,BIND_AUTO_CREATE); &#125; @Override protected void onDestroy() &#123; unbindService(mConnection); super.onDestroy(); &#125;&#125; 运行后打印如下：1212-09 17:05:46.447 19690-19690/? I/hj: 从服务端获取的集合大小:312-09 17:05:46.448 19690-19690/? I/hj: 第一个书名是:Kotlin实战 运行原理是通过IBookManager.Stub.asInterface方法获取到IBookManager,从而调用里面的方法来实现数据的传递与方法之间的调用，注意，这些方法都是运行在UI线程中的，所以不能有耗时的操作，如果有耗时的操作，应该新开启一个线程来解决。 还有一点需要注意的是，如果有类似于订阅者的实现，在进程通信中，不能简单的用List来管理接口，因为进程中的对象传输后其实变成了两个不同的对象，那么订阅和取消订阅将会失效，因此，系统提供了一个叫RemoteCallbackList的接口专门用来管理跨进程的接口，它的使用也很简单： beginBroadcast()方法会返回该类里所有集合的大小 getBroadcastItem(int position) 返回指定的item finishBroadcast() 结束遍历 通过以上三个方法可以循环遍历订阅者接口来达到取消订阅的目的。注意beginBroadcast和finishBroadcast必须配对使用 IBookManager 类分析通过以上的AIDL实现，我们发现了IBookManager类起到了制关重要的作用,所以我们来深入观察一下该类，理解了该类有助于我们更好的使用AIDL.以下是该类的源码。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133/* * This file is auto-generated. DO NOT MODIFY. * Original file: D:\\MyWork\\Studio_Work\\demo_01\\app\\src\\main\\aidl\\com\\jie\\demo_01\\IBookManager.aidl */package com.jie.demo_01;// Declare any non-default types here with import statementspublic interface IBookManager extends android.os.IInterface &#123; /** * Local-side IPC implementation stub class. */ public static abstract class Stub extends android.os.Binder implements com.jie.demo_01.IBookManager &#123; private static final java.lang.String DESCRIPTOR = "com.jie.demo_01.IBookManager"; /** * Construct the stub at attach it to the interface. */ public Stub() &#123; this.attachInterface(this, DESCRIPTOR); &#125; /** * Cast an IBinder object into an com.jie.demo_01.IBookManager interface, * generating a proxy if needed. */ public static com.jie.demo_01.IBookManager asInterface(android.os.IBinder obj) &#123; if ((obj == null)) &#123; return null; &#125; android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) &amp;&amp; (iin instanceof com.jie.demo_01.IBookManager))) &#123; return ((com.jie.demo_01.IBookManager) iin); &#125; return new com.jie.demo_01.IBookManager.Stub.Proxy(obj); &#125; @Override public android.os.IBinder asBinder() &#123; return this; &#125; @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123; switch (code) &#123; case INTERFACE_TRANSACTION: &#123; reply.writeString(DESCRIPTOR); return true; &#125; case TRANSACTION_getBookList: &#123; data.enforceInterface(DESCRIPTOR); java.util.List&lt;com.jie.demo_01.Book&gt; _result = this.getBookList(); reply.writeNoException(); reply.writeTypedList(_result); return true; &#125; case TRANSACTION_addBook: &#123; data.enforceInterface(DESCRIPTOR); com.jie.demo_01.Book _arg0; if ((0 != data.readInt())) &#123; _arg0 = com.jie.demo_01.Book.CREATOR.createFromParcel(data); &#125; else &#123; _arg0 = null; &#125; this.addBook(_arg0); reply.writeNoException(); return true; &#125; &#125; return super.onTransact(code, data, reply, flags); &#125; private static class Proxy implements com.jie.demo_01.IBookManager &#123; private android.os.IBinder mRemote; Proxy(android.os.IBinder remote) &#123; mRemote = remote; &#125; @Override public android.os.IBinder asBinder() &#123; return mRemote; &#125; public java.lang.String getInterfaceDescriptor() &#123; return DESCRIPTOR; &#125; @Override public java.util.List&lt;com.jie.demo_01.Book&gt; getBookList() throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); java.util.List&lt;com.jie.demo_01.Book&gt; _result; try &#123; _data.writeInterfaceToken(DESCRIPTOR); mRemote.transact(Stub.TRANSACTION_getBookList, _data, _reply, 0); _reply.readException(); _result = _reply.createTypedArrayList(com.jie.demo_01.Book.CREATOR); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; return _result; &#125; @Override public void addBook(com.jie.demo_01.Book book) throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); try &#123; _data.writeInterfaceToken(DESCRIPTOR); if ((book != null)) &#123; _data.writeInt(1); book.writeToParcel(_data, 0); &#125; else &#123; _data.writeInt(0); &#125; mRemote.transact(Stub.TRANSACTION_addBook, _data, _reply, 0); _reply.readException(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; &#125; &#125; static final int TRANSACTION_getBookList = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0); static final int TRANSACTION_addBook = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1); &#125; public java.util.List&lt;com.jie.demo_01.Book&gt; getBookList() throws android.os.RemoteException; public void addBook(com.jie.demo_01.Book book) throws android.os.RemoteException;&#125; 可以看到该类的结构还是比较清晰的,首先，它申明了getBookList和addBook两个方法，显然这是我在aidl接口中申明的方法，接着，还申明了两个int型的id,TRANSACTION_getBookList 和TRANSACTION_addBook，这两个id是为了在transact过程中区分客户端请求的是哪个方法，接着，它申明了一个内部类Stub,它是一个Binder类，接着还申明了一个Stub的内部代理类，以上就是该类的结构。下面详细介绍一下各个方法的作用 首先是Stub 类的方法： asInterface(android.os.IBinder obj)传入一个Binder对象，转换成客户端所需要的AIDL接口类型的对象，这种转换是区分进程的，如果服务端和客户端是在一个进程中，那么该方法会返回Stub对象本身，如果是两个进程，那么会返回Stub.proxy对象。 adBinder返回Binder对象. onTransact（(int code, android.os.Parcel data, android.os.Parcel reply, int flags）该方法是返回一个boolean对象，运行在Binder线程池中，当客户端发起请求，远程会通过系统底层封装后由此方法处理。code参数可以确定客户端请求的方法是什么，data中能取出目标的参数，然后执行目标的方法，当执行完毕后，就向reply中写入返回值（如果有返回值的话），而返回的boolean对象，如果为false,那么客户端会请求失败，因此可以通过这个返回值做权限验证。 Proxy中的方法： getBookList此方法运行在客户端，当客户端远程调用此方法时，它会创建该方法所需要的输入型Parcel对象data,输出型Parcel对象,_reply和返回值对象List,然后将该方法的参数信息写入_data中（如果有参数的话）；接着调用transact方法来发起请求，同时当前线程挂起，然后服务端的onTransatct方法会被调用，直到远程调用返回，当前线程继续执行，并从_reply中取出远程调用过程的返回结果，最后返回_reply数据。 addBook同getBookList一样，因为没有返回值，所以不需要从_reply中取值 整体来说整个类还是易于理解的，大多其实都是偏底层的实现,需要注意的是,客户端通过接口方法发起请求时，当前线程会被挂起直到服务端返回数据，因此，如果一个远程的方法非常耗时，那么就不能在主线程中发起请求，需要另开一个线程。]]></content>
      <categories>
        <category>Android基础进阶</category>
        <category>安卓IPC机制</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓IPC机制:使用Messenger通信]]></title>
    <url>%2F%E5%AE%89%E5%8D%93IPC%E6%9C%BA%E5%88%B6-%E4%BD%BF%E7%94%A8Messenger%E9%80%9A%E4%BF%A1.html</url>
    <content type="text"><![CDATA[Messenger原理Messenger的底层实现是AILD，它是一个Message的载体，通过它可以在不同进程间传递message对象,从而实现数据传递 使用代码示例：首先创建一个Service，让它运行在一个单独的进程中123&lt;service android:name=".mService" android:process=":remote" /&gt; 然后再来看服务端12345678910111213141516171819202122232425262728293031323334public class mService extends Service &#123; private final Messenger messenger = new Messenger(new messengerHandler()); private static class messengerHandler extends Handler &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case Constants.MSG_FROM_CLIENT: String clientMsg = msg.getData().getString("msg"); //接收客户端的消息 Log.i("hj","从客户端接收到的消息:"+clientMsg); Messenger messenger = msg.replyTo; //获取客户端发来的Messenger Message replyMessage = Message.obtain(null,Constants.MSG_FROM_SERVICE); //创建一个新的Message对象 Bundle bundle = new Bundle(); bundle.putString("reply", "已收到客户端的消息，稍后回复~"); replyMessage.setData(bundle); try &#123; messenger.send(replyMessage); //发送消息给客户端 &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; break; default: super.handleMessage(msg); &#125; &#125; &#125; @Nullable @Override public IBinder onBind(Intent intent) &#123; return messenger.getBinder(); &#125;&#125; 创建一个Handler并且传入到Messenger对象中,通过Handler来接收Message对象发来的消息,并且在Service的onBind中返回这个Messager对象底层的Binder。随后我又通过msg.replyTo方法获取到从客户端发来的Messenger对象，用于回复消息给客户端,最后调用send方法发出消息，这样就完成了消息的接收与回复，接下来再看客户端的实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.jie.demo_01;import android.content.ComponentName;import android.content.Intent;import android.content.ServiceConnection;import android.os.Bundle;import android.os.Handler;import android.os.IBinder;import android.os.Message;import android.os.Messenger;import android.os.RemoteException;import android.support.v7.app.AppCompatActivity;import android.util.Log;public class MainActivity extends AppCompatActivity &#123; private Messenger messenger; //客户端发送消息的messenger private ServiceConnection mConnection = new ServiceConnection() &#123; //Ibind监听，注意绑定是异步的 @Override public void onServiceConnected(ComponentName componentName, IBinder iBinder) &#123; //当与Service建立连接时调用 messenger = new Messenger(iBinder); Message message = Message.obtain(null,Constants.MSG_FROM_CLIENT); Bundle bundle = new Bundle(); bundle.putString("msg","Service兄弟在吗，是否已收到回复"); message.setData(bundle); message.replyTo = replyMessager; //注意这一句，将客户端用于接受消息的Messager对象传递给Service try &#123; messenger.send(message); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onServiceDisconnected(ComponentName componentName) &#123; //与Service意外中断时调用 &#125; &#125;; private Messenger replyMessager = new Messenger(new GetReplyMessenger()); //客户端接收消息的messenger private static class GetReplyMessenger extends Handler&#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what)&#123; case Constants.MSG_FROM_SERVICE: String reply = msg.getData().getString("reply"); Log.i("hj","从Service接收到的消息:"+reply); break; default: super.handleMessage(msg); break; &#125; &#125; &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Intent intent = new Intent(MainActivity.this,mService.class); bindService(intent,mConnection,BIND_AUTO_CREATE); &#125; @Override protected void onDestroy() &#123; unbindService(mConnection); super.onDestroy(); &#125;&#125; 首先是绑定一个Service，接下来在绑定监听中创建一个Messager对象,通过Messager就可以发消息给服务端了,注意，我在这里通过replyTo发送了一个新的Messager对象给服务端，这样服务端就可以回复消息给客户端了，客户端也是通过Handler来接收消息的。 运行结果如下：112-09 11:16:07.733 7900-7900/com.jie.demo_01:remote I/hj: 从客户端接收到的消息:Service兄弟在吗，是否已收到回复 112-09 11:16:07.753 7871-7871/com.jie.demo_01 I/hj: 从Service接收到的消息:已收到客户端的消息，稍后回复~ 可以看到两个不同进程之间通信成功了]]></content>
      <categories>
        <category>Android基础进阶</category>
        <category>安卓IPC机制</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓IPC机制：使用文件共享]]></title>
    <url>%2F%E5%AE%89%E5%8D%93IPC%E6%9C%BA%E5%88%B6%EF%BC%9A%E4%BD%BF%E7%94%A8%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB.html</url>
    <content type="text"><![CDATA[原理通过两个进程间读/写同一个文件来交换数据示例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.jie.demo_01;import android.content.Intent;import android.os.Bundle;import android.os.Environment;import android.support.v7.app.AppCompatActivity;import android.view.View;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectOutputStream;public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; @Override protected void onResume() &#123; super.onResume(); initWriteToFile(); &#125; //点击跳转到SecondActivity public void start(View v)&#123; startActivity(new Intent(MainActivity.this,SecondActivity.class)); &#125; private void initWriteToFile()&#123; new Thread()&#123; @Override public void run() &#123; User user = new User(); user.userName = &quot;Hello World&quot;; File file = new File(getDiskCacheDir()); ObjectOutputStream oos = null; try &#123; oos = new ObjectOutputStream(new FileOutputStream(file)); oos.writeObject(user); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; if (oos!=null) oos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;.start(); &#125; public String getDiskCacheDir() &#123; String cachePath = null; if (Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState()) || !Environment.isExternalStorageRemovable()) &#123; cachePath = getExternalCacheDir().getPath()+&quot;/cache.txt&quot;; &#125; else &#123; cachePath = getCacheDir().getPath()+&quot;/cache.txt&quot;; &#125; return cachePath; &#125;&#125; SecondActivity代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.jie.demo_01;import android.os.Bundle;import android.os.Environment;import android.support.v7.app.AppCompatActivity;import android.util.Log;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.ObjectInputStream;public class SecondActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; @Override protected void onResume() &#123; super.onResume(); getCacheFromFile(); &#125; private void getCacheFromFile ()&#123; new Thread()&#123; @Override public void run() &#123; User user = null; File file = new File(getDiskCacheDir()); if (file.exists())&#123; ObjectInputStream ois = null; try &#123; ois = new ObjectInputStream(new FileInputStream(file)); user = (User) ois.readObject(); Log.i(&quot;TAG&quot;,user.userName); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;.start(); &#125; public String getDiskCacheDir() &#123; String cachePath = null; if (Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState()) || !Environment.isExternalStorageRemovable()) &#123; cachePath = getExternalCacheDir().getPath()+&quot;/cache.txt&quot;; &#125; else &#123; cachePath = getCacheDir().getPath()+&quot;/cache.txt&quot;; &#125; return cachePath; &#125;&#125; 运行后，打印出日志：112-08 13:13:30.372 17706-17723/com.jie.demo_01.remote I/TAG: Hello World 文件传值成功 文件传值并没有具体的要求，不管是通过txt,xml,等等都可以，需要注意的是文件的并发问题，要避免获取文件值得时候同时去修改文件，这样会造成数据的混乱。]]></content>
      <categories>
        <category>Android基础进阶</category>
        <category>安卓IPC机制</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓IPC机制：Bundle数据传递]]></title>
    <url>%2F%E5%AE%89%E5%8D%93IPC%E6%9C%BA%E5%88%B6%EF%BC%9ABundle%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92.html</url>
    <content type="text"><![CDATA[序列化与反序列化要实现进程之间的通信，序列化是通信的基础，所以先要了解下什么是序列化安卓实现序列化有两种方式：1. 实现Serializable接口，使用相当简单，这个是JAVA提供的方法，需要注意的是,该接口有一个serialVersionUID参数：1private static final long serialVersionUID = 1L ; 可以选择不实现，依旧可以序列化，但是会对反序列化产生影响，如果在反序列化的过程中类发生了变化，那么将会报错。AndroidStudio默认不检查serialVersionUID的实现，因此，可以手动开启它，这样系统就会自动帮你实现serialVersionUID。开启方法：Settings-&gt;Editor-&gt;Inspections-&gt;serialization issues-&gt;Serializable class without ‘serialVersionUID’ 勾上确认就可以 序列化对象也非常简单，通过ObjectOutputStream和ObjectInputStream即可轻松实现 2.实现Parcelable接口,这是Android提供的方法，实现该接口，系统会自动帮你实现需要的代码，Android中推荐使用该方法，因为效率比Serializable高，Serializable需要进行大量的I/O操作。以下是完整实现实例：1234567891011121314151617181920212223242526272829303132333435363738public class User implements Parcelable &#123; public int userId; public String userName; public boolean isMale; public Book book; protected User(Parcel in) &#123; userId = in.readInt(); userName = in.readString(); isMale = in.readByte() != 0; book = in.readParcelable(Book.class.getClassLoader()); &#125; public static final Creator&lt;User&gt; CREATOR = new Creator&lt;User&gt;() &#123; @Override public User createFromParcel(Parcel in) &#123; return new User(in); &#125; @Override public User[] newArray(int size) &#123; return new User[size]; &#125; &#125;; @Override public int describeContents() &#123; return 0; &#125; @Override public void writeToParcel(Parcel parcel, int i) &#123; parcel.writeInt(userId); parcel.writeString(userName); parcel.writeByte((byte) (isMale ? 1 : 0)); parcel.writeParcelable(book, i); &#125;&#125; 方法详解见下表： 方法 功能 标记位 createFromParce(Parcel in)l 从序列化的对象中创建原始对象 newArray 创建指定长度的原始对象数组 User(Parcel in) 从序列化的对象中创建原始对象 writeToParcel(Parcel parcel, int i) 将当前对象写入序列化结构中,其中 i有两种值，1代表当前对象需要作为返回值返回，不能立即释放资源， PARCELABLE_WRITE_VALUE describeContents 返回当前对象的内容描述，如果含有文件扫描符，返回1（参见右侧标记位），否则返回0 CONTENTS_FILE_DESCRIPTOR 实现了序列化，我们就可以很方便的通过Intent发送Bundle,这是一种简单的进程间通信的方法12345Bundle bundle = new Bundle(); bundle.putParcelable(&quot;User&quot;,new User()); Intent intent = new Intent(MainActivity.this, SecondActivity.class); intent.putExtra(&quot;data&quot;,bundle); startActivity(intent);]]></content>
      <categories>
        <category>Android基础进阶</category>
        <category>安卓IPC机制</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓IPC机制:多进程]]></title>
    <url>%2F%E5%AE%89%E5%8D%93IPC%E6%9C%BA%E5%88%B6-%E5%A4%9A%E8%BF%9B%E7%A8%8B.html</url>
    <content type="text"><![CDATA[什么是IPC IPC是指进程间通信或者跨进程通信，指两个进程之间交换数据的过程。而IPC使用的场景往往是在多进程之间进行通信。 Android开启多进程 通过给Activity指定android:process属性来开启多进程模式,如下示例，123456789101112131415161718192021&lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:roundIcon=&quot;@mipmap/ic_launcher_round&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/AppTheme&quot;&gt; &lt;activity android:name=&quot;.MainActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=&quot;.ThirdActivity&quot; android:process=&quot;:remote&quot; /&gt; &lt;activity android:name=&quot;.SecondActivity&quot; android:process=&quot;com.jie.demo_01.remote&quot; /&gt; &lt;/application&gt; 示例中实现了两种不同的写法，这两种写法是有区别的,当ThirdActivity启动，系统会单独开启一个叫com.jie.demo_01:remote的进程(com.jie.demo_01为包名),当启动SecondActivity,系统会单独开启一个叫com.jie.demo_01.remote的进程，其中，“：”代表要在当前进程名前面加上当前的包名，并且代表此进程为私有进程，其他应用不能和它跑在一个进程中，而没有”：”的为全局进程。SecondActivity的这种写法，是一种完整的命名方式，不会附加包名信息。 开启多进程的一些坑当一个Activity单独开启了一个进程，那么这个Activity就不能和别的进程的Activity共享数据了，只能通过IPC机制来传递数据。 例如我申明了一个静态变量 Userid = 1;我在MainActivity中把它改为了2，我在SecondActivity中开启了一个进程，我获取这个Userid，你会发现Userid还是1，这是因为Android会为每一个进程分配一个虚拟机，不同的虚拟机在内存分配上会有不同的地址空间，所以Userid会在不同的虚拟机上产生不同的副本，并且副本之间是互不干扰的,我在MainActivity中把它改为2，在SecondActivity中的副本是不会变得,可以理解为又新开启了一个应用，所以，一般来说，多进程之间会存在下列一些问题： 静态成员和单例模式无效 线程同步机制失效 SharedPreferences的存储结果变得不再可靠 Application会多次创建 为了解决这些问题，系统引入了IPC机制，用于在进程间共享和传递数据，IPC的方式主要有以下几种： 使用Bundle 使用文件共享 使用Messenger 使用AIDL 其中Messenger底层其实使用的AILD，AIDL其实是依靠Binder,下一章将详细介绍这几种方法。]]></content>
      <categories>
        <category>Android基础进阶</category>
        <category>安卓IPC机制</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity的生命周期和启动模式]]></title>
    <url>%2FActivity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[此系列文章为进阶类文章,快餐类记录文,用于自己安卓知识点的复习 典型情况生命周期 onCreate() :Activity被创建 onRestart() : 正在重新启动。调用场景：当前Activity从不可见到变为可见状态 onStart(): Activity正在启动,此时Activity已经可见，但还不能和用户交互 onResume() :此时Activity已经可见并开始活动 onPause() :Activity正在停止，如果是从此Activity退到上一个Activity,那么会先执行此Activity的onPause,再执行上一个Activity的onResume,所以此方法不能执行耗时的操作，不然会影响新Activity的显示 onStop() : Activity即将停止,紧接着onPause后面执行 onDestroy() : Activity即将销毁,在这里主要做一些资源的释放完整的启动流程是从上到下,有几个具体情况说明:1)第一次启动一个新的Activity: onCreate-&gt;onStart-&gt;onResume2)再次打开一个Activity或者切换到桌面：onPause -&gt;onStop (注：如果新的Activity是用的透明主题,那么不会回调onStop)3) 再次回到此Activity：onRestar -&gt;onStart -&gt;onResume4)退出此Activity (finish掉)：onPause -&gt;onStop -&gt;onDestroty 异常情况生命周期资源相关的系统配置发生了改变导致Activity被杀死并重新创建发生此种情况最典型的就是横竖屏的切换,因为系统会去拿两张不同的图片，这时，Activity就会重新创建,它的onPause,onStop,onDestroy都会被调用,同时因为Activity是在异常情况下终止的,所以系统会调用onSaveInstanceState来保存当前Activity的状态，这个方法会在onStop方法之前调用。当Activity创建完成,系统会调用onRestoreInstanceState，可以从这个方法里拿到bundle对象并恢复Activity的状态 资源不足导致Activity被杀死此种情况和第一类差不多，都可以通过以上两种方法来恢复数据 此外，我们还可以不让Activity重新创建,通过在清单文件中指定Activity的configChanges属性,通过这些属性,可以让我们在特定场景下Activity不会被重新创建,此时，如果我们进行了特殊的操作,Activity会调用onConfigurationChanged方法 Activity的启动模式1)standard： 默认模式，每次都打开一个新的Activity,例如ABCD四个Activity,A是最底的Activity,D是当前的栈顶Activity,通过D启动D，此时栈中的Activity就会变成ABCDD2）singleTop： 栈顶复用模式，例如ABCD四个Activity,用D启动D,栈中的Activity还是ABCD，D被复用了,并且D不会再次调用onCreate，而是会调用onNewIntent3)singleTask: 栈内复用模式,例如ABCD,通过D启动B，栈中的Activity为：ACDB,B不会被重新创建,并且B会放入到栈顶,如果是通过D启动E，那个栈中Activcity为ABCDE,因为E在栈中没有，系统会创建一个新的实例。复用的Activity依旧会调用onNewInternt4) 单实例模式，可以理解为加强版的singTask.此种模式不但拥有singTask的全部特性，而且是单独的位于一个任务栈中，例如A是此种模式，那个系统会创建一个新的任务栈，那么由于栈的复用特性，后续的请求都不会重新创建新的Activity，除非被系统销毁了 启动模式的设置1）通过清单文件的launchMode属性设置2）通过Intent设置标志位来指定1234Intent intent = new Intent();intent.setClass(A.this,B.class);intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);startActivity(intent); 两者的区别:第二种的优先级会高于第一种，第一种无法设置FLAG_ACTIVITY_CLEAR_TOP标识,第二种无法为Activity指定singleInstance模式。 Activity的FlagsFLAG_ACTIVITY_NEW_TASKsingleTask模式FLAG_ACTIVITY_SINGLE_TOPsingleTop模式FLAG_ACTIVITY_CLEAR_TOP设置了此模式，如果是singleTask模式启动,那么就会调用onNewIntent，如果是standard模式启动,那么位于此Activity栈上的所有Activity都要出栈FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS具有这个标记的Activity不会出现在列表中,等同于xml中的excludeFromRecents=true;]]></content>
      <categories>
        <category>Android基础进阶</category>
        <category>安卓Activity</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有哪些送给年轻人的建议或道理？]]></title>
    <url>%2F%E6%9C%89%E5%93%AA%E4%BA%9B%E9%80%81%E7%BB%99%E5%B9%B4%E8%BD%BB%E4%BA%BA%E7%9A%84%E5%BB%BA%E8%AE%AE%E6%88%96%E9%81%93%E7%90%86%EF%BC%9F.html</url>
    <content type="text"><![CDATA[序言：这篇文章，写给你们，也写给我自己，我自己会经常阅读这篇文章来激励自己，每当自己茫然，无措，不知道该干嘛时，我都会读一遍，这样我的脑海就会自动给自己罗列出一些事情来做，哈哈哈。希望对阅读这篇文章的你会有启发,我相信未来的你一定会感谢现在这么努力的自己！ 学习很重要！学习很重要！学习很重要！ 知识或者技能这种东西，学到了就跟你一辈子，不管工作或时空跨度多大，新知和技能都能排上用场，请不要感叹时光已逝，学习不易，人家老来考研的，甚是80岁学编程的都有，请不要为你的懒惰找借口。 习惯很重要！ 有人总是和我们说，要养成好的习惯。可没人跟我说重要到深度影响自己生活、人生选择和生命质量的程度。因为几乎大多数人，每时每刻都生活在形形色色的思维习惯、生活习惯中，比如健身、跑步、阅读、表达、写作、沟通、学习等等，所有影响我们生活工作结果的全是这些习惯。我们养成习惯，然后习惯养成我们。 学会学习他人优秀的品质围剿式学习，也就是吸星大法，通过观察对方的沟通、演讲、写作方式，从而学习他们的思维方式、学习他们身上最优秀的思维习惯,当你们把优秀的人身上优秀的品质学习下来，这就是成功！ 真诚和诚信真诚是领导力的真谛，诚信是商业的真谛，每个人的年薪、领导能力、商业成就全部都可以从这两个词汇里诠释,当你自己做老板你就会觉得这两个品质是多么的重要了。 要多陪陪家人年轻人可能心里想得更多的是幸福生活，但父母的年纪，他们年龄越大，越要去面临离开这一主题，他们担心被世界抛弃，担心自己在儿女生活中扮演不了什么重要价值，特别渴望回馈、关注和尊重，不管多忙，能多打一个电话就多打一个电话，能多在一起吃顿饭，就多在一起吃顿饭，能满足他们想要的，不管大小，尽量去满足。可能你没察觉的是，随着你的逐渐成长，你的父母正逼近死亡！ 不要熬夜睡眠其实真正决定了生命的效率。因为睡眠决定着第二天的心情、状态、专注度等，而心情、状态、专注度直接影响结果，我们的现在就是由大大小小的这些结果构成的。所以睡个好觉可能是让生活变得更好的最大的捷径。不要相信什么狗血成功剧经常熬夜就能成功，成功是讲究效率的。 保持自我，不断完善保持自我，并不断变得更好，其实在一段感情里，远比委曲求全，一味地宠溺对方，更重要。保持自我可以测试出和对方是否合拍，不断变得更好，可以让感情更深刻而持久。千万不要因为孤独、无助、父母逼迫、个人面子、焦虑等原因仓促地选择一个人。这个人是自己生命的一部分，对自己施加着无以复加地影响，所以谨慎点，即便单身都比错误好很多。 用感官去发现更美好的世界利用所有的感官去体验周遭的世界是那么重要，刻意发现生活的美，发现细微处的不同，会给自己带来很多小惊喜 接下来聊聊职场发展的,人要舍得投资自己，这样你才会越来越值钱 不要让专业限制你的选择许多人或许都是一些刚刚步入社会的学生，学生思维的一大局限就是觉得找工作应该专业要对口，实际上从我个人的观察来看，大学毕业后，同学中反倒是从事本专业的属于小众，我觉得造成这个现象的原因有：（1）一般来说，填高考志愿的时候，你报的专业未来到底能做什么工作，你的父母如果不太了解的话，你必定也不太了解，况且很多学生报的专业都是那种所谓的热门专业，或者父母给选的，或者父母从事的专业；（2）上大学后，真正的学了专业课后，你很有可能并不感兴趣，或者并不擅长；（3）除了少数对专业知识要求较高的理工科专业，大部分专业毕业后去公司实习完全可以搞明白工作流程。所以除了队技术要求较高的理工科职位，其他大多数职位，毕业去公司，通过实际工作中学习，是完全可以的，只要你做了感兴趣，并且擅长的工作，工作技能都是学的很快的，而且在公司里你不懂的问题可以直接问资历老的员工，比你自己在学校里上课效率高多了，我本科学计算机的，班里同学有从事媒体的，金融的，出版社的，房地产的，考公务员的，还有经商的，反正干啥的都有，只要是你感兴趣的，并且觉得自己能做好的职位，大可以一试。 不要怕犯错，年轻没有失败网上很多人说过要找自己擅长的工作，但是问题是，一份工作你没干之前，很难知道自己到底是否擅长，那这份擅长的工作或行业要怎么找呢？答案是：多去尝试不同的职业。大学刚毕业一两年，很有可能你目前从事的工作并不是你喜欢的，也不是你一辈子只能干这个，如果干的不开心，并且在公司里干的也不算出色，那么，很可能就是你不擅长这个行业，这个时候，仗着你年轻，你大可以辞职转行，30岁之前你的转行成本是很低的，因为你年轻，大部分公司都会给你一个面试的机会，等你过了30岁再想转行，也不是不可能，但是难度比20几岁的时候会高几个量级：（1）从公司的角度来看，公司更爱培养年轻人；（2）30岁很可能结婚了，上有老，下有小，转行的风险特别的高，就是找1个月工作，很多家庭的房贷就要断供了，导致这个年纪即使想转行，需要考虑的因素也会多很多。所以，最好的选择就是在你的25-30岁之间这5年里，找到你擅长的行业或领域，这5年内你干的不爽尽可以换，但是最好在30岁之前找到自己能做一生的职业，并且稳定下来。 好好利用下班的时间，5年后会给你带来巨大的改变20-25岁的年轻人，如果指望不上父母，只能靠自己奋斗的话，说难听点，你随后的几年是不应该有过多的娱乐生活的。道理很简单，在你没有过多的好的选择的时候，好好工作，升职加薪是你能做到的风险最小的选择（创业风险太高，不适合普通人），而决定你升职加薪的关键就是你的工作技能，所以如果你想30岁混个一官半职当个小主管，不想再当普通打工仔，那么，有效的利用下班时间好好的给自己充电是你必须要做的。而现代社会每个人白天得上至少八小时的班（不加班的企业真是良心），即使你有幸在一家不加班的企业工作，晚上下班挤地铁/公交到家吃完饭，洗完澡之后，怎么着也得8点了，如果你12点睡的话（基本已是极限，再晚睡会影响白天的工作），你一天中有效的连续学习时间就是4小时（这是比较乐观的估计，还有很多人通勤时间就得1个多小时，所以能有4个小时的学习时间的人真是很幸运），4小时，乍一看不少了，但是实际用起来，减掉中间休息一下的时间，你就会发现，是很紧凑的，而且一旦开始决定晚上学习，基本就不能隔三差五的和朋友出去浪了，因为就怕一出去，打破了学习惯性，心就散了，无心再耐心学习下去了，所以如果你决定给自己充电，几乎也就可以告别娱乐生活了，虽然这样的生活很苦，但是人生是需要规划的，若干年后，你应该感谢曾经那么的努力的自己。一辈子很长，25岁是你播种的时候，为的是未来的收获。 对工作的爱好最重要爱好是最重要的，你不爱的工作再赚钱你也会忧郁症的，到时候每天起床都没动力，毕竟工作是半辈子的事情。 定制自己的职业发展计划,明确自己要的是什么提前给自己定好计划，避免让自己像一个无头苍蝇般到处乱飞，明确自己想要的是什么，该如何去努力，对自己的财产也要有规划，多阅读一些关于金融理财类的书籍。 最后，再来一个毒鸡汤总结 这是一个带毒的总结在年轻的时候，即使你知道再多“人生的道理”，即使你下了再大的决心，即使你做了再周密的计划。你还是可能一事无成。因为你并没有坚持下来,道理你都懂，要干什么事儿也都知道，为什么你做不到？有谁认真想过? 我们之所以做不到，是因为大部分人，都无法把自己眼前的事或即将要做的事，和今后的收益联系起来,因为你坚持了一个月后,你可能就会想，我这样做真的有用吗？这时你就会彷徨，甚至惊恐，毕竟，隔山的金子不如铜:我又不靠写作吃饭,看那么多书有什么用呢?一个月就那么点钱,理财有什么用呢?已经长那样了,健身有什么用呢?我又不想出国、不考外交部、不去外企,你让我努力打卡学英语不是搞笑吗?………人往往就是这样,事到临头才会想到要抱佛脚。那么如何才能去坚持，其实我也没什么方法可言，道理你都懂了，做与不做都是你的一念之间,我只能告诉你一个道理需要你们自己去悟： 你要让你所有做的事情，随着时间发展产生变化 你需要的只是在年轻的时候多用时间做资本，去为未来做投资.就能在未来取得收益后，买下更重要的时间。人的一生很宝贵，酒足饭饱之余，不妨多想想，做点什么更有用的事，才能在阶层固化之前尽量往上多蹦一两个台阶 因为，相对于你今后的每一天，现在的你都是最年轻的你。好文链接： 【习惯】你培养习惯的方法可能是个假方法 你的所谓成熟，不过是精神早衰 —————————–希望生活善待如此努力的你❤—————————-]]></content>
      <categories>
        <category>感悟</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如何将个人域名与github绑定]]></title>
    <url>%2F%E5%A6%82%E4%BD%95%E5%B0%86%E4%B8%AA%E4%BA%BA%E5%9F%9F%E5%90%8D%E4%B8%8Egithub%E7%BB%91%E5%AE%9A.html</url>
    <content type="text"><![CDATA[购买个人域名例如我的是在阿里云万网购买的,点击进入域名列表,点击解析,会出现一个添加解析按钮，点开有记录类型，主机记录，解析线路，记录值，TTL值五个选项依次填写： 记录类型：A 主机记录：www 解析线路：不用选，就用默认 记录值：填写你的github网址的ip,可以用ip查询或ping查到，一般都是151开头。 TTL值：不用管，默认10分钟。 填写完毕后就可以关闭页面了 Github配置在你的io网站本地仓库中新建一个CHAME(注意都要大写)文件，没有后缀，打开编辑，将你的域名添加进入，例如我的就是www.huangjie.name,保存，关闭,将文件提交到远程仓库,这时github应该会发一封邮件给你代表配置成功，更改不会立即生效，一般10分钟左右 如果你是用的hexo，可以将CHAME文件建立在source文件夹中，这样通过Hexo提交到github不会被覆盖]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客使用心得]]></title>
    <url>%2Fhello-world.html</url>
    <content type="text"><![CDATA[欢迎来到黄杰的个人博客，这是我写入的第一篇博文,此博客平台采用 Hexo + githubPages搭建而成,搭建日期：2017/11/29。这篇博客将持续记录hexo使用过程中的一些问题 引言记录一些自己搭建的参考资料 http://blog.haoji.me/build-blog-website-by-hexo-github.html?from=xa https://hexo.io/zh-cn/docs/generating.html http://blog.csdn.net/poem_of_sunshine/article/details/2936978 http://blog.sunnyxx.com/2014/02/27/hexo_startup/ 常用命令进入项目主结构，使用git bash执行命令 监听文件变动 $ hexo g 开启本地服务 $ hexo s ，开启后在浏览器输入http://localhost:4000 即可访问 提交代码 $ hexo d ，需要配置deploy 在主项目目录下有个_config.yml,为全局配置文件,在themes文件夹里，存放着网站使用的主题文件，打开主题文件夹，里面也有个_config.yml，为主题配置文件，与主题相关的在这里配置，我现在采用的是Next主题 遇到的问题一.首页的文章内容全部显示出来了，没有“阅读全文”?解决办法有两种方法 第一种：在主题配置文件里(themes/next/_config.yml)用编辑器打开，找到12345# Automatically Excerpt. Not recommend.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: false length: 150 将 enable：false 改为true就行了，后面的length:150代表显示的文本字数。 第二种：直接在编辑的.md文件里将要预览的文字后面加上&lt;!--more--&gt;,这样之前的就是预览的文字,后面的就不会显示了 二.如何将README.md文件传到github而不被编译成html在Hexo目录的source目录在建立一个README.md文件,修改Hexo目录的_config.yml配置,找到 skip_render参数设置,后面加上 README.md,关闭保存,之后编译就不会渲染README.md这个文件了 三.百度搜索引擎不能收录自己的网站地址原因是github屏蔽了百度的spider爬虫,导致百度不能收录,解决办法是使用coding来托管国内的流量访问,具体的方法可以参考这篇博文:hexo高阶教程：想让你的博客被更多的人在搜索引擎中搜到吗？ 写作技巧记录一.如何将md文件以时间命名 在_config.yml中找到new_post_name,修改名称为:year-:month-:day-:title.md,这样创建的文件就会以电脑时间命名，使用时间命名可以更方便的管理文章]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[About Me Android 小生一枚，轻微强迫症患者，非处女座，忠实谷粉兼果粉，喜欢看书听歌旅游,喜欢研究各种的技术~~ 联系我: Email(QQ): jay@huangjie.name Github : Jay-huangjie QQ: 289223562 CSDN: _杰哥 简书:我是黄教主啊]]></content>
  </entry>
  <entry>
    <title><![CDATA[分类]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[tags]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
